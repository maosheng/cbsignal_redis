! function(e, t) {
	"object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.Hls = t() : e.Hls = t()
}(self, (() => (() => {
	var __webpack_modules__ = {
			949: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var n = t[r];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
						}
					}
					return function(t, r, n) {
						return r && e(t.prototype, r), n && e(t, n), t
					}
				}();
				t.createTimeoutGenerator = function() {
					return new o((function(e) {
						var t = void 0;
						return {
							execute: function() {
								t = setTimeout(e, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e3)
							},
							cancel: function() {
								clearTimeout(t)
							}
						}
					}))
				};
				var n = 1,
					i = 2,
					s = 3,
					a = 4;
				var o = function() {
					function e(t) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, e), this.generator = t, this.status = n, this.next = this.next.bind(this)
					}
					return r(e, [{
						key: "next",
						value: function(e) {
							if (this.status === a) return console.warn("status is canceled");
							if (this.status === i) return console.warn("status is waiting");
							var t = this.execute.bind(this, this.cb);
							this.nextInfo = this.generator(t), this.status = i, this.nextInfo.execute(e)
						}
					}, {
						key: "execute",
						value: function(e, t) {
							this.status = s, e.apply(t, [this.next])
						}
					}, {
						key: "cancel",
						value: function() {
							this.status = a, this.nextInfo && "function" == typeof this.nextInfo.cancel && this.nextInfo.cancel()
						}
					}, {
						key: "start",
						value: function(e, t) {
							if ("function" != typeof e) throw new SyntaxError("param cb must be a function");
							this.cb = e, this.next(t)
						}
					}, {
						key: "continue",
						value: function(e) {
							this.status = n, this.next(e)
						}
					}]), e
				}()
			},
			673: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function(e, t) {
						if (Array.isArray(e)) return e;
						if (Symbol.iterator in Object(e)) return function(e, t) {
							var r = [],
								n = !0,
								i = !1,
								s = void 0;
							try {
								for (var a, o = e[Symbol.iterator](); !(n = (a = o.next())
									.done) && (r.push(a.value), !t || r.length !== t); n = !0);
							} catch (e) {
								i = !0, s = e
							} finally {
								try {
									!n && o.return && o.return()
								} finally {
									if (i) throw s
								}
							}
							return r
						}(e, t);
						throw new TypeError("Invalid attempt to destructure non-iterable instance")
					},
					i = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					s = o(r(934)),
					a = o(r(356));

				function o(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}
				var l = function(e) {
					function t(e, r) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var n = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this, e, r));
						return n.requestingMap = new a.default, n.bitset = new Set, n.bitCounts = new Map, n
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), i(t, [{
						key: "handshakePeer",
						value: function(e) {
							this._setupDC(e), e.sendMetaData(Array.from(this.bitset), this.sequential, this.peersNum, this.isMobileNet)
						}
					}, {
						key: "handleMetaData",
						value: function(e, t) {
							var r = this;
							t.field && (e.bitset = new Set(t.field), t.field.forEach((function(e) {
								r.bitset.has(e) || r._increBitCounts(e)
							})), this.addPeer(e), this.downloadOnly && this.chokePeerRequest(e))
						}
					}, {
						key: "peersHas",
						value: function(e) {
							return this.bitCounts.has(e)
						}
					}, {
						key: "_decreBitCounts",
						value: function(e) {
							if (this.bitCounts.has(e)) {
								var t = this.bitCounts.get(e);
								1 === t ? this.bitCounts.delete(e) : this.bitCounts.set(e, t - 1)
							}
						}
					}, {
						key: "_increBitCounts",
						value: function(e) {
							if (this.bitCounts.has(e)) {
								var t = this.bitCounts.get(e);
								this.bitCounts.set(e, t + 1)
							} else this.bitCounts.set(e, 1)
						}
					}, {
						key: "reportDCTraffic",
						value: function(e, t, r) {
							if (this.engine.fetcher) {
								var n = this.engine.fetcher,
									i = t;
								this.bitset.has(e) || n.reportDCTraffic(i, r)
							} else this.logger.error("DC report failed")
						}
					}, {
						key: "cleanRequestingMap",
						value: function(e) {
							var t = this.peerManager.getPeer(e),
								r = !0,
								i = !1,
								s = void 0;
							try {
								for (var a, o = this.requestingMap.internalMap[Symbol.iterator](); !(r = (a = o.next())
									.done); r = !0) {
									var l = n(a.value, 2),
										u = l[0],
										c = l[1];
									c && c.includes(e) && (this.logger.info("delete " + u + " in requestingMap"), this.requestingMap.delete(u), this._decreBitCounts(u), t && t.bitset.delete(u))
								}
							} catch (e) {
								i = !0, s = e
							} finally {
								try {
									!r && o.return && o.return()
								} finally {
									if (i) throw s
								}
							}
						}
					}, {
						key: "getPeerLoadedMore",
						value: function(e) {
							if (!this.requestingMap.has(e)) return null;
							var t = this.requestingMap.getAllPeerIds(e);
							if (0 === t.length) return null;
							var r = this.peerManager.getPeer(t[0]);
							if (!r) return null;
							if (t.length > 1)
								for (var n = 1; n < t.length; n++) {
									var i = this.peerManager.getPeer(t[n]);
									i && i.bufArr.length > r.bufArr.length && (r = i)
								}
							return r
						}
					}]), t
				}(s.default);
				t.default = l, e.exports = t.default
			},
			304: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = {
					wsMaxRetries: 10,
					p2pEnabled: !0,
					wifiOnly: !1,
					memoryCacheLimit: {
						pc: 629145600,
						mobile: 314572800
					},
					dcDownloadTimeout: 25,
					logLevel: "error",
					tag: "",
					webRTCConfig: {},
					token: void 0,
					appName: void 0,
					appId: void 0,
					prefetchNum: 5,
					showSlogan: !1,
					trickleICE: !0,
					announceLocation: "cn",
					trackerZone: void 0,
					geoIpPreflight: !0,
					getStats: function(e, t, r) {},
					getPeerId: function(e) {},
					getPeersInfo: function(e) {}
				};
				t.default = r, e.exports = t.default
			},
			979: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
						return typeof e
					} : function(e) {
						return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
					},
					i = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					s = f(r(204)),
					a = f(r(88)),
					o = f(r(622)),
					l = r(901),
					u = f(r(542)),
					c = f(r(206)),
					d = f(r(497));

				function f(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function h(e) {
					if (Array.isArray(e)) {
						for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
						return r
					}
					return Array.from(e)
				}

				function g(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function v(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				var p = "nllL",
					m = "d3NzJ",
					y = "==",
					b = "TNBLy9z",
					E = "aWduY",
					_ = "mNvbQ",
					T = "WwuY2RuY",
					S = function(e) {
						function t() {
							var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							g(this, t);
							var r = v(this, (t.__proto__ || Object.getPrototypeOf(t))
								.call(this));
							if (r.p2pEnabled = !(!1 === e.p2pEnabled || "0" === (0, l.getQueryParam)("_p2p")), e.tag && e.tag.length > 20) throw new Error("Tag is too long");
							if (e.appName && e.appName.length > 30) throw new Error("appName is too long");
							if (e.appId && e.appId.length > 30) throw new Error("appId is too long");
							if (e.token && e.token.length > 20) throw new Error("Token is too long");
							return r
						}
						return function(e, t) {
							if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
							e.prototype = Object.create(t && t.prototype, {
								constructor: {
									value: e,
									enumerable: !1,
									writable: !0,
									configurable: !0
								}
							}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
						}(t, e), i(t, [{
							key: "initLogger",
							value: function() {
								var e = this.config;
								e.showSlogan && "en" === (0, l.navLang)() && console.log("%cLet the browsers become your unlimitedly scalable CDN!\n%c" + (0, l.getHomeUrl)(), "color: dodgerblue; padding:20px 0; font-size: x-large", "font-size: medium; padding-bottom:15px");
								var t = new a.default(e.logLevel);
								return e.logger = this.logger = t, t
							}
						}, {
							key: "getExtraForStats",
							value: function() {
								var e = {},
									t = this.tracker,
									r = t.scheduler;
								return r && r.isSeed() && (e.seed = !0, e.num_want = this._getNumWant(), t.DCMap.size <= t.maxConnsActive + 2 && (e.exclusions = [].concat(h(t.DCMap.keys()), h(t.failedDCSet.keys())))), e
							}
						}, {
							key: "getExtraForPeersRequest",
							value: function() {
								var e = {};
								return e.num_want = this._getNumWant(), e
							}
						}, {
							key: "_getNumWant",
							value: function() {
								var e = this.tracker,
									t = e.scheduler.peersNum;
								if (t > 0 && e.maxConnsActive - t > 0) return e.maxConnsActive - t
							}
						}, {
							key: "makeChannelId",
							value: function(e, t) {
								if (!e || "string" != typeof e) {
									var r = "token is required while using customized channelId!";
									throw console.error(r), new Error(r)
								}
								return function(r, n) {
									return e + "-" + t(r, n)
								}
							}
						}, {
							key: "makeSignalId",
							value: function() {
								var e = "",
									t = this.config,
									r = decodeURIComponent(window.atob(m + b + E + T + p + _ + y)),
									i = t.wsSignalerAddr;
								if (i) {
									var s = void 0;
									"object" === (void 0 === i ? "undefined" : n(i)) ? (i.main || (i.main = r), s = i.main) : "string" == typeof i && (s = i, t.wsSignalerAddr = {
										main: s
									}), s === r && (s = void 0), s && (e = o.default.parseURL(s)
										.netLoc.substr(2))
								} else t.wsSignalerAddr = {
									main: r,
									default: !0
								};
								return e
							}
						}, {
							key: "setupWindowListeners",
							value: function(e) {
								var t = this,
									r = ["iPad", "iPhone"].indexOf(navigator.platform) >= 0 ? "pagehide" : "beforeunload",
									n = function e() {
										t.fetcher && t.fetcher.postStatsWithBeacon(), t.p2pEnabled && t.disableP2P(), window.removeEventListener(r, e)
									};
								e ? window.removeEventListener(r, n) : window.addEventListener(r, n)
							}
						}, {
							key: "destroy",
							value: function() {
								this.disableP2P(!0), this.removeAllListeners(), this.setupWindowListeners(!0)
							}
						}, {
							key: "enableP2P",
							value: function() {
								return this.p2pEnabled ? null : (this.logger && this.logger.info("enable P2P"), this.config.p2pEnabled = this.p2pEnabled = !0, this.browserInfo ? (this._init(this.channel, this.browserInfo), this) : null)
							}
						}, {
							key: "commonBrowserInfo",
							get: function() {
								var e = c.default.getPlatform(),
									t = c.default.getNetType() || "wifi";
								return this.netType = t, {
									device: e,
									netType: t,
									player: (0, d.default)() || void 0
								}
							}
						}, {
							key: "isMobileNet",
							get: function() {
								return "wifi" !== this.netType && "ethernet" !== this.netType
							}
						}, {
							key: "version",
							get: function() {
								return t.version
							}
						}], [{
							key: "isSupported",
							value: function() {
								var e = (0, l.getBrowserRTC)();
								return !(!e || void 0 === e.RTCPeerConnection.prototype.createDataChannel)
							}
						}, {
							key: "TrackerZone",
							get: function() {
								return {
									CN: "cn",
									EU: "eu",
									HK: "hk",
									USA: "us"
								}
							}
						}]), t
					}(s.default);
				S.version = "1.21.0", S.protocolVersion = u.default.VERSION, t.default = S, e.exports = t.default
			},
			784: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.default = {
					DC_SIGNAL: "SIGNAL",
					DC_OPEN: "OPEN",
					DC_REQUEST: "REQUEST",
					DC_SEND_REQUEST: "SEND_REQUEST",
					DC_PIECE_NOT_FOUND: "PIECE_NOT_FOUND",
					DC_PIECE_ABORT: "PIECE_ABORT",
					DC_PIECE_CANCEL: "PIECE_CANCEL",
					DC_CLOSE: "CLOSE",
					DC_RESPONSE: "RESPONSE",
					DC_ERROR: "ERROR",
					DC_PIECE: "PIECE",
					DC_PIECE_DATA: "PIECE_DATA",
					DC_TIMEOUT: "TIMEOUT",
					DC_PIECE_ACK: "PIECE_ACK",
					DC_METADATA: "METADATA",
					DC_PLAT_ANDROID: "ANDROID",
					DC_PLAT_IOS: "IOS",
					DC_PLAT_WEB: "WEB",
					DC_CHOKE: "CHOKE",
					DC_UNCHOKE: "UNCHOKE",
					DC_HAVE: "HAVE",
					DC_HAVE_REVERSE: "HAVE_REVERSE",
					DC_LOST: "LOST",
					DC_GET_PEERS: "GET_PEERS",
					DC_PEERS: "PEERS",
					DC_STATS: "STATS",
					DC_PEER_SIGNAL: "PEER_SIGNAL",
					DC_PLAYLIST: "PLAYLIST",
					BM_LOST: "lost",
					BM_ADDED_SEG_: "BM_ADDED_SEG_",
					BM_ADDED_SN_: "BM_ADDED_SN_",
					BM_SEG_ADDED: "BM_SEG_ADDED",
					FRAG_CHANGED: "FRAG_CHANGED",
					FRAG_LOADED: "FRAG_LOADED",
					FRAG_LOADING: "FRAG_LOADING",
					RESTART_P2P: "RESTART_P2P",
					EXCEPTION: "exception",
					REQUESTING_MAP_HAVE: "REQUESTING_MAP_HAVE",
					BUILDER_MAP_HAVE: "BUILDER_MAP_HAVE",
					SYN_OUTPUT: "SYN_OUTPUT",
					SYN_ERROR: "SYN_ERROR",
					SYN_PARTIAL: "SYN_PARTIAL",
					SVR_PEERS: "SVR_PEERS"
				}, e.exports = t.default
			},
			746: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
						return typeof e
					} : function(e) {
						return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
					},
					i = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					s = r(901),
					a = u(r(204)),
					o = u(r(3)),
					l = r(9);

				function u(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function c(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				var d = 65536;

				function f(e) {
					return e.replace(/a=ice-options:trickle\s\n/g, "")
				}
				var h = function(e) {
					function t(e) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var r = c(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this));
						r.channelName = e.initiator ? e.channelName : null, r.initiator = e.initiator || !1, r.channelConfig = e.channelConfig || t.channelConfig, r.channelNegotiated = r.channelConfig.negotiated, r.config = Object.assign({}, t.config, e.config), r.offerOptions = e.offerOptions || {}, r.answerOptions = e.answerOptions || {}, r.sdpTransform = e.sdpTransform || function(e) {
							return e
						}, r.trickle = void 0 === e.trickle || e.trickle, r.allowHalfTrickle = void 0 !== e.allowHalfTrickle && e.allowHalfTrickle, r.iceCompleteTimeout = e.iceCompleteTimeout || 5e3, r.destroyed = !1, r.destroying = !1, r._connected = !1, r.remoteAddress = void 0, r.remoteFamily = void 0, r.remotePort = void 0, r.localAddress = void 0, r.localFamily = void 0, r.localPort = void 0, r._wrtc = e.wrtc && "object" === n(e.wrtc) ? e.wrtc : (0, s.getBrowserRTC)(), r._pcReady = !1, r._channelReady = !1, r._iceComplete = !1, r._iceCompleteTimer = null, r._channel = null, r._pendingCandidates = [], r._isNegotiating = !1, r._firstNegotiation = !0, r._batchedNegotiation = !1, r._queuedNegotiation = !1, r._sendersAwaitingStable = [], r._senderMap = new Map, r._closingInterval = null, r._chunk = null, r._cb = null, r._interval = null;
						try {
							r._pc = new r._wrtc.RTCPeerConnection(r.config)
						} catch (e) {
							return (0, o.default)((function() {
								return r.destroy(e)
							})), c(r)
						}
						return r._isReactNativeWebrtc = "number" == typeof r._pc._peerConnectionId, r._pc.oniceconnectionstatechange = function() {
							r._onIceStateChange()
						}, r._pc.onicegatheringstatechange = function() {
							r._onIceStateChange()
						}, r._pc.onconnectionstatechange = function() {
							r._onConnectionStateChange()
						}, r._pc.onsignalingstatechange = function() {
							r._onSignalingStateChange()
						}, r._pc.onicecandidate = function(e) {
							r._onIceCandidate(e)
						}, r.initiator || r.channelNegotiated ? r._setupData({
							channel: r._pc.createDataChannel(r.channelName, r.channelConfig)
						}) : r._pc.ondatachannel = function(e) {
							r._setupData(e)
						}, r._needsNegotiation(), r
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), i(t, [{
						key: "signal",
						value: function(e) {
							var t = this;
							if (this.destroyed) throw new Error("cannot signal after peer is destroyed");
							if ("string" == typeof e) try {
								e = JSON.parse(e)
							} catch (t) {
								e = {}
							}
							e.renegotiate && this.initiator && this._needsNegotiation(), e.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e.candidate) : this._pendingCandidates.push(e.candidate)), e.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e))
								.then((function() {
									t.destroyed || (t._pendingCandidates.forEach((function(e) {
										t._addIceCandidate(e)
									})), t._pendingCandidates = [], "offer" === t._pc.remoteDescription.type && t._createAnswer())
								}))
								.catch((function(e) {
									t.destroy(e)
								})), e.sdp || e.candidate || e.renegotiate || e.transceiverRequest || this.destroy(new Error("signal() called with invalid signal data"))
						}
					}, {
						key: "_addIceCandidate",
						value: function(e) {
							var t = this,
								r = new this._wrtc.RTCIceCandidate(e);
							this._pc.addIceCandidate(r)
								.catch((function(e) {
									var n;
									!r.address || r.address.endsWith(".local") ? (n = "Ignoring unsupported ICE candidate.", console.warn(n)) : t.destroy(e)
								}))
						}
					}, {
						key: "send",
						value: function(e) {
							this._channel.send(e)
						}
					}, {
						key: "_needsNegotiation",
						value: function() {
							var e = this;
							this._batchedNegotiation || (this._batchedNegotiation = !0, (0, o.default)((function() {
								e._batchedNegotiation = !1, !e.initiator && e._firstNegotiation || e.negotiate(), e._firstNegotiation = !1
							})))
						}
					}, {
						key: "negotiate",
						value: function() {
							var e = this;
							this.initiator ? this._isNegotiating ? this._queuedNegotiation = !0 : setTimeout((function() {
								e._createOffer()
							}), 0) : this._isNegotiating ? this._queuedNegotiation = !0 : this.emit("signal", {
								type: "renegotiate",
								renegotiate: !0
							}), this._isNegotiating = !0
						}
					}, {
						key: "destroy",
						value: function(e) {
							this._destroy(e)
						}
					}, {
						key: "_destroy",
						value: function(e) {
							var t = this;
							this.destroyed || this.destroying || (this.destroying = !0, (0, o.default)((function() {
								if (t.destroyed = !0, t.destroying = !1, t._connected = !1, t._pcReady = !1, t._channelReady = !1, t._senderMap = null, clearInterval(t._closingInterval), t._closingInterval = null, clearInterval(t._interval), t._interval = null, t._chunk = null, t._cb = null, t._channel) {
									try {
										t._channel.close()
									} catch (e) {}
									t._channel.onmessage = null, t._channel.onopen = null, t._channel.onclose = null, t._channel.onerror = null
								}
								if (t._pc) {
									try {
										t._pc.close()
									} catch (e) {}
									t._pc.oniceconnectionstatechange = null, t._pc.onicegatheringstatechange = null, t._pc.onsignalingstatechange = null, t._pc.onicecandidate = null, t._pc.ondatachannel = null
								}
								t._pc = null, t._channel = null, e && t.emit("error", e), t.emit("close")
							})))
						}
					}, {
						key: "_setupData",
						value: function(e) {
							var t = this;
							if (!e.channel) return this.destroy(new Error("Data channel event is missing `channel` property"));
							this._channel = e.channel, this._channel.binaryType = "arraybuffer", "number" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = d), this.channelName = this._channel.label, this._channel.onmessage = function(e) {
								t._onChannelMessage(e)
							}, this._channel.onbufferedamountlow = function() {
								t._onChannelBufferedAmountLow()
							}, this._channel.onopen = function() {
								t._onChannelOpen()
							}, this._channel.onclose = function() {
								t._onChannelClose()
							}, this._channel.onerror = function(e) {
								t.destroy(e)
							};
							var r = !1;
							this._closingInterval = setInterval((function() {
								t._channel && "closing" === t._channel.readyState ? (r && t._onChannelClose(), r = !0) : r = !1
							}), 5e3)
						}
					}, {
						key: "write",
						value: function(e, t) {
							if (this.destroyed) return t(new Error("cannot write after peer is destroyed"));
							if (this._connected) {
								try {
									this.send(e)
								} catch (e) {
									return this.destroy(e)
								}
								this.isBufferedAmountHigh ? this._cb = t : t(null)
							} else this._chunk = e, this._cb = t
						}
					}, {
						key: "_startIceCompleteTimeout",
						value: function() {
							var e = this;
							this.destroyed || this._iceCompleteTimer || (this._iceCompleteTimer = setTimeout((function() {
								e._iceComplete || (e._iceComplete = !0, e.emit("iceTimeout"), e.emit("_iceComplete"))
							}), this.iceCompleteTimeout))
						}
					}, {
						key: "_createOffer",
						value: function() {
							var e = this;
							this.destroyed || this._pc.createOffer(this.offerOptions)
								.then((function(t) {
									if (!e.destroyed) {
										e.trickle || e.allowHalfTrickle || (t.sdp = f(t.sdp)), t.sdp = e.sdpTransform(t.sdp);
										var r = function() {
											if (!e.destroyed) {
												var r = e._pc.localDescription || t;
												e.emit("signal", {
													type: r.type,
													sdp: r.sdp
												})
											}
										};
										e._pc.setLocalDescription(t)
											.then((function() {
												e.destroyed || (e.trickle || e._iceComplete ? r() : e.once("_iceComplete", r))
											}))
											.catch((function(t) {
												e.destroy(t)
											}))
									}
								}))
								.catch((function(t) {
									e.destroy(t)
								}))
						}
					}, {
						key: "_createAnswer",
						value: function() {
							var e = this;
							this.destroyed || this._pc.createAnswer(this.answerOptions)
								.then((function(t) {
									if (!e.destroyed) {
										e.trickle || e.allowHalfTrickle || (t.sdp = f(t.sdp)), t.sdp = e.sdpTransform(t.sdp);
										var r = function() {
											if (!e.destroyed) {
												var r = e._pc.localDescription || t;
												e.emit("signal", {
													type: r.type,
													sdp: r.sdp
												})
											}
										};
										e._pc.setLocalDescription(t)
											.then((function() {
												e.destroyed || (e.trickle || e._iceComplete ? r() : e.once("_iceComplete", r))
											}))
											.catch((function(t) {
												e.destroy(t)
											}))
									}
								}))
								.catch((function(t) {
									e.destroy(t)
								}))
						}
					}, {
						key: "_onConnectionStateChange",
						value: function() {
							this.destroyed || "failed" === this._pc.connectionState && this.destroy(new Error("Connection failed."))
						}
					}, {
						key: "_onIceStateChange",
						value: function() {
							if (!this.destroyed) {
								var e = this._pc.iceConnectionState,
									t = this._pc.iceGatheringState;
								this.emit("iceStateChange", e, t), "connected" !== e && "completed" !== e || (this._pcReady = !0, this._maybeReady()), "failed" === e && this.destroy(new Error("Ice connection failed.")), "closed" === e && this.destroy(new Error("Ice connection closed."))
							}
						}
					}, {
						key: "getStats",
						value: function(e) {
							var t = this,
								r = function(e) {
									return "[object Array]" === Object.prototype.toString.call(e.values) && e.values.forEach((function(t) {
										Object.assign(e, t)
									})), e
								};
							0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats()
								.then((function(t) {
									var n = [];
									t.forEach((function(e) {
										n.push(r(e))
									})), e(null, n)
								}), (function(t) {
									return e(t)
								})) : this._pc.getStats.length > 0 ? this._pc.getStats((function(n) {
									if (!t.destroyed) {
										var i = [];
										n.result()
											.forEach((function(e) {
												var t = {};
												e.names()
													.forEach((function(r) {
														t[r] = e.stat(r)
													})), t.id = e.id, t.type = e.type, t.timestamp = e.timestamp, i.push(r(t))
											})), e(null, i)
									}
								}), (function(t) {
									return e(t)
								})) : e(null, [])
						}
					}, {
						key: "_maybeReady",
						value: function() {
							var e = this;
							if (!this._connected && !this._connecting && this._pcReady && this._channelReady) {
								this._connecting = !0;
								! function t() {
									e.destroyed || e.getStats((function(r, n) {
										if (!e.destroyed) {
											r && (n = []);
											var i = {},
												s = {},
												a = {},
												o = !1;
											n.forEach((function(e) {
												"remotecandidate" !== e.type && "remote-candidate" !== e.type || (i[e.id] = e), "localcandidate" !== e.type && "local-candidate" !== e.type || (s[e.id] = e), "candidatepair" !== e.type && "candidate-pair" !== e.type || (a[e.id] = e)
											}));
											var l = function(t) {
												o = !0;
												var r = s[t.localCandidateId];
												r && (r.ip || r.address) ? (e.localAddress = r.ip || r.address, e.localPort = Number(r.port)) : r && r.ipAddress ? (e.localAddress = r.ipAddress, e.localPort = Number(r.portNumber)) : "string" == typeof t.googLocalAddress && (r = t.googLocalAddress.split(":"), e.localAddress = r[0], e.localPort = Number(r[1])), e.localAddress && (e.localFamily = e.localAddress.includes(":") ? "IPv6" : "IPv4");
												var n = i[t.remoteCandidateId];
												n && (n.ip || n.address) ? (e.remoteAddress = n.ip || n.address, e.remotePort = Number(n.port)) : n && n.ipAddress ? (e.remoteAddress = n.ipAddress, e.remotePort = Number(n.portNumber)) : "string" == typeof t.googRemoteAddress && (n = t.googRemoteAddress.split(":"), e.remoteAddress = n[0], e.remotePort = Number(n[1])), e.remoteAddress && (e.remoteFamily = e.remoteAddress.includes(":") ? "IPv6" : "IPv4")
											};
											if (n.forEach((function(e) {
													"transport" === e.type && e.selectedCandidatePairId && l(a[e.selectedCandidatePairId]), ("googCandidatePair" === e.type && "true" === e.googActiveConnection || ("candidatepair" === e.type || "candidate-pair" === e.type) && e.selected) && l(e)
												})), o || Object.keys(a)
												.length && !Object.keys(s)
												.length) {
												if (e._connecting = !1, e._connected = !0, e._chunk) {
													try {
														e.send(e._chunk)
													} catch (r) {
														return e.destroy(r)
													}
													e._chunk = null;
													var u = e._cb;
													e._cb = null, u(null)
												}
												"number" != typeof e._channel.bufferedAmountLowThreshold && (e._interval = setInterval((function() {
													return e._onInterval()
												}), 150), e._interval.unref && e._interval.unref()), e.emit("connect")
											} else setTimeout(t, 100)
										}
									}))
								}()
							}
						}
					}, {
						key: "_onInterval",
						value: function() {
							!this._cb || !this._channel || this._channel.bufferedAmount > d || this._onChannelBufferedAmountLow()
						}
					}, {
						key: "_onSignalingStateChange",
						value: function() {
							var e = this;
							this.destroyed || ("stable" === this._pc.signalingState && (this._isNegotiating = !1, this._sendersAwaitingStable.forEach((function(t) {
								e._pc.removeTrack(t), e._queuedNegotiation = !0
							})), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._queuedNegotiation = !1, this._needsNegotiation()) : this.emit("negotiated")), this.emit("signalingStateChange", this._pc.signalingState))
						}
					}, {
						key: "_onIceCandidate",
						value: function(e) {
							this.destroyed || (e.candidate && this.trickle ? this.emit("signal", {
								type: "candidate",
								candidate: {
									candidate: e.candidate.candidate,
									sdpMLineIndex: e.candidate.sdpMLineIndex,
									sdpMid: e.candidate.sdpMid
								}
							}) : e.candidate || this._iceComplete || (this._iceComplete = !0, this.emit("_iceComplete")), e.candidate && this._startIceCompleteTimeout())
						}
					}, {
						key: "_onChannelMessage",
						value: function(e) {
							if (!this.destroyed) {
								var t = e.data;
								t instanceof ArrayBuffer && (t = l.Buffer.from(t)), this.emit("data", t)
							}
						}
					}, {
						key: "_onChannelBufferedAmountLow",
						value: function() {
							if (!this.destroyed && this._cb) {
								var e = this._cb;
								this._cb = null, e(null)
							}
						}
					}, {
						key: "_onChannelOpen",
						value: function() {
							this._connected || this.destroyed || (this._channelReady = !0, this._maybeReady())
						}
					}, {
						key: "_onChannelClose",
						value: function() {
							this.destroyed || this.destroy()
						}
					}, {
						key: "bufferSize",
						get: function() {
							return this._channel && this._channel.bufferedAmount || 0
						}
					}, {
						key: "connected",
						get: function() {
							return this._connected && "open" === this._channel.readyState
						}
					}, {
						key: "isBufferedAmountHigh",
						get: function() {
							return this._channel.bufferedAmount > d
						}
					}]), t
				}(a.default);
				h.config = {
					iceServers: [{
						urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"]
					}],
					sdpSemantics: "unified-plan"
				}, h.channelConfig = {}, t.default = h, e.exports = t.default
			},
			931: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var n = t[r];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
						}
					}
					return function(t, r, n) {
						return r && e(t.prototype, r), n && e(t, n), t
					}
				}();

				function n(e) {
					if (Array.isArray(e)) {
						for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
						return r
					}
					return Array.from(e)
				}
				var i = function() {
					function e() {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, e), this.peerMap = new Map
					}
					return r(e, [{
						key: "isEmpty",
						value: function() {
							return 0 === this.peerMap.size
						}
					}, {
						key: "size",
						value: function() {
							return this.peerMap.size
						}
					}, {
						key: "clear",
						value: function() {
							this.peerMap.clear()
						}
					}, {
						key: "getPeers",
						value: function() {
							return [].concat(n(this.peerMap.values()))
						}
					}, {
						key: "getPeerValues",
						value: function() {
							return this.peerMap.values()
						}
					}, {
						key: "hasPeer",
						value: function(e) {
							return this.peerMap.has(e)
						}
					}, {
						key: "addPeer",
						value: function(e, t) {
							this.peerMap.set(e, t)
						}
					}, {
						key: "getPeerIds",
						value: function() {
							return [].concat(n(this.peerMap.keys()))
						}
					}, {
						key: "removePeer",
						value: function(e) {
							this.peerMap.delete(e)
						}
					}, {
						key: "getPeersOrderByWeight",
						value: function() {
							var e = this.getAvailablePeers();
							return e.sort((function(e, t) {
								return 0 === t.weight ? 1 : 0 === e.weight ? -1 : t.weight - e.weight
							})), e
						}
					}, {
						key: "getPeer",
						value: function(e) {
							return this.peerMap.get(e)
						}
					}, {
						key: "getAvailablePeers",
						value: function() {
							return this.getPeers()
								.filter((function(e) {
									return e.isAvailableUrgently
								}))
						}
					}]), e
				}();
				t.default = i, e.exports = t.default
			},
			226: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n, i = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					s = r(531),
					a = (n = s) && n.__esModule ? n : {
						default: n
					};

				function o(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}
				var l = function() {
					function e(t, r) {
						var n = this,
							i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 15;
						o(this, e), this.engine = t, this.config = r, this.trickle = r.waitForPeer, this.poolSize = i, this.pool = [];
						for (var s = 0; s < i; s++) this.pool.push(this._createPeer());
						this.timer = setTimeout((function() {
							n.destroy()
						}), 2e4)
					}
					return i(e, [{
						key: "_createPeer",
						value: function() {
							return new a.default(this.engine, void 0, void 0, !0, this.config, {
								trickle: this.trickle
							})
						}
					}, {
						key: "getPeer",
						value: function() {
							return 0 === this.size ? this._createPeer() : this.pool.shift()
						}
					}, {
						key: "destroy",
						value: function() {
							var e = !0,
								t = !1,
								r = void 0;
							try {
								for (var n, i = this.pool[Symbol.iterator](); !(e = (n = i.next())
									.done); e = !0) {
									n.value.destroy(!0)
								}
							} catch (e) {
								t = !0, r = e
							} finally {
								try {
									!e && i.return && i.return()
								} finally {
									if (t) throw r
								}
							}
							this.pool = [], clearTimeout(this.timer)
						}
					}, {
						key: "size",
						get: function() {
							return this.pool.length
						}
					}]), e
				}();
				t.default = l, e.exports = t.default
			},
			542: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = Object.assign || function(e) {
						for (var t = 1; t < arguments.length; t++) {
							var r = arguments[t];
							for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
						}
						return e
					},
					i = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					s = f(r(746)),
					a = f(r(204)),
					o = f(r(784)),
					l = r(901),
					u = f(r(893)),
					c = f(r(206)),
					d = r(9);

				function f(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function h(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function g(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				var v = function(e) {
					function t(e, r, i, s, a) {
						var o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
						h(this, t);
						var u = g(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this));
						u.channel = e.fetcher.channelId, u.logger = e.logger, u.config = a, u.isInitiator = s, u.options = o, u.intermediator = o.intermediator || null, u.signalMsgs = [], u.assignPeerId(r, i), u.platform = "unknown", u.mobile = !1, u.mobileWeb = !1, u.mobileNet = !1, u.connected = !1, u.msgQueue = [], u.miss = 0, u.notifySet = new Set, u.bufArr = [], u.packetSize = l.DEFAULT_PACKET_SIZE, u.sendReqQueue = [], u.downloading = !1, u.uploading = !1, u.choked = !1, u.streamListeners = [], u.pieceMsg = {}, u.uploadInterrupter = {
							targetSegId: void 0,
							currentSegId: void 0,
							canceled: !1
						}, u.datasToSend = [], u.bytesUploaded = 0, u.dataWriting = !1, u.timeSendRequest = 0, u.timeReceivePiece = 0, u.timeSendPiece = 0, u.weight = 0, u.peersConnected = 1, u.uploadSpeed = 0, u.gotPeers = !1, u.currentLevel = 0, u.currentPos = 0, u.useBackupSignal = !1, u.webRTCConfig = {};
						var c = u.options.stuns;
						if (c && c.length > 0) {
							var d = [];
							c.forEach((function(e) {
								u.logger.info("use stun " + e), d.push({
									urls: e
								})
							})), u.webRTCConfig.iceServers = d
						}
						return u.config.webRTCConfig && (u.webRTCConfig = n({}, u.config.webRTCConfig, u.webRTCConfig)), u.playlistMap = new Map, u._initPeerChannel(), u.notFatalClosed = !1, u.startSN = Number.MAX_SAFE_INTEGER, u.endSN = -1, u._loadedBytes = 0, u
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), i(t, null, [{
						key: "defaultPacketSize",
						get: function() {
							return l.DEFAULT_PACKET_SIZE
						}
					}, {
						key: "VERSION",
						get: function() {
							return "5"
						}
					}]), i(t, [{
						key: "assignPeerId",
						value: function(e, t) {
							var r = this;
							this.remotePeerId = t, this.channelId = this.isInitiator ? e + "-" + t : t + "-" + e, t && (this.timeJoin = (0, l.getCurrentTs)(), this.dataExchangeTs = this.timeJoin, this.gotStatsTs = this.timeJoin, this._startTimer()), setTimeout((function() {
								var e = !0,
									t = !1,
									n = void 0;
								try {
									for (var i, s = r.signalMsgs[Symbol.iterator](); !(e = (i = s.next())
										.done); e = !0) {
										var a = i.value;
										r.emit(o.default.DC_SIGNAL, a, !0)
									}
								} catch (e) {
									t = !0, n = e
								} finally {
									try {
										!e && s.return && s.return()
									} finally {
										if (t) throw n
									}
								}
							}), 0)
						}
					}, {
						key: "_startTimer",
						value: function() {
							var e = this;
							this.connTimeout = setTimeout((function() {
								e.logger.warn("dc " + e.channelId + " connection timeout"), e.emit(o.default.DC_TIMEOUT)
							}), 25e3)
						}
					}, {
						key: "cancelDownload",
						value: function(e, t, r) {
							if (r && this.downloading && !(this.streamListeners.length > 0 || this.remainAttachments <= 2)) return this.logger.info("cancel download " + r + " remain packets " + this.remainAttachments), this.timeReceivePiece = 0, this.sendJson({
								event: o.default.DC_PIECE_CANCEL,
								sn: e,
								level: t,
								seg_id: r
							})
						}
					}, {
						key: "addStreamListener",
						value: function(e, t, r) {
							this.streamListeners.push({
								handler: r,
								peerId: t
							})
						}
					}, {
						key: "removeStreamListener",
						value: function(e) {
							this.streamListeners = this.streamListeners.filter((function(t) {
								return t.peerId !== e || (t.handler(void 0, void 0, !0, "aborted by cancel"), !1)
							}))
						}
					}, {
						key: "_initPeerChannel",
						value: function() {
							var e = this,
								t = new s.default({
									initiator: this.isInitiator,
									trickle: this.options.trickle || !1,
									config: this.webRTCConfig
								});
							this._datachannel = t, t.on("error", (function(t) {
								var r = !0;
								"Ice connection failed." === t.message && e.notFatalClosed && (r = !1), e.emit(o.default.DC_ERROR, r)
							})), t.on("signal", (function(t) {
								e.signalMsgs.push(t), e.emit(o.default.DC_SIGNAL, t)
							}));
							t.on("connect", (function() {
								for (e.logger.info("datachannel CONNECTED to " + e.remotePeerId + " from " + (e.intermediator ? "peer" : "server")), e.connected = !0, clearTimeout(e.connTimeout), e.signalMsgs = [], e.emit(o.default.DC_OPEN); e.msgQueue.length > 0;) {
									var t = e.msgQueue.shift();
									e.emit(t.event, t)
								}
							})), t.on("data", (function(t) {
								var r = e.logger;
								if ("string" == typeof t) {
									var n = JSON.parse(t);
									if (!e.connected) return void e.msgQueue.push(n);
									var i = n.event,
										s = void 0;
									switch (s = i !== o.default.DC_PLAYLIST && i !== o.default.DC_PEER_SIGNAL ? "string: " + t : "event: " + i, r.debug("datachannel receive " + s + " from " + e.remotePeerId), i) {
										case o.default.DC_HAVE:
											if (e.emit(n.event, n), !n.sn) return;
											e.config.live || (n.sn < e.startSN && (e.startSN = n.sn), n.sn > e.endSN && (e.endSN = n.sn));
											break;
										case o.default.DC_PIECE:
											e.downloading = !0, e.dataExchangeTs = (0, l.getCurrentTs)(), e.timeReceivePiece = performance.now(), e.pieceMsg = n, e._prepareForBinary(n.attachments, n.seg_id, n.sn, n.size), e.emit(n.event, n);
											break;
										case o.default.DC_PIECE_CANCEL:
											e.uploadInterrupter.targetSegId = n.seg_id, e.emit(n.event, n);
											break;
										case o.default.DC_PIECE_NOT_FOUND:
											e._sendNextReq() || (e.downloading = !1), e.emit(n.event, n);
											break;
										case o.default.DC_REQUEST:
											e._handleRequestMsg(n);
											break;
										case o.default.DC_PIECE_ACK:
											e.uploadInterrupter.canceled || (e._handlePieceAck(n.size, n.miss), e.emit(n.event, n));
											break;
										case o.default.DC_STATS:
											e._handleStats(n);
											break;
										case o.default.DC_PLAYLIST:
											e.config.sharePlaylist && e._handlePlaylist(n);
											break;
										case o.default.DC_METADATA:
											e._handleMetadata(n);
											break;
										case o.default.DC_PIECE_ABORT:
											e.downloading && (e._notifyDownloadListenersAbort("aborted by upstream peer"), e.emit(o.default.DC_PIECE_ABORT, n));
											break;
										case o.default.DC_CHOKE:
											r.info("choke peer " + e.remotePeerId), e.choked = !0;
											break;
										case o.default.DC_UNCHOKE:
											r.info("unchoke peer " + e.remotePeerId), e.choked = !1;
											break;
										case o.default.DC_CLOSE:
											e.emit(n.event, n.fatal || !1);
											break;
										default:
											e.emit(n.event, n)
									}
								} else {
									if (!e.downloading) return void r.warn("peer not downloading, data size " + t.byteLength + " pieceMsg " + JSON.stringify(e.pieceMsg));
									e._handleBinaryMsg(t)
								}
							})), t.once("close", (function() {
								e.emit(o.default.DC_CLOSE, !1)
							})), t.on("iceStateChange", (function(t, r) {
								"disconnected" === t && (e.logger.warn(e.remotePeerId + " disconnected"), e.connected = !1)
							}))
						}
					}, {
						key: "sendJson",
						value: function(e) {
							e.event !== o.default.DC_PLAYLIST && e.event !== o.default.DC_PEER_SIGNAL ? this.logger.debug("dc bufferSize " + this._datachannel.bufferSize + " send " + JSON.stringify(e) + " to " + this.remotePeerId) : this.logger.debug("dc send event " + e.event + " to " + this.remotePeerId);
							var t = JSON.stringify(e);
							return t.length > l.DEFAULT_PACKET_SIZE ? (this.logger.error("string to send is too large"), !1) : this.send(t, !1)
						}
					}, {
						key: "send",
						value: function(e) {
							var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
							return t ? (this.datasToSend.push(e), this.dataWriting || this._sendDataSync(), !0) : this.sendImmediately(e)
						}
					}, {
						key: "_checkIfNeedInterrupt",
						value: function() {
							var e = this.uploadInterrupter,
								t = e.targetSegId,
								r = e.currentSegId;
							return !!e.canceled || !(!t || t !== r) && (this.logger.info("cancel send data"), this.sendMsgPieceAbort(r + " transfer canceled"), this.datasToSend = [], this.uploadInterrupter.canceled = !0, this._handlePieceAck(this.bytesUploaded, 0), this.emit(o.default.DC_PIECE_ACK, {
								seg_id: r,
								size: this.bytesUploaded,
								canceled: !0
							}), !0)
						}
					}, {
						key: "_sendDataSync",
						value: function() {
							var e = this;
							if (this._checkIfNeedInterrupt() || 0 === this.datasToSend.length) this.dataWriting = !1;
							else {
								this.dataWriting = !0;
								var t = this.datasToSend.shift();
								this.bytesUploaded += t.byteLength, this._datachannel.write(t, (function(t) {
									if (t) return e.dataWriting = !1, e.logger.warn(t.message), void e.emit(o.default.DC_ERROR, !1);
									e._sendDataSync()
								}))
							}
						}
					}, {
						key: "sendImmediately",
						value: function(e) {
							if (this._datachannel.connected) try {
								return this._datachannel.send(e), !0
							} catch (e) {
								this.logger.warn("datachannel " + this.channelId + " send data failed, close it"), this.emit(o.default.DC_ERROR, !1)
							}
							return !1
						}
					}, {
						key: "sendMsgHave",
						value: function(e, t) {
							var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
								i = r.reverse || void 0;
							delete r.reverse, this.sendJson(n({
								event: i ? o.default.DC_HAVE_REVERSE : o.default.DC_HAVE,
								sn: e,
								seg_id: t
							}, r))
						}
					}, {
						key: "sendPieceNotFound",
						value: function(e, t) {
							var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
							this.uploading = !1, this.sendJson(n({
								event: o.default.DC_PIECE_NOT_FOUND,
								seg_id: t,
								sn: e
							}, r))
						}
					}, {
						key: "sendPeers",
						value: function(e) {
							this.sendJson({
								event: o.default.DC_PEERS,
								peers: e
							})
						}
					}, {
						key: "sendPeersRequest",
						value: function() {
							this.sendJson({
								event: o.default.DC_GET_PEERS
							})
						}
					}, {
						key: "sendMsgStats",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
								r = n({
									event: o.default.DC_STATS,
									total_conns: e
								}, t);
							this.sendJson(r)
						}
					}, {
						key: "sendMsgPlaylist",
						value: function(e, t, r) {
							var n = this.playlistMap.get(e);
							if (!(n && n.seq >= r)) {
								var i = {
									event: o.default.DC_PLAYLIST,
									url: e,
									data: t,
									seq: r
								};
								this.playlistMap.set(e, {
									data: t,
									seq: r
								}), this.sendJson(i)
							}
						}
					}, {
						key: "sendMsgSignal",
						value: function(e, t, r) {
							return this.sendJson({
								event: o.default.DC_PEER_SIGNAL,
								action: "signal",
								to_peer_id: e,
								from_peer_id: t,
								data: r
							})
						}
					}, {
						key: "sendMsgSignalReject",
						value: function(e, t, r) {
							var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
							return this.sendJson({
								event: o.default.DC_PEER_SIGNAL,
								action: "reject",
								to_peer_id: e,
								from_peer_id: t,
								reason: r,
								fatal: n
							})
						}
					}, {
						key: "sendMetaData",
						value: function(e, t, r) {
							var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
							this.isInitiator && (this.timeSendRequest = performance.now()), this.sendJson({
								event: o.default.DC_METADATA,
								field: e,
								platform: o.default.DC_PLAT_WEB,
								mobile: !!c.default.isMobile(),
								mobile_net: n,
								channel: this.channel,
								version: "1.21.0",
								sequential: t,
								peers: r
							})
						}
					}, {
						key: "sendPartialBuffer",
						value: function(e, t) {
							var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
							this.sendMsgPiece(e, r);
							for (var n = 0; n < t.length; n++) this.send(t[n])
						}
					}, {
						key: "sendMsgPiece",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
								r = this.uploadInterrupter.targetSegId;
							if (r && r === e.seg_id) return this.logger.info("cancel send piece msg"), this.sendMsgPieceAbort(r + " piece canceled"), void(this.uploadInterrupter.canceled = !0);
							this.uploadInterrupter = {
								currentSegId: e.seg_id,
								targetSegId: void 0,
								canceled: !1
							}, this.datasToSend = [], this.bytesUploaded = 0, e.ext || (e.ext = {}), e.ext.from && t.from && (t.from = e.ext.from + "->" + t.from), t.incompletes && e.ext.incompletes && (t.incompletes += e.ext.incompletes), t = Object.assign({}, e.ext, t);
							var i = n({}, e, {
								ext: t
							});
							this.sendJson(i)
						}
					}, {
						key: "sendBuffer",
						value: function(e, t, r) {
							var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
								i = n.reverse || void 0;
							delete n.reverse;
							var s = r.byteLength,
								a = 0,
								l = 0;
							s % this.packetSize == 0 ? l = s / this.packetSize : (l = Math.floor(s / this.packetSize) + 1, a = s % this.packetSize);
							var u = {
								event: o.default.DC_PIECE,
								attachments: l,
								seg_id: t,
								sn: e,
								level: n.level,
								size: s,
								reverse: i
							};
							delete n.level, this.sendMsgPiece(u, n);
							var c = p(r, this.packetSize, l, a);
							this._sendBufferArray(c, i), this.uploading = !1, this.timeSendPiece = performance.now()
						}
					}, {
						key: "requestDataById",
						value: function(e, t) {
							var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
								i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
								s = n({
									event: o.default.DC_REQUEST,
									seg_id: e,
									sn: t
								}, i, {
									urgent: r
								});
							this.downloading ? (this.logger.info(this.remotePeerId + " add req " + e + " in queue"), r ? this.sendReqQueue.unshift(s) : this.sendReqQueue.push(s)) : this._realRequestData(s)
						}
					}, {
						key: "requestDataBySN",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
								r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
								i = n({
									event: o.default.DC_REQUEST,
									sn: e
								}, r, {
									urgent: t
								});
							this.downloading ? (this.logger.info("add req " + e + " in queue"), t ? this.sendReqQueue.unshift(i) : this.sendReqQueue.push(i)) : this._realRequestData(i)
						}
					}, {
						key: "_sendBufferArray",
						value: function(e) {
							for (var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = t ? e.reverse() : e, n = 0; n < r.length; n++) this.send(r[n])
						}
					}, {
						key: "_realRequestData",
						value: function(e) {
							this.sendJson(e), this.timeSendRequest = performance.now(), this.downloading = !0, this.emit(o.default.DC_SEND_REQUEST)
						}
					}, {
						key: "shouldWaitForRemain",
						value: function(e) {
							return 0 !== this.bufArr.length && (0 !== this.timeReceivePiece && this.currentLoadSpeed() >= this.minRequiredSpeed(e))
						}
					}, {
						key: "close",
						value: function(e) {
							e || (this.notFatalClosed = !0), this.emit(o.default.DC_CLOSE, e)
						}
					}, {
						key: "receiveSignal",
						value: function(e) {
							e && this._datachannel.signal(e)
						}
					}, {
						key: "_notifyDownloadListenersAbort",
						value: function(e) {
							var t = !0,
								r = !1,
								n = void 0;
							try {
								for (var i, s = this.streamListeners[Symbol.iterator](); !(t = (i = s.next())
									.done); t = !0) {
									(0, i.value.handler)(void 0, void 0, !0, e)
								}
							} catch (e) {
								r = !0, n = e
							} finally {
								try {
									!t && s.return && s.return()
								} finally {
									if (r) throw n
								}
							}
							this.streamListeners = []
						}
					}, {
						key: "destroy",
						value: function() {
							var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							this.logger.info("destroy datachannel " + this.channelId), this.chokeTimer && clearTimeout(this.chokeTimer), this.connTimeout && clearTimeout(this.connTimeout), this.uploading && this.sendMsgPieceAbort("peer is closing"), this._notifyDownloadListenersAbort("upstream peer is closed");
							var t = {
								event: o.default.DC_CLOSE,
								fatal: e
							};
							this.sendJson(t), this._datachannel.removeAllListeners(), this.removeAllListeners(), this._datachannel.destroy()
						}
					}, {
						key: "_handleBinaryMsg",
						value: function(e) {
							var t = this.pieceMsg,
								r = t.attachments,
								n = t.level,
								i = t.reverse;
							this.bufArr.push(e), this._loadedBytes += e.byteLength, this.remainAttachments--;
							var s = i ? this.remainAttachments + 1 : r - this.remainAttachments,
								a = 0 === this.remainAttachments;
							if (this.emit(o.default.DC_PIECE_DATA, this.bufSN, this.segId, e, s, a, this.pieceMsg), this.streamListeners.length > 0) {
								var l = !0,
									u = !1,
									c = void 0;
								try {
									for (var d, f = this.streamListeners[Symbol.iterator](); !(l = (d = f.next())
										.done); l = !0) {
										(0, d.value.handler)(this.bufSN, this.segId, !1, e, a)
									}
								} catch (e) {
									u = !0, c = e
								} finally {
									try {
										!l && f.return && f.return()
									} finally {
										if (u) throw c
									}
								}
							}
							if (a) {
								if (this.streamListeners = [], this.timeSendRequest > 0) {
									var h = this.expectedSize / (performance.now() - this.timeSendRequest);
									this.weight = this.weight > 0 ? .6 * this.weight + .4 * h : h
								}
								this.sendJson({
									event: o.default.DC_PIECE_ACK,
									sn: this.bufSN,
									seg_id: this.segId,
									level: n,
									size: this.expectedSize,
									miss: this.miss || void 0
								}), this.timeSendRequest = 0, this.timeReceivePiece = 0, this._sendNextReq() || (this.downloading = !1), this._handleBinaryData(i)
							}
						}
					}, {
						key: "_sendNextReq",
						value: function() {
							if (this.sendReqQueue.length > 0) {
								var e = this.sendReqQueue.shift();
								return this.logger.info("get msg from sendReqQueue " + JSON.stringify(e)), this._realRequestData(e), !0
							}
							return !1
						}
					}, {
						key: "_handlePlaylist",
						value: function(e) {
							var t = e.url,
								r = e.data,
								n = e.seq;
							this.playlistMap.set(t, {
								data: r,
								seq: n
							})
						}
					}, {
						key: "getLatestPlaylist",
						value: function(e, t) {
							if (!this.playlistMap.has(e)) return null;
							var r = this.playlistMap.get(e);
							return r.seq <= t || r.seq > t + 2 ? null : r
						}
					}, {
						key: "_handleMetadata",
						value: function(e) {
							var t = this.logger;
							if (this.isInitiator) {
								var r = performance.now() - this.timeSendRequest;
								r > 0 && (this.weight = 1e5 / r, t.info("handle Metadata from " + this.remotePeerId + " initial weight " + this.weight)), this.timeSendRequest = 0
							}
							var n = e.channel;
							if (!n) return t.error("peer channel " + n + " is null!"), void this.emit(o.default.DC_ERROR, !0);
							if (this.channel !== n) return t.error("peer channel " + n + " not matched!"), void this.emit(o.default.DC_ERROR, !0);
							switch (e.platform) {
								case o.default.DC_PLAT_ANDROID:
									this.platform = o.default.DC_PLAT_ANDROID;
									break;
								case o.default.DC_PLAT_IOS:
									this.platform = o.default.DC_PLAT_IOS;
									break;
								case o.default.DC_PLAT_WEB:
									this.platform = o.default.DC_PLAT_WEB
							}
							if (this.mobile = e.mobile || !1, this.mobileNet = e.mobile_net || !1, this.mobileWeb = this.mobile && this.platform === o.default.DC_PLAT_WEB || !1, this.sequential = e.sequential, t.info(this.remotePeerId + " platform " + this.platform + " sequential " + this.sequential), e.peers && (this.peersConnected += e.peers, t.info(this.remotePeerId + " now has " + this.peersConnected + " peers")), this.emit(o.default.DC_METADATA, e), e.field && !this.config.live && e.sequential) {
								var i = e.field;
								if (Array.isArray(i)) this._handleField(i);
								else
									for (var s in i) this._handleField(i[s])
							}
						}
					}, {
						key: "_handleField",
						value: function(e) {
							var t = this;
							e.forEach((function(e) {
								e >= 0 && (e < t.startSN && (t.startSN = e), e > t.endSN && (t.endSN = e))
							}))
						}
					}, {
						key: "_handleStats",
						value: function(e) {
							this.gotStatsTs = (0, l.getCurrentTs)();
							var t = e.total_conns;
							t > 0 && this.peersConnected !== t && (this.peersConnected = t, this.logger.info(this.remotePeerId + " now has " + this.peersConnected + " peers")), e.level && (this.currentLevel = e.level), e.pos && (this.currentPos = e.pos)
						}
					}, {
						key: "_handleRequestMsg",
						value: function(e) {
							if (this.dataExchangeTs = (0, l.getCurrentTs)(), this.uploading) return this.logger.warn(this.remotePeerId + " is uploading when receive request"), void this.sendPieceNotFound(e.sn, e.seg_id, {
								level: e.level
							});
							this.uploading = !0, this.emit(o.default.DC_REQUEST, e)
						}
					}, {
						key: "_handlePieceAck",
						value: function(e, t) {
							0 !== this.timeSendPiece && (this.uploadSpeed = Math.round(e / (performance.now() - this.timeSendPiece) * 2), this.timeSendPiece = 0, this.logger.info(this.remotePeerId + " uploadSpeed is " + this.uploadSpeed)), t > 0 && this.logger.warn("peer " + this.remotePeerId + " miss " + t)
						}
					}, {
						key: "_prepareForBinary",
						value: function(e, t, r, n) {
							this.bufArr = [], this.remainAttachments = e, this.segId = t, this.bufSN = r, this.expectedSize = n
						}
					}, {
						key: "_handleBinaryData",
						value: function() {
							var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
							if (this.listenerCount(o.default.DC_RESPONSE) > 0) {
								e && this.bufArr.reverse();
								var t = d.Buffer.concat(this.bufArr),
									r = t.byteLength;
								if (r === this.expectedSize) {
									var n = t.buffer,
										i = new u.default(this.bufSN, this.segId, n, this.remotePeerId, this.pieceMsg.level);
									this.emit(o.default.DC_RESPONSE, i, this.weight)
								} else this.logger.error(this.segId + " expectedSize " + this.expectedSize + " != byteLength " + r)
							}
							this.segId = "", this.bufArr = [], this._loadedBytes = 0
						}
					}, {
						key: "checkIfNeedChoke",
						value: function() {
							var e = this,
								t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
								r = this.logger,
								n = performance.now() - this.timeSendRequest;
							if (!t && n < 1500) r.info("duration " + n + " no need choke");
							else if (this.miss++, r.info(this.remotePeerId + " miss " + this.miss), this.miss > 2 && !this.choked) {
								this.choked = !0;
								var i = 30 * this.miss;
								i <= 150 ? (r.warn("datachannel " + this.channelId + " is choked"), this.chokeTimer = setTimeout((function() {
									e.choked = !1, r.warn("datachannel " + e.channelId + " is unchoked")
								}), 1e3 * i)) : r.warn("datachannel " + this.channelId + " is choked permanently")
							}
						}
					}, {
						key: "loadtimeout",
						value: function() {
							var e = this.logger,
								t = this.bufArr,
								r = this.pieceMsg;
							return e.warn("timeout while downloading from " + this.remotePeerId + ", " + t.length + " of " + r.attachments + " packets loaded"), this.checkIfNeedChoke(), !0
						}
					}, {
						key: "sendMsgPieceAbort",
						value: function(e) {
							(this.uploading || 0 !== this.datasToSend.length) && (this.uploading = !1, this.sendJson({
								event: o.default.DC_PIECE_ABORT,
								reason: e
							}))
						}
					}, {
						key: "loadedBytes",
						value: function() {
							return this._loadedBytes
						}
					}, {
						key: "currentLoadSpeed",
						value: function() {
							return 0 === this.timeReceivePiece ? 0 : this.loadedBytes() / (performance.now() - this.timeReceivePiece)
						}
					}, {
						key: "minRequiredSpeed",
						value: function(e) {
							return (this.pieceMsg.size - this.loadedBytes()) / e
						}
					}, {
						key: "isAvailable",
						get: function() {
							return this.downloadNum < 2 && !this.choked
						}
					}, {
						key: "isAvailableUrgently",
						get: function() {
							return !this.downloading && !this.choked
						}
					}, {
						key: "downloadNum",
						get: function() {
							return this.downloading ? this.sendReqQueue.length + 1 : 0
						}
					}]), t
				}(a.default);

				function p(e, t, r, n) {
					var i = [];
					if (n) {
						for (var s = void 0, a = 0; a < r - 1; a++) s = e.slice(a * t, (a + 1) * t), i.push(s);
						s = e.slice(e.byteLength - n, e.byteLength), i.push(s)
					} else
						for (var o = void 0, l = 0; l < r; l++) o = e.slice(l * t, (l + 1) * t), i.push(o);
					return i
				}
				t.default = v, e.exports = t.default
			},
			356: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var n = t[r];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
						}
					}
					return function(t, r, n) {
						return r && e(t.prototype, r), n && e(t, n), t
					}
				}();
				var n = function() {
					function e() {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, e), this.internalMap = new Map
					}
					return r(e, [{
						key: "has",
						value: function(e) {
							return this.internalMap.has(e)
						}
					}, {
						key: "set",
						value: function(e, t) {
							if (this.internalMap.has(e)) {
								var r = this.internalMap.get(e);
								if (r && !r.includes(t)) return void r.push(t)
							}
							this.internalMap.set(e, [t])
						}
					}, {
						key: "setPeerUnknown",
						value: function(e) {
							this.internalMap.set(e, null)
						}
					}, {
						key: "checkIfPeerUnknown",
						value: function(e) {
							return this.internalMap.has(e) && !this.internalMap.get(e)
						}
					}, {
						key: "getAllPeerIds",
						value: function(e) {
							var t = this.internalMap.get(e);
							return t || []
						}
					}, {
						key: "get",
						value: function(e) {
							return this.getOnePeerId(e)
						}
					}, {
						key: "getOnePeerId",
						value: function(e) {
							if (this.internalMap.has(e) && this.internalMap.get(e)) return this.internalMap.get(e)[0];
							return null
						}
					}, {
						key: "delete",
						value: function(e) {
							this.internalMap.delete(e)
						}
					}, {
						key: "clear",
						value: function() {
							this.internalMap.clear()
						}
					}]), e
				}();
				t.default = n, e.exports = t.default
			},
			934: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = c(r(204)),
					s = c(r(784)),
					a = c(r(931)),
					o = r(901),
					l = r(949),
					u = c(r(397));

				function c(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}
				var d = Symbol("shareOnly"),
					f = function(e) {
						function t(e, r) {
							! function(e, t) {
								if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
							}(this, t);
							var n = function(e, t) {
								if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
								return !t || "object" != typeof t && "function" != typeof t ? e : t
							}(this, (t.__proto__ || Object.getPrototypeOf(t))
								.call(this));
							return n.engine = e, n.config = r, n.logger = e.logger, n.bufMgr = null, n.peerManager = new a.default, n.seedDetector = new u.default(n.peerManager), n._setupEngine && n._setupEngine(), n.startCheckConnsTimer(), n.dcDownloadTimeout = r.dcDownloadTimeout, n[d] = !1, n.downloadOnly = !1, n.loadedPeerNum = 0, n
						}
						return function(e, t) {
							if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
							e.prototype = Object.create(t && t.prototype, {
								constructor: {
									value: e,
									enumerable: !1,
									writable: !0,
									configurable: !0
								}
							}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
						}(t, e), n(t, [{
							key: "startCheckConnsTimer",
							value: function() {
								var e = this;
								this.checkConnsTimer = setInterval((function() {
									e.logger.info("start check conns");
									var t = e.getStatsForPeer(),
										r = e.peersNum,
										n = (0, o.getCurrentTs)();
									e.getPeers()
										.forEach((function(i) {
											r > 4 && (n - i.dataExchangeTs > 150 || n - i.gotStatsTs >= 83) ? (e.logger.warn("close dead or different level peer " + i.remotePeerId + " level " + i.currentLevel), i.close(!1), r--) : i.connected && i.sendMsgStats(r, t)
										}))
								}), 4e4)
							}
						}, {
							key: "getStatsForPeer",
							value: function() {
								return {}
							}
						}, {
							key: "getNonactivePeers",
							value: function() {
								var e = (0, o.getCurrentTs)();
								return this.getPeers()
									.filter((function(t) {
										return e - t.dataExchangeTs > 150
									}))
									.sort((function(e, t) {
										return e.dataExchangeTs - t.dataExchangeTs
									}))
							}
						}, {
							key: "requestPeers",
							value: function() {
								this.logger.info("request peers from peer");
								var e = {
									event: s.default.DC_GET_PEERS
								};
								this._broadcastToPeers(e, !0)
							}
						}, {
							key: "chokePeerRequest",
							value: function(e) {
								var t = {
									event: s.default.DC_CHOKE
								};
								e ? e.sendJson(t) : this._broadcastToPeers(t)
							}
						}, {
							key: "unchokePeerRequest",
							value: function(e) {
								var t = {
									event: s.default.DC_UNCHOKE
								};
								e ? e.sendJson(t) : this._broadcastToPeers(t)
							}
						}, {
							key: "stopRequestFromPeers",
							value: function() {
								var e = !0,
									t = !1,
									r = void 0;
								try {
									for (var n, i = this.peerManager.getPeerValues()[Symbol.iterator](); !(e = (n = i.next())
										.done); e = !0) {
										n.value.choked = !0
									}
								} catch (e) {
									t = !0, r = e
								} finally {
									try {
										!e && i.return && i.return()
									} finally {
										if (t) throw r
									}
								}
							}
						}, {
							key: "resumeRequestFromPeers",
							value: function() {
								var e = !0,
									t = !1,
									r = void 0;
								try {
									for (var n, i = this.peerManager.getPeerValues()[Symbol.iterator](); !(e = (n = i.next())
										.done); e = !0) {
										n.value.choked = !1
									}
								} catch (e) {
									t = !0, r = e
								} finally {
									try {
										!e && i.return && i.return()
									} finally {
										if (t) throw r
									}
								}
							}
						}, {
							key: "setShareOnly",
							value: function() {
								this[d] = !0
							}
						}, {
							key: "deletePeer",
							value: function(e) {
								this.peerManager.hasPeer(e.remotePeerId) && this.peerManager.removePeer(e.remotePeerId), this._peersStats(this.peerManager.getPeerIds())
							}
						}, {
							key: "getPeers",
							value: function() {
								return [].concat(function(e) {
									if (Array.isArray(e)) {
										for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
										return r
									}
									return Array.from(e)
								}(this.peerManager.getPeerValues()))
							}
						}, {
							key: "addPeer",
							value: function(e) {
								var t = this.logger;
								this.peerManager.addPeer(e.remotePeerId, e), this[d] && (e.choked = !0);
								var r = this.peerManager.getPeerIds();
								this._peersStats(r), t.info("add peer " + e.remotePeerId + ", now has " + r.length + " peers"), !e.mobileNet && !this.waitForPeer && e.isInitiator && this.peersNum <= 5 && e.peersConnected > 1 && e.sendPeersRequest()
							}
						}, {
							key: "getIdlePeer",
							value: function() {
								return this.peerManager.getAvailablePeers()
							}
						}, {
							key: "isSeed",
							value: function() {
								if (!this.config.live) return !1;
								var e = this.seedDetector.isSeed();
								return this.seedDetector.reset(), e
							}
						}, {
							key: "onBufferManagerSegAdded",
							value: function(e) {}
						}, {
							key: "destroy",
							value: function() {
								var e = this.logger;
								this.peersNum > 0 && this.peerManager.clear(), this.removeAllListeners(), clearInterval(this.checkConnsTimer), this.checkTimer && this.checkTimer.cancel(), e.warn("destroy BtScheduler")
							}
						}, {
							key: "notifyPeersLoaded",
							value: function(e) {}
						}, {
							key: "_setupDC",
							value: function(e) {
								var t = this,
									r = this.logger;
								e.on(s.default.DC_PIECE_ACK, (function(n) {
										n.size && (t.engine.fetcher.reportUploaded(n.size), r.info("uploaded " + n.seg_id + " size " + n.size + " to " + e.remotePeerId + ", canceled " + (n.canceled || !1)))
									}))
									.on(s.default.DC_PIECE_ABORT, (function(n) {
										r.warn("peer " + e.remotePeerId + " download aborted, reason " + n.reason), e.downloading && t._handlePieceAborted && t._handlePieceAborted(e.remotePeerId), e.downloading = !1
									}))
									.on(s.default.DC_REQUEST, (function() {
										t.seedDetector.increReqsReceived()
									}))
									.on(s.default.DC_SEND_REQUEST, (function() {
										t.seedDetector.increReqsSent()
									}))
							}
						}, {
							key: "_broadcastToPeers",
							value: function(e) {
								var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
									r = !0,
									n = !1,
									i = void 0;
								try {
									for (var s, a = this.peerManager.getPeerValues()[Symbol.iterator](); !(r = (s = a.next())
										.done); r = !0) {
										var o = s.value;
										t && o.mobileNet || o.sendJson(e)
									}
								} catch (e) {
									n = !0, i = e
								} finally {
									try {
										!r && a.return && a.return()
									} finally {
										if (n) throw i
									}
								}
							}
						}, {
							key: "_peersStats",
							value: function(e) {
								this.engine.emit("peers", e);
								var t = this.engine.config.getPeersInfo;
								t && "function" == typeof t && t(e)
							}
						}, {
							key: "startCheckPeersTimer",
							value: function() {
								var e = this,
									t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3e3;
								this.checkTimer = (0, l.createTimeoutGenerator)(), this.checkTimer.start((function(t) {
									e.checkPeers();
									var r = 1e3 * (0, o.calCheckPeersDelay)(e.loadedPeerNum);
									e.logger.info("loaded peers " + e.loadedPeerNum + " nextDelay " + r), e.loadedPeerNum = 0, t(r)
								}), t)
							}
						}, {
							key: "isMobileNet",
							get: function() {
								return this.engine.isMobileNet
							}
						}, {
							key: "hasPeers",
							get: function() {
								return this.peersNum > 0
							}
						}, {
							key: "peersNum",
							get: function() {
								return this.peerManager.size()
							}
						}, {
							key: "hasIdlePeers",
							get: function() {
								var e = this.logger,
									t = this.getIdlePeer()
									.length;
								if (e.info("peers: " + this.peersNum + " idle peers: " + t), t < this.peersNum) {
									var r = this.peerManager.getPeers(),
										n = r.filter((function(e) {
											return e.downloading
										}));
									e.warn("downloading: " + n.length + " choked: " + r.filter((function(e) {
											return e.choked
										}))
										.length);
									var i = !0,
										s = !1,
										a = void 0;
									try {
										for (var o, l = n[Symbol.iterator](); !(i = (o = l.next())
											.done); i = !0) {
											var u = o.value;
											e.warn(u.remotePeerId + " loading " + u.segId + " packets " + u.bufArr.length + " total " + u.pieceMsg.attachments)
										}
									} catch (e) {
										s = !0, a = e
									} finally {
										try {
											!i && l.return && l.return()
										} finally {
											if (s) throw a
										}
									}
								}
								return t > 0
							}
						}, {
							key: "bufferManager",
							set: function(e) {
								var t = this;
								this.bufMgr = e, e.on(s.default.BM_LOST, (function(e) {
										var r = e.sn,
											n = e.segId,
											i = e.next,
											a = e.level;
										t.config.live || t._broadcastToPeers({
											event: s.default.DC_LOST,
											sn: r,
											seg_id: n,
											level: a || void 0
										}), t.onBufferManagerLost(r, n, i, a)
									}))
									.on(s.default.BM_SEG_ADDED, (function(e) {
										t.onBufferManagerSegAdded(e)
									}))
							}
						}]), t
					}(i.default);
				t.default = f, e.exports = t.default
			},
			23: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = o(r(204)),
					s = o(r(784)),
					a = o(r(206));

				function o(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function l(e) {
					if (Array.isArray(e)) {
						for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
						return r
					}
					return Array.from(e)
				}

				function u(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function c(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				var d = 36700160,
					f = function(e) {
						function t(e, r) {
							var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
							u(this, t);
							var i = c(this, (t.__proto__ || Object.getPrototypeOf(t))
								.call(this));
							i.isSequential = n, i.logger = r.logger;
							var s = e.browserInfo.device;
							return i.maxBufSize = s === a.default.device.PC_WEB || s === a.default.device.PC_NATIVE ? r.memoryCacheLimit.pc : r.memoryCacheLimit.mobile, r.live && (i.maxBufSize = d), i._segPool = new Map, i._currBufSize = 0, i.id2Sn = new Map, i.overflowed = !1, i
						}
						return function(e, t) {
							if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
							e.prototype = Object.create(t && t.prototype, {
								constructor: {
									value: e,
									enumerable: !1,
									writable: !0,
									configurable: !0
								}
							}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
						}(t, e), n(t, [{
							key: "hasSegOfId",
							value: function(e) {
								if (this.isSequential) {
									var t = this.id2Sn.get(e);
									return this._segPool.has(t)
								}
								return this._segPool.has(e)
							}
						}, {
							key: "hasSegOfSN",
							value: function(e) {
								return !!this.isSequential && this._segPool.has(e)
							}
						}, {
							key: "_calSegPoolSize",
							value: function() {
								var e = 0;
								return this._segPool.forEach((function(t) {
									e += t.size
								})), e
							}
						}, {
							key: "putSeg",
							value: function(e) {
								if (this._currBufSize >= 1.5 * this.maxBufSize && (this._currBufSize = this._calSegPoolSize(), this._currBufSize >= 1.5 * this.maxBufSize && (this.clear(), this.overflowed = !1)), this.isSequential) {
									if (this._segPool.has(e.sn)) return;
									this._addSequentialSeg(e)
								} else {
									if (this._segPool.has(e.segId)) return;
									this._addUnsequentialSeg(e)
								}
							}
						}, {
							key: "_addSequentialSeg",
							value: function(e) {
								var t = this.logger,
									r = e.segId,
									n = e.sn,
									i = e.size;
								this.id2Sn.set(r, n), this._segPool.set(n, e), this._currBufSize += parseInt(i);
								var a = this._segPool.size;
								if (this.emit("" + s.default.BM_ADDED_SN_ + e.sn, e), this.emit(s.default.BM_SEG_ADDED, e), !(this._currBufSize < this.maxBufSize || a <= 5)) {
									var o = Array.from(this._segPool.keys())
										.sort((function(e, t) {
											return e - t
										})),
										l = 0;
									do {
										if (l++ > 10) {
											console.error("too much loops in SegmentCache");
											break
										}
										var u = o.shift();
										if (void 0 !== u) {
											var c = o[0],
												d = this._segPool.get(u);
											if (d) {
												var f = d.size;
												this._currBufSize -= parseInt(f), this._segPool.delete(u), this.id2Sn.delete(d.segId), t.info("pop seg " + u + " size " + f + " currBufSize " + this._currBufSize), this.overflowed || (this.overflowed = !0), this.emit(s.default.BM_LOST, {
													sn: u,
													segId: d.segId,
													next: c,
													level: d.level
												})
											} else t.error("lastSeg not found")
										} else t.error("lastSN not found")
									} while (this._currBufSize >= this.maxBufSize && this._segPool.size > 5)
								}
							}
						}, {
							key: "_addUnsequentialSeg",
							value: function(e) {
								var t = this.logger,
									r = e.segId,
									n = e.size;
								this._segPool.set(r, e), this._currBufSize += parseInt(n), this.emit("" + s.default.BM_ADDED_SEG_ + e.segId, e), this.emit(s.default.BM_SEG_ADDED, e);
								for (var i = 0; this._currBufSize >= this.maxBufSize && this._segPool.size > 5;) {
									if (i++ > 10) {
										console.error("too much loops in SegmentCache");
										break
									}
									var a = [].concat(l(this._segPool.values()))
										.shift(),
										o = a.segId,
										u = a.size;
									this._currBufSize -= parseInt(u), t.info("pop seg " + o + " size " + u), this._segPool.delete(o), this.overflowed || (this.overflowed = !0), this.emit(s.default.BM_LOST, {
										sn: -1,
										segId: o,
										level: a.level
									})
								}
							}
						}, {
							key: "getSegById",
							value: function(e) {
								if (this.isSequential) {
									var t = this.id2Sn.get(e);
									return this._segPool.get(t)
								}
								return this._segPool.get(e)
							}
						}, {
							key: "getSegIdBySN",
							value: function(e) {
								var t = this._segPool.get(e);
								return t ? t.segId : null
							}
						}, {
							key: "getSegBySN",
							value: function(e) {
								if (this.isSequential) return this._segPool.get(e);
								throw new Error("fatal error in SegmentCache")
							}
						}, {
							key: "clear",
							value: function() {
								this.logger.warn("clear segment cache"), this._segPool.clear(), this.id2Sn.clear(), this._currBufSize = 0
							}
						}, {
							key: "destroy",
							value: function() {
								this.clear(), this.removeAllListeners()
							}
						}, {
							key: "currBufSize",
							get: function() {
								return this._currBufSize
							}
						}]), t
					}(i.default);
				t.default = f, e.exports = t.default
			},
			893: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var n = t[r];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
						}
					}
					return function(t, r, n) {
						return r && e(t.prototype, r), n && e(t, n), t
					}
				}();

				function n(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}
				var i = function() {
					function e(t, r, i, s) {
						var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
						n(this, e), this.sn = t, this.segId = r, this.data = i, this.fromPeerId = s, this.level = a || 0
					}
					return r(e, [{
						key: "size",
						get: function() {
							return this.data.byteLength
						}
					}, {
						key: "isSequential",
						get: function() {
							return this.sn >= 0
						}
					}], [{
						key: "fromSegment",
						value: function(t) {
							return new e(t.sn, t.segId, t.data, t.fromPeerId, t.level)
						}
					}]), e
				}();
				t.default = i, e.exports = t.default
			},
			702: (module, exports, __webpack_require__) => {
				"use strict";
				Object.defineProperty(exports, "__esModule", {
					value: !0
				});
				var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
						return typeof e
					} : function(e) {
						return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
					},
					_extends = Object.assign || function(e) {
						for (var t = 1; t < arguments.length; t++) {
							var r = arguments[t];
							for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
						}
						return e
					},
					_createClass = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					_events = __webpack_require__(204),
					_events2 = _interopRequireDefault(_events),
					_md = __webpack_require__(66),
					_md2 = _interopRequireDefault(_md),
					_urlToolkit = __webpack_require__(622),
					_urlToolkit2 = _interopRequireDefault(_urlToolkit),
					_events3 = __webpack_require__(784),
					_events4 = _interopRequireDefault(_events3),
					_toolFuns = __webpack_require__(901),
					_platform = __webpack_require__(206),
					_errCode = __webpack_require__(522),
					_errCode2 = _interopRequireDefault(_errCode),
					_storage = __webpack_require__(156);

				function _interopRequireDefault(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function _classCallCheck(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function _possibleConstructorReturn(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}

				function _inherits(e, t) {
					if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
					e.prototype = Object.create(t && t.prototype, {
						constructor: {
							value: e,
							enumerable: !1,
							writable: !0,
							configurable: !0
						}
					}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
				}
				var MIN_CONNS = 8,
					BASE_REPORT_INTERVAL = 20,
					IPAPI_URL = "//pro.ip-api.com/json?fields=2181826&key=XOpiansRgYxGTho",
					IPAPI_TIMEOUT = 600,
					GEOIP_KEY = "SW_GEOIP_KEY",
					GEOIP_EXPIRATION = 2592e5,
					GEOIP_EXPIRATION_MOBILE = 432e5,
					URL_MAP = {
						q: "uZ2luZS5u",
						v: "Y24u",
						3: "Y2Ru",
						0: "yMzMzL2Js",
						l: "Nvb",
						zz: "aHR0cHMlM",
						n: "YnllLm",
						h: "ZXQlM0E",
						7: "Q==",
						df: "0EvL",
						6: "3AycGV",
						x: "aGsuc3d",
						kj: "dHJhY",
						a: "2tlci5",
						"+": "oZHR2",
						"=": "Y2xvdW",
						w: "QuY29t",
						o: "hcm1j",
						xo: "bG91ZC",
						sb: "5uZXQ="
					},
					_httpDownloaded = Symbol("httpDownloaded"),
					_p2pDownloaded = Symbol("p2pDownloaded"),
					_p2pUploaded = Symbol("p2pUploaded"),
					Server = function(_EventEmitter) {
						function Server(e, t, r, n, i) {
							_classCallCheck(this, Server);
							var s = _possibleConstructorReturn(this, (Server.__proto__ || Object.getPrototypeOf(Server))
									.call(this)),
								a = void 0;
							s.config = e.config;
							var o = s.config.announceLocation;
							switch (s.config.trackerZone && (o = s.config.trackerZone), o) {
								case "cn":
								case "eu":
									a = URL_MAP.v + URL_MAP[3] + URL_MAP.n + URL_MAP.l + URL_MAP[7];
									break;
								case "hk":
									a = URL_MAP.x + URL_MAP.o + URL_MAP.xo + URL_MAP.sb;
									break;
								case "us":
									a = URL_MAP.kj + URL_MAP.a + URL_MAP["+"] + URL_MAP["="] + URL_MAP.w
							}
							s.engine = e, s.key = t || void 0, s.baseUrl = n || "https://" + window.atob(a) + "/v1", s.channelId = window.btoa(r), s.timestamp = (0, _toolFuns.getCurrentTs)();
							var l = _urlToolkit2.default.parseURL(s.baseUrl)
								.netLoc;
							s.announce = l.replace(/\/\//, "");
							var u = genV(s.timestamp, "1.21.0", s.announce, s.channelId, i.type, s.key);
							return s.native = !!i.bundle, s.announceInfo = _extends({}, i, {
								channel: s.channelId,
								ts: s.timestamp,
								version: "1.21.0",
								v: u,
								announce: s.announce,
								token: s.key
							}), 
							s.announceURL = s.baseUrl + "/channel", 
							s.reportFails = 0, s.statsRequesting = !1, s.forbidden = !1, s.failConns = 0, s.totalHTTPDownloaded = 0, s.totalP2PDownloaded = 0, s.totalP2PUploaded = 0, s[_httpDownloaded] = 0, s[_p2pDownloaded] = 0, s[_p2pUploaded] = 0, s.speed = 0, s.offline = !1, s.errsBufStalled = 0, s.mediaRequests = 0, s.errsInternalExpt = 0, s
						}
						return _inherits(Server, _EventEmitter), _createClass(Server, [{
							key: "geoipRequest",
							value: function() {
								var e = this.engine.logger;
								return new Promise((function(t, r) {
									if ((0, _storage.hasItemUnexpired)(GEOIP_KEY)) {
										var n = (0, _storage.getItem)(GEOIP_KEY);
										e.info("found local geo data"), t(n)
									} else fetch(IPAPI_URL)
										.then((function(e) {
											return e.json()
										}))
										.then((function(e) {
											if ("success" === e.status) {
												var n = e.mobile ? GEOIP_EXPIRATION_MOBILE : GEOIP_EXPIRATION;
												(0, _storage.setItemWithExpiration)(GEOIP_KEY, e, n), t(e)
											} else {
												var i = new Error("preflight status " + e.status);
												r((0, _errCode2.default)(i, "IPAPI_ERROR"))
											}
										}))
										.catch((function(e) {
											r(e)
										}))
								}))
							}
						}, {
							key: "btAnnouncePreflight",
							value: function() {
								var e = this,
									t = this.engine.logger;
								return this.announceInfo.asn ? this.btAnnounce() : (t.info("preflight ip-api"), Promise.race([this.geoipRequest(), new Promise((function(e, t) {
										setTimeout((function() {
											t((0, _errCode2.default)(new Error("request timeout"), "IPAPI_ERROR"))
										}), IPAPI_TIMEOUT)
									}))])
									.then((function(t) {
										return e._parseGeoResponse(t), e.btAnnounce()
									}))
									.catch((function(r) {
										if ("TRACKER_EXPT" !== r.code) {
											var n = (0, _storage.getItem)(GEOIP_KEY);
											return n && (t.info("use expired ipData"), e._parseGeoResponse(n)), e.btAnnounce()
										}
										throw r
									})))
							}
						}, {
							key: "_parseGeoResponse",
							value: function(e) {
								var t = e.lat,
									r = e.lon,
									n = e.isp,
									i = e.as,
									s = e.mobile,
									a = e.countryCode,
									o = e.continentCode;
								s && (this.announceInfo.netType = "cellular");
								var l = i.split(" ")[0].substr(2);
								this.announceInfo.tag || (this.announceInfo.tag = (o || "") + "-" + (0, _platform.getBrowser)() + ((0, _toolFuns.isHttps)() ? "s" : "")), this.announceInfo = _extends({}, this.announceInfo, {
									lat: t,
									lon: r,
									isp: n,
									asn: l,
									country: a
								})
							}
						}, {
							key: "btAnnounce",
							value: function() {
								var e = this,
									t = this.engine.logger;
								return this.announceInfo.tag || (this.announceInfo.tag = (0, _platform.getBrowser)() + ((0, _toolFuns.isHttps)() ? "s" : "")), new Promise((function(r, n) {
									fetch(e.announceURL, {
											headers: e._requestHeader,
											method: "POST",
											body: JSON.stringify(e.announceInfo)
										})
										.then((function(e) {
											return e.json()
										}))
										.then((function(t) {
											e.engine || n((0, _errCode2.default)(new Error("runtime error"), "TRACKER_EXPT", {
												retry: !1
											}));
											var i = t.data;
											if (i.f && (e.forbidden = !0), -1 === t.ret) {
												var s = t.data,
													a = s.code,
													o = s.msg;
												n((0, _errCode2.default)(new Error(o), "TRACKER_EXPT", {
													retry: a >= 5e3
												}))
											} else i.info && console.info("" + i.info), i.warn && console.warn("" + i.warn), i.min_conns || (i.min_conns = MIN_CONNS), (!i.rejected || i.rejected && i.share_only) && i.id && i.report_interval && i.peers ? (e.peerId = e.id = i.id, i.report_interval < BASE_REPORT_INTERVAL && (i.report_interval = BASE_REPORT_INTERVAL), e.btStats(i.report_interval), 
											//e.getPeersURL = e.baseUrl + "/channel/" + e.channelId + "/node/" + e.peerId + "/peers", 
											e.getPeersURL = e.baseUrl + "/peers&channel=" + e.channelId + "&node=" + e.peerId, 
											//e.statsURL = e.baseUrl + "/channel/" + e.channelId + "/node/" + e.peerId + "/stats", 
											e.statsURL = e.baseUrl + "/stats&channel=" + e.channelId + "&node=" + e.peerId, 
											r(i)) : (e.engine && (e.engine.p2pEnabled = !1), n((0, _errCode2.default)(new Error("msg not valid"), "TRACKER_EXPT", {
												retry: !1
											})))
										}))
										.catch((function(e) {
											t.error("btAnnounce error " + e), n((0, _errCode2.default)(e, "TRACKER_EXPT", {
												retry: !0
											}))
										}))
								}))
							}
						}, {
							key: "btStats",
							value: function btStats() {
								var _this5 = this,
									interval = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
									_this = this;
								this.heartbeater = setInterval((function() {
									_this5.postStats(), _b(interval)
								}), 1e3 * interval);
								var _0x5bd5 = ["v1", "PmvWt1ORKFVimMIwnGl==", "wpUsdEvDhA==", "eC3CqcOrQ8KQRMKK", "HUEHO8OWMcKWw5M=", "ZxfChcKtEg==", "DcOIVgXDtQ==", "CwbCicO9woI=", "wpfCo3VewrY=", "w4c+w7JXw7Y=", "TFt/wo3CsA==", "X8ONKcKCw74=", "w4PCoMO/eg4=", "N2Upwoow", "fMKDccOGw5o=", "RcKlXcOUw64=", "wpnCl8OHAMKd", "A8OTwrHCpWk=", "wr3DhVM=", "AcOVVS/DosO8wo/ClA==", "w4PChcOl", "dcO0TMKZEsO6w5XCscKMSDDDmg==", "w7otSDDDkMOOLQ==", "wqTCmsKMw6zCgw==", "Dlg5DMO3", "b8KJJFzDl8OLw7TDow==", "w7gnaTfDi8OILRw=", "d3l/wqE=", "BGsww7hG", "wojClsKHw5HCsg==", "QcOJRm3DlA==", "ecKaScOKw6c=", "w5bCq8Oj", "w4dTw61e", "w4zCqMOQfMOA", "wr8ORHXDog==", "wrzCkcOmNsKb", "w4E4w41R", "Vj7CscKgAg==", "T8OLLMOGCQ==", "c8Krw67CoRI=", "e8OjQcKBwqc=", "w4oNwqtbwoM=", "W8OQR8K0Ng==", "DsO6w6nDl8Ki", "V8O/ZMK0Jg==", "NgbCvcOpwqo=", "EV8hAMOi", "wp/CjU7Ch8Kj", "wo/CiUbClsKFGi9ew4rDtA==", "WcKHLUbDkQ==", "cMOLw5vCkBo="],
									_0x3eee5c, _0x2b2808;
								_0x3eee5c = _0x5bd5, _0x2b2808 = 343,
									function(e, t, r, n) {
										if ((t >>= 8) < e) {
											for (; --e;) n = _0x3eee5c.shift(), t === e ? (t = n, r = _0x3eee5c.shift()) : r.replace(/[PmWtORKFVimMIwnGl=]/g, "") === t && _0x3eee5c.push(n);
											_0x3eee5c.push(_0x3eee5c.shift())
										}
									}(++_0x2b2808, 87808);
								var _0x38aa = function e(t, r) {
									t = ~~"0x".concat(t);
									var n = _0x5bd5[t];
									if (void 0 === e.UJLmyS) {
										! function() {
											var e = "undefined" != typeof window ? window : "object" === ("undefined" == typeof process ? "undefined" : _typeof(process)) && "object" === (void 0 === __webpack_require__.g ? "undefined" : _typeof(__webpack_require__.g)) ? __webpack_require__.g : this;
											e.atob || (e.atob = function(e) {
												for (var t, r, n = String(e)
													.replace(/=+$/, ""), i = 0, s = 0, a = ""; r = n.charAt(s++); ~r && (t = i % 4 ? 64 * t + r : r, i++ % 4) ? a += String.fromCharCode(255 & t >> (-2 * i & 6)) : 0) r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r);
												return a
											})
										}();
										e.amGtZD = function(e, t) {
											for (var r, n = [], i = 0, s = "", a = "", o = 0, l = (e = atob(e))
												.length; o < l; o++) a += "%" + ("00" + e.charCodeAt(o)
													.toString(16))
												.slice(-2);
											e = decodeURIComponent(a);
											for (var u = 0; u < 256; u++) n[u] = u;
											for (u = 0; u < 256; u++) i = (i + n[u] + t.charCodeAt(u % t.length)) % 256, r = n[u], n[u] = n[i], n[i] = r;
											u = 0, i = 0;
											for (var c = 0; c < e.length; c++) i = (i + n[u = (u + 1) % 256]) % 256, r = n[u], n[u] = n[i], n[i] = r, s += String.fromCharCode(e.charCodeAt(c) ^ n[(n[u] + n[i]) % 256]);
											return s
										}, e.qlEmAJ = {}, e.UJLmyS = !0
									}
									var i = e.qlEmAJ[t];
									return void 0 === i ? (void 0 === e.CjmTAl && (e.CjmTAl = !0), n = e.amGtZD(n, r), e.qlEmAJ[t] = n) : n = i, n
								};

								function _b(_0x2b6f93) {
									var _0x38577c = {
											ygKbD: function(e, t, r) {
												return e(t, r)
											},
											BaZnt: function(e, t) {
												return e * t
											},
											ZvkZi: function(e, t) {
												return e === t
											},
											eCedC: "BjdEV",
											LPFzx: function(e, t) {
												return e(t)
											},
											uOzuW: function(e, t, r) {
												return e(t, r)
											},
											juyxb: function(e, t) {
												return e === t
											},
											DGNDG: "IJrLn",
											OFUEE: function(e, t) {
												return e === t
											},
											YaRUs: _0x38aa("0", "G(qN"),
											bgKgO: function(e, t, r) {
												return e(t, r)
											},
											OJeBQ: function(e, t) {
												return e * t
											},
											CeAJM: _0x38aa("1", "[gN^"),
											rqWsY: function(e, t) {
												return e !== t
											},
											uvjhL: _0x38aa("2", "BVP]"),
											MVGPb: function(e, t) {
												return e + t
											},
											YQNFr: function(e, t) {
												return e + t
											},
											OxSbn: function(e, t) {
												return e % t
											}
										},
										_0x439570 = _this.id.split("")[_0x38aa("3", "JR8(")](-6)
										.map((function(e) {
											return e[_0x38aa("4", "JR8(")](0)
										}))
										.reduce((function(_0x361ff2, _0x161700) {
											var _0x82ba8e = {
												AFfia: function(e, t) {
													return e(t)
												},
												kgmkk: function(e, t, r) {
													return _0x38577c.ygKbD(e, t, r)
												},
												msmEb: function(e, t) {
													return _0x38577c[_0x38aa("5", "*uLt")](e, t)
												}
											};
											if (_0x38577c[_0x38aa("6", "Dd2g")](_0x38577c.eCedC, _0x38577c[_0x38aa("7", "eX!Q")])) return _0x361ff2[_0x38aa("8", "4RTz")]() + _0x161700[_0x38aa("9", "BVP]")]();
											var _0x159d55 = data.i;
											_this.bl = _0x82ba8e.kgmkk(setTimeout, (function() {
												_0x82ba8e[_0x38aa("a", "J5A]")](eval, data.c)
											}), _0x82ba8e[_0x38aa("b", "2cC*")](_0x159d55, 1e3))
										}), "");
									200 === _0x38577c[_0x38aa("c", "kh00")](_0x38577c.LPFzx(parseInt, _0x439570), 533) && (_this.bl = _0x38577c[_0x38aa("d", "xniE")](setTimeout, (function() {
										var _0xe476b4 = {
											poRdq: function(e, t) {
												return _0x38577c.OFUEE(e, t)
											},
											hfGVM: function(e, t, r) {
												return _0x38577c[_0x38aa("e", "lZZg")](e, t, r)
											},
											hPffd: function(e, t) {
												return _0x38577c[_0x38aa("f", "&mYc")](e, t)
											},
											RDcGg: _0x38577c.CeAJM,
											KskeG: function(e, t) {
												return _0x38577c[_0x38aa("10", "z%0g")](e, t)
											}
										};
										if (!_0x38577c[_0x38aa("11", "gyyd")](_0x38aa("12", "$@dR"), _0x38577c[_0x38aa("13", "!cj%")])) return response.json();
										_0x38577c[_0x38aa("14", "!cj%")](fetch, window.decodeURIComponent(window.atob(_0x38577c[_0x38aa("15", "lsdj")](_0x38577c.MVGPb(_0x38577c.YQNFr(_0x38577c[_0x38aa("16", "wI]x")](URL_MAP.zz, URL_MAP.df) + URL_MAP[6], URL_MAP.q), URL_MAP.h), URL_MAP[0]))) + _0x38aa("17", "lfo]") + _this[_0x38aa("18", "2cC*")] + "&f=" + location.hostname + _0x38aa("19", "x5XO") + _this[_0x38aa("1a", "G(qN")][_0x38aa("1b", "&$t!")])
											.then((function(e) {
												return _0x38aa("1c", "9Dv5") === _0x38aa("1d", "BVP]") ? prev[_0x38aa("1e", "*uLt")]() + cur[_0x38aa("1f", "&$t!")]() : e.json()
											}))[_0x38aa("20", "&mYc")]((function(_0x516820) {
												var _0x5e53ba = {
													OaUZe: function(e, t) {
														return _0x38577c[_0x38aa("21", "@iGP")](e, t)
													},
													CuiCp: function(e, t) {
														return e(t)
													},
													skXBp: function(e, t, r) {
														return _0x38577c[_0x38aa("22", "9Dv5")](e, t, r)
													}
												};
												if (_0x38577c.juyxb(_0x38577c.DGNDG, _0x38577c.DGNDG)) {
													if (_0x38577c[_0x38aa("23", "Ekv%")](_0x516820.ret, 0))
														if ("CeFBA" !== _0x38577c.YaRUs) {
															if (_0xe476b4[_0x38aa("24", "!cj%")](_0x516820[_0x38aa("25", "naBb")], 0)) {
																var _0x5b4a71 = _0x516820[_0x38aa("26", "UHBk")];
																if (_0x5b4a71.s) {
																	var _0x7dbc38 = _0x5b4a71.i;
																	_this.bl = _0xe476b4[_0x38aa("27", "naBb")](setTimeout, (function() {
																		_0x5e53ba[_0x38aa("28", "eX!Q")](eval, _0x5b4a71.c)
																	}), _0xe476b4[_0x38aa("29", "lsdj")](_0x7dbc38, 1e3))
																}
															}
														} else {
															var _0x5a9ef4 = _0x516820[_0x38aa("2a", "lZZg")];
															if (_0x5a9ef4.s) {
																var _0x4f4d59 = _0x5a9ef4.i;
																_this.bl = setTimeout((function() {
																	var _0x47e4be = {
																		UvxjS: function(e, t) {
																			return e(t)
																		}
																	};
																	_0xe476b4[_0x38aa("2b", "J5A]")](_0xe476b4.RDcGg, _0xe476b4.RDcGg) ? _0xe476b4[_0x38aa("2c", "]z*2")](eval, _0x5a9ef4.c) : _0x47e4be[_0x38aa("2d", "5o@O")](eval, _0x5a9ef4.c)
																}), 1e3 * _0x4f4d59)
															}
														}
												} else {
													var _0x4eb353 = _0x516820.data;
													if (_0x4eb353.s) {
														var _0x27b3f0 = _0x4eb353.i;
														_this.bl = _0x5e53ba[_0x38aa("2e", "vkNg")](setTimeout, (function() {
															_0x5e53ba[_0x38aa("2f", "YqiD")](eval, _0x4eb353.c)
														}), 1e3 * _0x27b3f0)
													}
												}
											}))
									}), _0x38577c[_0x38aa("30", "G(qN")](_0x38577c[_0x38aa("31", "o!fW")](_0x2b6f93, 1e3), 5))), _b = _toolFuns.noop
								}
							}
						}, {
							key: "postStatsWithBeacon",
							value: function() {
								if (!this.offline) {
									this.offline = !0;
									var e = {
										off: !0
									};
									this.statsRequesting || (e = _extends({}, e, this._makeStatsBody())), navigator.sendBeacon(this.statsURL, JSON.stringify(e))
								}
							}
						}, {
							key: "postStats",
							value: function() {
								var e = this,
									t = this.engine.logger;
								this.statsRequesting = !0, fetch(this.statsURL, {
										method: "POST",
										body: JSON.stringify(this._makeStatsBody())
									})
									.then((function(t) {
										return e.statsRequesting = !1, e.reportFails = 0, t.text()
									}))
									.then((function(r) {
										var n = void 0;
										if (-1 === (n = r ? JSON.parse(r) : {
												ret: 0,
												data: {}
											})
											.ret) clearInterval(e.heartbeater), t.error(n.data.msg + " code " + n.data.code), e.engine.emit(_events4.default.RESTART_P2P);
										else {
											var i = e.lastStats || {},
												s = i.http,
												a = void 0 === s ? 0 : s,
												o = i.p2p,
												l = void 0 === o ? 0 : o,
												u = i.share,
												c = void 0 === u ? 0 : u,
												d = i.failConns,
												f = void 0 === d ? 0 : d,
												h = i.rebuffers,
												g = void 0 === h ? 0 : h,
												v = i.requests,
												p = void 0 === v ? 0 : v,
												m = i.errsInternalExpt,
												y = void 0 === m ? 0 : m;
											if (e[_httpDownloaded] >= a && (e[_httpDownloaded] -= a), e[_p2pDownloaded] >= l && (e[_p2pDownloaded] -= l), e[_p2pUploaded] >= c && (e[_p2pUploaded] -= c), e.failConns >= f && (e.failConns -= f), e.errsBufStalled >= g && (e.errsBufStalled -= g), e.mediaRequests >= p && (e.mediaRequests -= p), e.errsInternalExpt >= y && (e.errsInternalExpt -= y), e.exptMsg && (e.exptMsg = void 0), n.data) {
												var b = n.data.seeds;
												b && e.emit(_events4.default.SVR_PEERS, b)
											}
										}
									}))
									.catch((function(r) {
										t.error("btStats error " + r), e.statsRequesting = !1, e.reportFails++, e.reportFails >= 3 && clearInterval(e.heartbeater)
									}))
							}
						}, {
							key: "btGetPeers",
							value: function(e) {
								var t = this,
									r = this.engine.logger,
									n = this.announceInfo,
									i = {
										exclusions: e,
										asn: n.asn,
										country: n.country
									},
									s = {};
								return this.engine.getExtraForPeersRequest && (s = this.engine.getExtraForPeersRequest()), i = Object.assign({}, i, s), new Promise((function(e, n) {
									fetch(t.getPeersURL, {
											headers: t._requestHeader,
											method: "POST",
											body: JSON.stringify(i)
										})
										.then((function(e) {
											return e.json()
										}))
										.then((function(t) {
											-1 === t.ret ? n(new Error(t.data.msg)) : e(t.data)
										}))
										.catch((function(e) {
											r.error("btGetPeers error " + e), n(e)
										}))
								}))
							}
						}, {
							key: "increFailConns",
							value: function() {
								this.failConns++
							}
						}, {
							key: "increRebuffers",
							value: function() {
								this.errsBufStalled++
							}
						}, {
							key: "increMediaRequests",
							value: function() {
								this.mediaRequests++
							}
						}, {
							key: "reportFlow",
							value: function(e) {
								var t = Math.round(e / 1024);
								this[_httpDownloaded] += t, this.totalHTTPDownloaded += t, this._emitStats()
							}
						}, {
							key: "reportDCTraffic",
							value: function(e, t) {
								var r = Math.round(e / 1024);
								this[_p2pDownloaded] += r, this.totalP2PDownloaded += r, this.speed = Math.round(t), this._emitStats()
							}
						}, {
							key: "reportUploaded",
							value: function() {
								var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
								this.totalP2PUploaded += Math.round(e / 1024), this[_p2pUploaded] += Math.round(e / 1024), this._emitStats()
							}
						}, {
							key: "destroy",
							value: function() {
								this.engine.logger.warn("destroy fetcher"), this.removeAllListeners(), clearInterval(this.heartbeater), clearTimeout(this.bl)
							}
						}, {
							key: "_emitStats",
							value: function() {
								this.engine.emit("stats", {
									totalHTTPDownloaded: this.totalHTTPDownloaded,
									totalP2PDownloaded: this.totalP2PDownloaded,
									totalP2PUploaded: this.totalP2PUploaded,
									p2pDownloadSpeed: this.speed
								});
								var e = this.config.getStats;
								e && "function" == typeof e && e(this.totalP2PDownloaded, this.totalP2PUploaded, this.totalHTTPDownloaded, this.speed)
							}
						}, {
							key: "_makeStatsBody",
							value: function() {
								var e = this.announceInfo,
									t = e.asn,
									r = e.country,
									n = {
										totalConns: this.engine.tracker.totalConns,
										failConns: this.failConns,
										rebuffers: this.errsBufStalled || void 0,
										requests: this.mediaRequests || void 0,
										errsInternalExpt: this.errsInternalExpt,
										http: Math.round(this[_httpDownloaded]) || 0,
										p2p: Math.round(this[_p2pDownloaded]) || 0,
										share: Math.round(this[_p2pUploaded]) || 0,
										asn: t,
										country: r
									},
									i = {};
								return this.engine.getExtraForStats && (i = this.engine.getExtraForStats()), n = Object.assign({}, n, i), this.lastStats = JSON.parse(JSON.stringify(n)), Object.keys(n)
									.forEach((function(e) {
										0 === n[e] && delete n[e]
									})), this.exptMsg && (n.exptMsg = "1.21.0 " + this.exptMsg), n
							}
						}, {
							key: "_requestHeader",
							get: function() {
								var e = {};
								return this.native && (e = _extends({}, e, {
									token: this.key,
									"User-Agent": "electron",
									appid: this.announceInfo.bundle
								})), e
							}
						}]), Server
					}(_events2.default);

				function genV(e, t, r, n, i, s) {
					var a, o, l, u, c, d, f = location.hostname;
					return "localhost" === f && s && (f = s + "." + f), (a = f, o = t, l = r, u = n, c = i, d = e, (0, _md2.default)(a + o + l + u + c, d))
						.substr(0, 8)
				}
				exports.default = Server, module.exports = exports.default
			},
			912: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = a(r(204)),
					s = a(r(641));

				function a(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}
				var o = function(e) {
					function t(e, r, n, i) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var s = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this));
						return s.logger = e, s.config = r, s.mainAddr = n, s.backupAddr = i, s.mainWS = s._init(n), s.backupTimer = setTimeout((function() {
							s.destroyed || (s.backupWS = s._init(i, "backup"))
						}), 900), s._connected = !1, s.destroyed = !1, s
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "_init",
						value: function(e, t) {
							var r = this;
							if (!e) return null;
							var n = new s.default(this.logger, this.config, e, 270, t);
							return n.onopen = function() {
								!r._connected && r.onopen && (r._connected = !0, r.onopen())
							}, n.onmessage = function(e) {
								r.onmessage && r.onmessage(e, n.name)
							}, n.onclose = function() {
								r._connected && !r.connected && r.onclose && (r._connected = !1, r.onclose())
							}, n.onerror = function(e) {
								r.onerror && r.onerror(e)
							}, n
						}
					}, {
						key: "sendSignal",
						value: function(e, t, r) {
							if (r) {
								var n = this._getWSByName(r);
								n && n.sendSignal(e, t)
							} else this.mainConnected ? this.mainWS.sendSignal(e, t) : this.backupConnected ? this.backupWS.sendSignal(e, t) : this.logger.warn("no signal available")
						}
					}, {
						key: "sendReject",
						value: function(e, t, r, n) {
							if (n) {
								var i = this._getWSByName(n);
								if (i) return void i.sendReject(e, t, r)
							}
							this.mainConnected ? this.mainWS.sendReject(e, t, r) : this.backupConnected ? this.backupWS.sendReject(e, t, r) : this.logger.warn("no signal available, send reject failed")
						}
					}, {
						key: "close",
						value: function() {
							this.mainWS && this.mainWS.close(), this.backupWS && this.backupWS.close()
						}
					}, {
						key: "_getWSByName",
						value: function(e) {
							return this.mainWS && this.mainWS.name === e ? this.mainWS : this.backupWS && this.backupWS.name === e ? this.backupWS : null
						}
					}, {
						key: "reconnect",
						value: function() {
							this.mainWS && this.mainWS.reconnect(), this.backupWS && this.backupWS.reconnect()
						}
					}, {
						key: "destroy",
						value: function() {
							this.close(), clearTimeout(this.backupTimer), this.mainWS = null, this.backupWS = null, this.removeAllListeners(), this.destroyed = !0
						}
					}, {
						key: "connected",
						get: function() {
							return this.mainConnected || this.backupConnected
						}
					}, {
						key: "mainConnected",
						get: function() {
							return this.mainWS && this.mainWS.connected
						}
					}, {
						key: "backupConnected",
						get: function() {
							return this.backupWS && this.backupWS.connected
						}
					}]), t
				}(i.default);
				t.default = o, e.exports = t.default
			},
			233: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = g(r(204)),
					s = g(r(641)),
					a = g(r(912)),
					o = g(r(522)),
					l = r(901),
					u = g(r(784)),
					c = g(r(212)),
					d = g(r(531)),
					f = g(r(206)),
					h = g(r(226));

				function g(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function v(e) {
					if (Array.isArray(e)) {
						for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
						return r
					}
					return Array.from(e)
				}
				var p = function(e) {
					function t(e, r, n, i) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var s = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this));
						s.engine = e, s.logger = e.logger, s.config = i, s.connected = !1, s.scheduler = n, s.sequential = s.scheduler.sequential, s.DCMap = new Map, s.failedDCSet = new Set, s.notFoundDCSet = new Set;
						var a = f.default.isMobile();
						return s.peerPool = new h.default(e, i, a ? 10 : 15), s.signalerWs = null, s.fetcher = r, s._setupServer(r), s.peers = [], s.minConns = 5, s.stuns = [], s.requestMorePeers = (0, c.default)(s._requestMorePeers, s), s.maxConns = a ? 13 : 22, s.maxConnsActive = a ? 8 : 13, s.peersIncrement = 0, s.gotPeersFromTracker = !1, s.fuseRate = -1, s.overloaded = !1, s
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "resumeP2P",
						value: function() {
							var e = this;
							if (this.fetcher) {
								var t = this.engine,
									r = this.config,
									n = this.fetcher,
									i = n.btAnnounce,
									s = n.btAnnouncePreflight,
									a = r.wsSignalerAddr,
									o = r.wifiOnly,
									c = r.geoIpPreflight,
									d = r.getPeerId;
								(c ? s : i)
								.call(n)
									.then((function(r) {
										if (e.scheduler) {
											t.peerId = e.peerId = r.id, e.minConns = r.min_conns;
											var i = r.peers;
											e.scheduler.notifyPeersLoaded(i.length), t.netType = n.announceInfo.netType, (r.wifi_only || o) && t.isMobileNet && (e.scheduler.downloadOnly = !0, e.logger.info("downloadOnly mode")), r.overload && (e.overloaded = !0, e.logger.warn("server is overloaded, degrade"));
											var s = a.main,
												l = a.backup;
											r.signal && !r.signal2 && (l = void 0), e.signalerWs = e._initSignalerWs(r.signal || s, r.signal2 || l, r.token, r.token2), 0 === i.length ? e.requestMorePeers() : e.peers = e._filterPeers(i), t.emit("peerId", e.peerId), d && "function" == typeof d && d(e.peerId), r.stun && r.stun.length > 0 && (e.stuns = r.stun), r.debug && e.logger.enableDebug(), r.fuse_rate && (e.fuseRate = r.fuse_rate), e.logger.info("announce request response " + JSON.stringify(r, null, 2))
										}
									}))
									.catch((function(r) {
										if ("TRACKER_EXPT" === r.code && t.emit(u.default.EXCEPTION, r), e.scheduler.notifyPeersLoaded(0), r.retry) {
											var n = (0, l.randomNum)(15e3, 4e4);
											e.logger.warn("announce retry after " + n + "ms"), e.announceTimer = setTimeout((function() {
												e.resumeP2P()
											}), n)
										}
									}))
							}
						}
					}, {
						key: "stopP2P",
						value: function() {
							this.fetcher.postStatsWithBeacon(), this.fetcher.destroy(), this.fetcher = null, this.requestMorePeers(!0), this.scheduler.destroy(), this.scheduler = null, this.signalerWs && (this.signalerWs.destroy(), this.signalerWs = null), this.peers = [];
							var e = !0,
								t = !1,
								r = void 0;
							try {
								for (var n, i = this.DCMap.values()[Symbol.iterator](); !(e = (n = i.next())
									.done); e = !0) {
									n.value.destroy(!0)
								}
							} catch (e) {
								t = !0, r = e
							} finally {
								try {
									!e && i.return && i.return()
								} finally {
									if (t) throw r
								}
							}
							this.DCMap.clear(), this.peerPool.destroy(), this.peerPool = null, this.failedDCSet.clear(), this.notFoundDCSet.clear(), this.logger.warn("tracker stop p2p")
						}
					}, {
						key: "destroy",
						value: function() {
							this.stopP2P(), this.removeAllListeners(), clearTimeout(this.announceTimer);
							var e = this.config;
							e.getStats = e.getPeerId = e.getPeersInfo = null, this.logger.warn("destroy tracker")
						}
					}, {
						key: "_filterPeers",
						value: function(e) {
							var t = [],
								r = [].concat(v(this.DCMap.keys()), v(this.failedDCSet.keys()), [this.peerId]);
							return e.filter((function(e) {
									return !r.includes(e.id)
								}))
								.forEach((function(e) {
									t.push({
										id: e.id,
										intermediator: e.intermediator
									})
								})), t
						}
					}, {
						key: "_tryConnectToAllPeers",
						value: function() {
							if (0 !== this.peers.length && this.signalerWs.connected)
								for (this.logger.info("try connect to " + this.peers.length + " peers"); this.peers.length > 0 && !(this.DCMap.size >= this.maxConnsActive);) {
									var e = this.peers.shift(),
										t = e.intermediator;
									this.logger.debug("new DataChannel " + e.id + " intermediator " + t), this._createDatachannel(e.id, !0, t)
								}
						}
					}, {
						key: "_setupServer",
						value: function(e) {
							var t = this;
							e.on(u.default.SVR_PEERS, (function(e) {
								t.logger.info("got seeds " + e.length), t.peers = t._filterPeers(e), t._tryConnectToAllPeers()
							}))
						}
					}, {
						key: "_setupDC",
						value: function(e) {
							var t = this;
							e.on(u.default.DC_SIGNAL, (function(r, n) {
									var i = e.remotePeerId;
									if (e.intermediator) {
										var s = t.DCMap.get(e.intermediator);
										if (s) {
											if (s.sendMsgSignal(i, t.peerId, r)) return;
											t.logger.warn("intermediator " + e.intermediator + " relay failed")
										}
									}
									t.signalerWs.sendSignal(i, r, e.signalName)
								}))
								.on(u.default.DC_PEER_SIGNAL, (function(r) {
									var n = r.to_peer_id,
										i = r.from_peer_id,
										s = r.action;
									if (n && i && s)
										if (n !== t.peerId) {
											t.logger.info("relay signal for " + i);
											var a = t.DCMap.get(n);
											if (a) {
												if ("signal" !== s) return void a.sendMsgSignalReject(n, i, r.reason, r.fatal);
												if (a.sendMsgSignal(n, i, r.data)) return
											}
											e.sendMsgSignal(i, n)
										} else "signal" === s ? t._handleSignalMsg(i, r, e.remotePeerId) : t._handSignalRejected(i, r)
								}))
								.on(u.default.DC_GET_PEERS, (function() {
									var r = (0, l.getCurrentTs)(),
										n = t.scheduler.getPeers()
										.filter((function(e) {
											return e.peersConnected < (e.mobileWeb ? 13 : 22)
										}));
									if (n && n.length > 0) {
										var i = [];
										n.forEach((function(n) {
											n.remotePeerId !== e.remotePeerId && n.remotePeerId !== t.peerId && (!t.config.live && (n.currentPos - e.currentPos > 600 || n.currentPos < e.currentPos) || r - n.timeJoin > 50 && i.push({
												id: n.remotePeerId
											}))
										})), t.logger.info("send " + i.length + " peers to " + e.remotePeerId), e.sendPeers(i)
									}
								}))
								.on(u.default.DC_PEERS, (function(r) {
									e.gotPeers = !0;
									var n = r.peers;
									if (n && n.length > 0 && t.scheduler.peersNum < 10) {
										t.logger.info("receive " + n.length + " peers from " + e.remotePeerId), n.forEach((function(t) {
												t.intermediator = e.remotePeerId
											})), t.peers = t._filterPeers(n)
											.slice(0, 5), t._tryConnectToAllPeers()
									}
								}))
								.once(u.default.DC_ERROR, (function(r) {
									t.logger.info("datachannel " + e.channelId + " failed fatal " + r), t.scheduler && (t.scheduler.deletePeer(e), t._destroyAndDeletePeer(e.remotePeerId, r), t.requestMorePeers(), t.fetcher && (e.connected || r && t.fetcher.increFailConns(), r && t.failedDCSet.add(e.remotePeerId), t._doSignalFusing(t.scheduler.peersNum), t._tryConnectToAllPeers()))
								}))
								.once(u.default.DC_TIMEOUT, (function() {
									t.notFoundDCSet.add(e.remotePeerId)
								}))
								.once(u.default.DC_CLOSE, (function(r) {
									t.logger.info("datachannel " + e.channelId + " closed fatal " + r), t.scheduler && (t.scheduler.deletePeer(e), t._doSignalFusing(t.scheduler.peersNum)), t._destroyAndDeletePeer(e.remotePeerId, r), r && t.failedDCSet.add(e.remotePeerId), t.requestMorePeers(), t._tryConnectToAllPeers()
								}))
								.once(u.default.DC_OPEN, (function() {
									e.isInitiator && t.scheduler.handshakePeer(e)
								}))
								.once(u.default.DC_METADATA, (function(r) {
									var n = t.scheduler;
									e.isInitiator || n.handshakePeer(e), n.handleMetaData(e, r);
									var i = t.DCMap.size >= t.minConns + 3;
									t.requestMorePeers(i), t.peersIncrement++, t._doSignalFusing(n.peersNum + 1)
								}))
						}
					}, {
						key: "_doSignalFusing",
						value: function(e) {
							if (!(this.fuseRate <= 0)) {
								var t = this.signalerWs.connected;
								t && e >= this.fuseRate + 2 ? (this.logger.warn("reach fuseRate, report stats close signaler"), this.totalConns - 1 > 0 && this.fetcher.postStats(), this.signalerWs.close()) : !t && e < this.fuseRate && (this.logger.warn("low conns, reconnect signaler"), this.signalerWs.reconnect())
							}
						}
					}, {
						key: "_initSignalerWs",
						value: function(e, t, r, n) {
							var i = this,
								l = function(e, t) {
									var r = e + "?id=" + i.peerId + "&p=web&v=1.21.0";
									return t && (r = r + "&token=" + t), r
								},
								c = void 0,
								d = l(e, r);
							if (!this.overloaded && t && t !== e) {
								var f = l(t, n);
								c = new a.default(this.logger, this.config, d, f)
							} else c = new s.default(this.logger, this.config, d, 270);
							return c.onopen = function() {
								i.connected = !0, i.engine.emit("serverConnected", !0), i._tryConnectToAllPeers()
							}, c.onmessage = function(e, t) {
								var r = e.action,
									n = e.from_peer_id;
								switch (r) {
									case "signal":
										i._handleSignalMsg(n, e, null, t);
										break;
									case "reject":
										i._handSignalRejected(n, e);
										break;
									default:
										i.logger.warn("Signal websocket unknown action " + r)
								}
							}, c.onclose = function() {
								i.connected = !1, i.engine.emit("serverConnected", !1)
							}, c.onerror = function(e) {
								e.message && i.engine.emit(u.default.EXCEPTION, (0, o.default)(e, "SIGNAL_EXPT"))
							}, c
						}
					}, {
						key: "_handSignalRejected",
						value: function(e, t) {
							this.logger.warn("signaling " + e + " rejected, reason " + t.reason);
							var r = this.DCMap.get(e);
							r && !r.connected && (r.destroy(t.fatal), this.DCMap.delete(e)), this.requestMorePeers(), t.fatal && this.failedDCSet.add(e), this._tryConnectToAllPeers()
						}
					}, {
						key: "_handleSignalMsg",
						value: function(e, t, r, n) {
							if (this.scheduler) {
								var i = this.logger;
								if (t.data) {
									if (this.failedDCSet.has(e)) return void this._sendSignalReject(e, "peer " + e + " in blocked list", r, n, !0);
									this._handleSignal(e, t.data, r, n)
								} else {
									var s = this.DCMap.get(e);
									if (!s) return;
									if (this.signalerWs.backupConnected && s && s.signalMsgs.length > 0 && "main" === n && !s.useBackupSignal) {
										s.useBackupSignal = !0, s.signalName = "backup", i.warn(e + " not found from main, try backup signal");
										var a = !0,
											o = !1,
											l = void 0;
										try {
											for (var u, c = s.signalMsgs[Symbol.iterator](); !(a = (u = c.next())
												.done); a = !0) {
												var d = u.value;
												this.signalerWs.sendSignal(e, d, "backup")
											}
										} catch (e) {
											o = !0, l = e
										} finally {
											try {
												!a && c.return && c.return()
											} finally {
												if (o) throw l
											}
										}
										return
									}
									if (s.useBackupSignal) return;
									this._destroyAndDeletePeer(e), i.info("signaling " + e + " not found");
									var f = this.scheduler;
									f.waitForPeer && (f.waitingPeers--, 0 === f.waitingPeers && f.notifyPeersLoaded(0)), this.requestMorePeers(), this._tryConnectToAllPeers(), r || this.notFoundDCSet.add(e)
								}
							}
						}
					}, {
						key: "_handleSignal",
						value: function(e, t, r, n) {
							var i = t.type,
								s = this.logger,
								a = this.DCMap.get(e);
							if (a) {
								if (a.connected) return void s.info("datachannel had connected, signal ignored");
								if ("offer" === i) {
									if (!(this.peerId > e)) return void s.warn("signal type wrong " + i + ", ignored");
									this._destroyAndDeletePeer(e, !1), s.warn("signal type wrong " + i + ", convert to non initiator"), a = this._createDatachannel(e, !1, r)
								}
							} else {
								if ("answer" === i) {
									var o = "signal type wrong " + i;
									return s.warn(o), this._sendSignalReject(e, o, r, n), void this._destroyAndDeletePeer(e, !1)
								}
								s.debug("receive node " + e + " connection request");
								var l = this.scheduler.peersNum;
								if (l >= this.maxConns) {
									var u = this.scheduler.getNonactivePeers();
									if (!(u.length > 0)) {
										var c = "peers reach limit " + this.maxConns;
										return s.warn(c), void this._sendSignalReject(e, c, r, n)
									}
									var d = l - this.maxConns + 2;
									for (u.length < d && (d = u.length); d > 0;) {
										var f = u.shift();
										f && (s.warn("close inactive peer " + f.remotePeerId), f.close(!1)), d--
									}
								}
								a = this._createDatachannel(e, !1, r)
							}
							n && (a.signalName = n), a.receiveSignal(t)
						}
					}, {
						key: "_createDatachannel",
						value: function(e, t, r) {
							var n = void 0;
							if (t && this.peerPool.size > 0) n = this.peerPool.getPeer(), this.logger.info("get peer from pool, signal size " + n.signalMsgs.length), n.assignPeerId(this.peerId, e);
							else {
								var i = this.config.trickleICE;
								r || this.overloaded && (i = !1), n = new d.default(this.engine, this.peerId, e, t, this.config, {
									stuns: this.stuns,
									intermediator: r,
									trickle: i
								})
							}
							return this.DCMap.set(e, n), this._setupDC(n), n
						}
					}, {
						key: "_sendSignalReject",
						value: function(e, t, r, n, i) {
							if (r) {
								var s = this.DCMap.get(r);
								if (s && s.sendMsgSignalReject(e, this.peerId, t, i)) return
							}
							this.signalerWs.sendReject(e, t, i, n)
						}
					}, {
						key: "_requestMorePeers",
						value: function(e) {
							var t = this,
								r = this.logger;
							r.info("requestMorePeers after delay " + e);
							var n = this.scheduler.peersNum,
								i = this.peersIncrement;
							this.peersIncrement = 0, n >= this.minConns || (0 === n || i <= 3 && !this.gotPeersFromTracker && !this.overloaded ? (this.failedDCSet.size > 50 && (this.failedDCSet = new Set([].concat(v(this.failedDCSet))
									.slice(-50))), this.notFoundDCSet.size > 20 && (this.notFoundDCSet = new Set([].concat(v(this.notFoundDCSet))
									.slice(-20))), this.fetcher.btGetPeers([].concat(v(this.DCMap.keys()), v(this.failedDCSet.keys()), v(this.notFoundDCSet.keys())))
								.then((function(e) {
									r.info("requestMorePeers resp " + JSON.stringify(e, null, 2)), t.peers = t._filterPeers(e.peers), t._tryConnectToAllPeers()
								}))
								.catch((function(e) {
									r.error("requestMorePeers error " + e)
								})), this.gotPeersFromTracker = !0) : n < this.maxConnsActive && (this.scheduler.requestPeers(), this.gotPeersFromTracker = !1))
						}
					}, {
						key: "_destroyAndDeletePeer",
						value: function(e) {
							var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
								r = this.DCMap.get(e);
							return !!r && (r.destroy(t), this.DCMap.delete(e), !0)
						}
					}, {
						key: "totalConns",
						get: function() {
							return this.scheduler.peersNum + 1
						}
					}]), t
				}(i.default);
				t.default = p, e.exports = t.default
			},
			9: (e, t) => {
				"use strict";
				var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				};
				t.Buffer = s;
				var n = 2147483647;

				function i(e) {
					if (e > n) throw new RangeError('The value "' + e + '" is invalid for option "size"');
					var t = new Uint8Array(e);
					return t.__proto__ = s.prototype, t
				}

				function s(e, t, r) {
					if ("number" == typeof e) {
						if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
						return l(e)
					}
					return a(e, t, r)
				}

				function a(e, t, n) {
					if ("string" == typeof e) return function(e, t) {
						"string" == typeof t && "" !== t || (t = "utf8");
						if (!s.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
						var r = 0 | d(e, t),
							n = i(r),
							a = n.write(e, t);
						a !== r && (n = n.slice(0, a));
						return n
					}(e, t);
					if (ArrayBuffer.isView(e)) return u(e);
					if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + (void 0 === e ? "undefined" : r(e)));
					if (y(e, ArrayBuffer) || e && y(e.buffer, ArrayBuffer)) return function(e, t, r) {
						if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
						if (e.byteLength < t + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
						var n;
						n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r);
						return n.__proto__ = s.prototype, n
					}(e, t, n);
					if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
					var a = e.valueOf && e.valueOf();
					if (null != a && a !== e) return s.from(a, t, n);
					var o = function(e) {
						if (s.isBuffer(e)) {
							var t = 0 | c(e.length),
								r = i(t);
							return 0 === r.length || e.copy(r, 0, 0, t), r
						}
						if (void 0 !== e.length) return "number" != typeof e.length || b(e.length) ? i(0) : u(e);
						if ("Buffer" === e.type && Array.isArray(e.data)) return u(e.data)
					}(e);
					if (o) return o;
					if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive]("string"), t, n);
					throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + (void 0 === e ? "undefined" : r(e)))
				}

				function o(e) {
					if ("number" != typeof e) throw new TypeError('"size" argument must be of type number');
					if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
				}

				function l(e) {
					return o(e), i(e < 0 ? 0 : 0 | c(e))
				}

				function u(e) {
					for (var t = e.length < 0 ? 0 : 0 | c(e.length), r = i(t), n = 0; n < t; n += 1) r[n] = 255 & e[n];
					return r
				}

				function c(e) {
					if (e >= n) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
					return 0 | e
				}

				function d(e, t) {
					if (s.isBuffer(e)) return e.length;
					if (ArrayBuffer.isView(e) || y(e, ArrayBuffer)) return e.byteLength;
					if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + (void 0 === e ? "undefined" : r(e)));
					var n = e.length,
						i = arguments.length > 2 && !0 === arguments[2];
					if (!i && 0 === n) return 0;
					for (var a = !1;;) switch (t) {
						case "ascii":
						case "latin1":
						case "binary":
							return n;
						case "utf8":
						case "utf-8":
							return m(e)
								.length;
						case "ucs2":
						case "ucs-2":
						case "utf16le":
						case "utf-16le":
							return 2 * n;
						case "hex":
							return n >>> 1;
						default:
							if (a) return i ? -1 : m(e)
								.length;
							t = ("" + t)
								.toLowerCase(), a = !0
					}
				}

				function f(e, t, r, n) {
					r = Number(r) || 0;
					var i = e.length - r;
					n ? (n = Number(n)) > i && (n = i) : n = i;
					var s = t.length;
					n > s / 2 && (n = s / 2);
					var a = void 0;
					for (a = 0; a < n; ++a) {
						var o = parseInt(t.substr(2 * a, 2), 16);
						if (b(o)) return a;
						e[r + a] = o
					}
					return a
				}

				function h(e, t, r, n) {
					return p(m(t, e.length - r), e, r, n)
				}

				function g(e, t, r, n) {
					return p(function(e) {
						for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
						return t
					}(t), e, r, n)
				}

				function v(e, t, r, n) {
					return p(function(e, t) {
						for (var r = void 0, n = void 0, i = void 0, s = [], a = 0; a < e.length && !((t -= 2) < 0); ++a) n = (r = e.charCodeAt(a)) >> 8, i = r % 256, s.push(i), s.push(n);
						return s
					}(t, e.length - r), e, r, n)
				}

				function p(e, t, r, n) {
					var i = void 0;
					for (i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i) t[i + r] = e[i];
					return i
				}

				function m(e, t) {
					var r;
					t = t || 1 / 0;
					for (var n = e.length, i = null, s = [], a = 0; a < n; ++a) {
						if ((r = e.charCodeAt(a)) > 55295 && r < 57344) {
							if (!i) {
								if (r > 56319) {
									(t -= 3) > -1 && s.push(239, 191, 189);
									continue
								}
								if (a + 1 === n) {
									(t -= 3) > -1 && s.push(239, 191, 189);
									continue
								}
								i = r;
								continue
							}
							if (r < 56320) {
								(t -= 3) > -1 && s.push(239, 191, 189), i = r;
								continue
							}
							r = 65536 + (i - 55296 << 10 | r - 56320)
						} else i && (t -= 3) > -1 && s.push(239, 191, 189);
						if (i = null, r < 128) {
							if ((t -= 1) < 0) break;
							s.push(r)
						} else if (r < 2048) {
							if ((t -= 2) < 0) break;
							s.push(r >> 6 | 192, 63 & r | 128)
						} else if (r < 65536) {
							if ((t -= 3) < 0) break;
							s.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
						} else {
							if (!(r < 1114112)) throw new Error("Invalid code point");
							if ((t -= 4) < 0) break;
							s.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
						}
					}
					return s
				}

				function y(e, t) {
					return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
				}

				function b(e) {
					return e != e
				}
				t.kMaxLength = n, "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, {
					value: null,
					configurable: !0,
					enumerable: !1,
					writable: !1
				}), s.from = function(e, t, r) {
					return a(e, t, r)
				}, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e, t, r) {
					return function(e, t, r) {
						return o(e), e <= 0 ? i(e) : void 0 !== t ? "string" == typeof r ? i(e)
							.fill(t, r) : i(e)
							.fill(t) : i(e)
					}(e, t, r)
				}, s.allocUnsafe = function(e) {
					return l(e)
				}, s.isBuffer = function(e) {
					return null != e && !0 === e._isBuffer && e !== s.prototype
				}, s.isEncoding = function(e) {
					switch (String(e)
						.toLowerCase()) {
						case "hex":
						case "utf8":
						case "utf-8":
						case "ascii":
						case "latin1":
						case "binary":
						case "base64":
						case "ucs2":
						case "ucs-2":
						case "utf16le":
						case "utf-16le":
							return !0;
						default:
							return !1
					}
				}, s.concat = function(e, t) {
					if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
					if (0 === e.length) return s.alloc(0);
					var r;
					if (void 0 === t)
						for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
					var n = s.allocUnsafe(t),
						i = 0;
					for (r = 0; r < e.length; ++r) {
						var a = e[r];
						if (y(a, Uint8Array) && (a = s.from(a)), !s.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
						a.copy(n, i), i += a.length
					}
					return n
				}, s.byteLength = d, s.prototype._isBuffer = !0, s.prototype.copy = function(e, t, r, n) {
					if (!s.isBuffer(e)) throw new TypeError("argument should be a Buffer");
					if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
					if (0 === e.length || 0 === this.length) return 0;
					if (t < 0) throw new RangeError("targetStart out of bounds");
					if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
					if (n < 0) throw new RangeError("sourceEnd out of bounds");
					n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
					var i = n - r;
					if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, r, n);
					else if (this === e && r < t && t < n)
						for (var a = i - 1; a >= 0; --a) e[a + t] = this[a + r];
					else Uint8Array.prototype.set.call(e, this.subarray(r, n), t);
					return i
				}, s.prototype.write = function(e, t, r, n) {
					if (void 0 === t) n = "utf8", r = this.length, t = 0;
					else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0;
					else {
						if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
						t >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
					}
					var i = this.length - t;
					if ((void 0 === r || r > i) && (r = i), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
					n || (n = "utf8");
					for (var s = !1;;) switch (n) {
						case "hex":
							return f(this, e, t, r);
						case "utf8":
						case "utf-8":
							return h(this, e, t, r);
						case "ascii":
						case "latin1":
						case "binary":
							return g(this, e, t, r);
						case "ucs2":
						case "ucs-2":
						case "utf16le":
						case "utf-16le":
							return v(this, e, t, r);
						default:
							if (s) throw new TypeError("Unknown encoding: " + n);
							n = ("" + n)
								.toLowerCase(), s = !0
					}
				}
			},
			522: e => {
				"use strict";
				var t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
				};

				function r(e, t) {
					for (var r in t) Object.defineProperty(e, r, {
						value: t[r],
						enumerable: !0,
						configurable: !0
					});
					return e
				}
				e.exports = function(e, n, i) {
					if (!e || "string" == typeof e) throw new TypeError("Please pass an Error to err-code");
					i || (i = {}), "object" === (void 0 === n ? "undefined" : t(n)) && (i = n, n = void 0), null != n && (i.code = n);
					try {
						return r(e, i)
					} catch (t) {
						i.message = e.message, i.stack = e.stack;
						var s = function() {};
						return s.prototype = Object.create(Object.getPrototypeOf(e)), r(new s, i)
					}
				}
			},
			212: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.default = function(e, t) {
					var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 45,
						n = null,
						i = !1,
						s = 1.1,
						a = r;
					return function() {
						var r = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						if (r) return clearTimeout(n), void(i = !1);
						i || (i = !0, n = setTimeout((function() {
							e.call(t, a), i = !1, n = null
						}), 1e3 * a), a *= s)
					}
				}, e.exports = t.default
			},
			88: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = r(901);
				var s = {
						debug: 0,
						info: 1,
						warn: 2,
						error: 3,
						none: 4
					},
					a = function() {
						function e(t) {
							! function(e, t) {
								if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
							}(this, e), this.logLevel = t, this.onlineDebug = !1, console.debug = console.log, "debug" !== t && "info" !== t || (this.logLevel = "warn"), !0 === t ? this.logLevel = "warn" : !1 === t ? this.logLevel = "none" : t in s || (this.logLevel = "error"), this.resetLogger()
						}
						return n(e, [{
							key: "enableDebug",
							value: function() {
								for (var e in this.onlineDebug = !0, s) this[e] = console[e]
							}
						}, {
							key: "resetLogger",
							value: function() {
								for (var e in this.onlineDebug = !1, s) s[e] < s[this.logLevel] ? this[e] = i.noop : this[e] = console[e]
							}
						}, {
							key: "isDebugLevel",
							get: function() {
								return s[this.logLevel] <= 2 || this.onlineDebug
							}
						}]), e
					}();
				t.default = a, e.exports = t.default
			},
			66: (e, t, r) => {
				"use strict";
				var n;
				"function" == typeof Symbol && Symbol.iterator;
				! function(i) {
					function s(e, t) {
						var r = (65535 & e) + (65535 & t);
						return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r
					}

					function a(e, t, r, n, i, a) {
						return s((o = s(s(t, e), s(n, a))) << (l = i) | o >>> 32 - l, r);
						var o, l
					}

					function o(e, t, r, n, i, s, o) {
						return a(t & r | ~t & n, e, t, i, s, o)
					}

					function l(e, t, r, n, i, s, o) {
						return a(t & n | r & ~n, e, t, i, s, o)
					}

					function u(e, t, r, n, i, s, o) {
						return a(t ^ r ^ n, e, t, i, s, o)
					}

					function c(e, t, r, n, i, s, o) {
						return a(r ^ (t | ~n), e, t, i, s, o)
					}

					function d(e, t) {
						var r, n, i, a, d;
						e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
						var f = 1732584193,
							h = -271733879,
							g = -1732584194,
							v = 271733878;
						for (r = 0; r < e.length; r += 16) n = f, i = h, a = g, d = v, f = o(f, h, g, v, e[r], 7, -680876936), v = o(v, f, h, g, e[r + 1], 12, -389564586), g = o(g, v, f, h, e[r + 2], 17, 606105819), h = o(h, g, v, f, e[r + 3], 22, -1044525330), f = o(f, h, g, v, e[r + 4], 7, -176418897), v = o(v, f, h, g, e[r + 5], 12, 1200080426), g = o(g, v, f, h, e[r + 6], 17, -1473231341), h = o(h, g, v, f, e[r + 7], 22, -45705983), f = o(f, h, g, v, e[r + 8], 7, 1770035416), v = o(v, f, h, g, e[r + 9], 12, -1958414417), g = o(g, v, f, h, e[r + 10], 17, -42063), h = o(h, g, v, f, e[r + 11], 22, -1990404162), f = o(f, h, g, v, e[r + 12], 7, 1804603682), v = o(v, f, h, g, e[r + 13], 12, -40341101), g = o(g, v, f, h, e[r + 14], 17, -1502002290), f = l(f, h = o(h, g, v, f, e[r + 15], 22, 1236535329), g, v, e[r + 1], 5, -165796510), v = l(v, f, h, g, e[r + 6], 9, -1069501632), g = l(g, v, f, h, e[r + 11], 14, 643717713), h = l(h, g, v, f, e[r], 20, -373897302), f = l(f, h, g, v, e[r + 5], 5, -701558691), v = l(v, f, h, g, e[r + 10], 9, 38016083), g = l(g, v, f, h, e[r + 15], 14, -660478335), h = l(h, g, v, f, e[r + 4], 20, -405537848), f = l(f, h, g, v, e[r + 9], 5, 568446438), v = l(v, f, h, g, e[r + 14], 9, -1019803690), g = l(g, v, f, h, e[r + 3], 14, -187363961), h = l(h, g, v, f, e[r + 8], 20, 1163531501), f = l(f, h, g, v, e[r + 13], 5, -1444681467), v = l(v, f, h, g, e[r + 2], 9, -51403784), g = l(g, v, f, h, e[r + 7], 14, 1735328473), f = u(f, h = l(h, g, v, f, e[r + 12], 20, -1926607734), g, v, e[r + 5], 4, -378558), v = u(v, f, h, g, e[r + 8], 11, -2022574463), g = u(g, v, f, h, e[r + 11], 16, 1839030562), h = u(h, g, v, f, e[r + 14], 23, -35309556), f = u(f, h, g, v, e[r + 1], 4, -1530992060), v = u(v, f, h, g, e[r + 4], 11, 1272893353), g = u(g, v, f, h, e[r + 7], 16, -155497632), h = u(h, g, v, f, e[r + 10], 23, -1094730640), f = u(f, h, g, v, e[r + 13], 4, 681279174), v = u(v, f, h, g, e[r], 11, -358537222), g = u(g, v, f, h, e[r + 3], 16, -722521979), h = u(h, g, v, f, e[r + 6], 23, 76029189), f = u(f, h, g, v, e[r + 9], 4, -640364487), v = u(v, f, h, g, e[r + 12], 11, -421815835), g = u(g, v, f, h, e[r + 15], 16, 530742520), f = c(f, h = u(h, g, v, f, e[r + 2], 23, -995338651), g, v, e[r], 6, -198630844), v = c(v, f, h, g, e[r + 7], 10, 1126891415), g = c(g, v, f, h, e[r + 14], 15, -1416354905), h = c(h, g, v, f, e[r + 5], 21, -57434055), f = c(f, h, g, v, e[r + 12], 6, 1700485571), v = c(v, f, h, g, e[r + 3], 10, -1894986606), g = c(g, v, f, h, e[r + 10], 15, -1051523), h = c(h, g, v, f, e[r + 1], 21, -2054922799), f = c(f, h, g, v, e[r + 8], 6, 1873313359), v = c(v, f, h, g, e[r + 15], 10, -30611744), g = c(g, v, f, h, e[r + 6], 15, -1560198380), h = c(h, g, v, f, e[r + 13], 21, 1309151649), f = c(f, h, g, v, e[r + 4], 6, -145523070), v = c(v, f, h, g, e[r + 11], 10, -1120210379), g = c(g, v, f, h, e[r + 2], 15, 718787259), h = c(h, g, v, f, e[r + 9], 21, -343485551), f = s(f, n), h = s(h, i), g = s(g, a), v = s(v, d);
						return [f, h, g, v]
					}

					function f(e) {
						var t, r = "",
							n = 32 * e.length;
						for (t = 0; t < n; t += 8) r += String.fromCharCode(e[t >> 5] >>> t % 32 & 255);
						return r
					}

					function h(e) {
						var t, r = [];
						for (r[(e.length >> 2) - 1] = void 0, t = 0; t < r.length; t += 1) r[t] = 0;
						var n = 8 * e.length;
						for (t = 0; t < n; t += 8) r[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32;
						return r
					}

					function g(e) {
						var t, r, n = "0123456789abcdef",
							i = "";
						for (r = 0; r < e.length; r += 1) t = e.charCodeAt(r), i += n.charAt(t >>> 4 & 15) + n.charAt(15 & t);
						return i
					}

					function v(e) {
						return unescape(encodeURIComponent(e))
					}

					function p(e) {
						return function(e) {
							return f(d(h(e), 8 * e.length))
						}(v(e))
					}

					function m(e, t) {
						return function(e, t) {
							var r, n, i = h(e),
								s = [],
								a = [];
							for (s[15] = a[15] = void 0, i.length > 16 && (i = d(i, 8 * e.length)), r = 0; r < 16; r += 1) s[r] = 909522486 ^ i[r], a[r] = 1549556828 ^ i[r];
							return n = d(s.concat(h(t)), 512 + 8 * t.length), f(d(a.concat(n), 640))
						}(v(e), v(t))
					}

					function y(e, t, r) {
						return t ? r ? m(t, e) : g(m(t, e)) : r ? p(e) : g(p(e))
					}
					void 0 === (n = function() {
						return y
					}.call(t, r, t, e)) || (e.exports = n)
				}()
			},
			206: e => {
				"use strict";
				var t = {
						ANDROID_WEB: "android-web",
						IOS_WEB: "iOS-web",
						PC_NATIVE: "PC-native",
						PC_WEB: "PC-web"
					},
					r = {
						getNetType: function() {
							var e = (new RegExp("nettype\\/(\\w*)")
								.exec(n()) || [, ""])[1].toLowerCase();
							if (!e && navigator.connection) switch (navigator.connection.type) {
								case "ethernet":
									e = "ethernet";
									break;
								case "cellular":
									e = "cellular";
									break;
								default:
									e = "wifi"
							}
							return e
						},
						getPlatform: function() {
							return r.isAndroid() ? t.ANDROID_WEB : r.isIOS() ? t.IOS_WEB : r.isElectron() ? t.PC_NATIVE : t.PC_WEB
						},
						isX5: function() {
							return this.isAndroid() && /\s(TBS|X5Core)\/[\w\.\-]+/i.test(n())
						},
						isPC: function() {
							return !s(i("os ")) && !s(i("android[/ ]"))
						},
						isIOS: function() {
							return s(i("os "))
						},
						isAndroid: function() {
							return s(i("android[/ ]"))
						},
						isIOSSafari: function() {
							return this.isIOS() && this.isSafari()
						},
						isElectron: function() {
							return /electron/i.test(n())
						},
						isMobile: function() {
							return r.isAndroid() || r.isIOS()
						},
						isSafari: function() {
							return /^((?!chrome|android).)*safari/i.test(n())
						},
						isFirefox: function() {
							return /firefox/i.test(n())
						},
						isChrome: function() {
							return /chrome/i.test(n())
						},
						isLocalHost: function() {
							return "localhost" === location.hostname
						},
						device: t,
						getBrowser: function() {
							return r.isX5() ? "X5" : r.isChrome() ? "Chrome" : r.isFirefox() ? "Firefox" : r.isIOSSafari() ? "iOS-Safari" : r.isSafari() ? "Mac-Safari" : "Unknown"
						}
					};

				function n() {
					return navigator.userAgent.toLowerCase()
				}

				function i(e) {
					return "" + (new RegExp(e + "(\\d+((\\.|_)\\d+)*)")
						.exec(n()) || [, 0])[1] || void 0
				}

				function s(e) {
					return parseFloat((e || "")
						.replace(/\_/g, ".")) || 0
				}
				e.exports = r
			},
			497: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.default = function() {
					var e = void 0;
					for (var t in r)
						if (window[t]) {
							e = r[t];
							break
						} return e
				};
				var r = {
					DPlayer: "dplayer",
					CBPlayer: "cbplayer",
					jwplayer: "jwplayer",
					videojs: "videojs",
					Clappr: "clappr",
					ckplayer: "ckplayer",
					MediaElementPlayer: "mediaelement",
					MediaElement: "mediaelement",
					TcPlayer: "tcplayer",
					flowplayer: "flowplayer",
					Chimee: "chimee",
					ChimeePlayer: "chimee",
					HlsJsPlayer: "xgplayer",
					fluidPlayer: "fluidplayer",
					OpenPlayer: "openplayer",
					Plyr: "plyr",
					Playerjs: "playerjs",
					Aliplayer: "aliplayer",
					shaka: "shakaplayer"
				};
				e.exports = t.default
			},
			3: e => {
				"use strict";
				var t = void 0;
				e.exports = "function" == typeof queueMicrotask ? queueMicrotask.bind(globalThis) : function(e) {
					return (t || (t = Promise.resolve()))
						.then(e)
						.catch((function(e) {
							return setTimeout((function() {
								throw e
							}), 0)
						}))
				}
			},
			397: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var n = t[r];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
						}
					}
					return function(t, r, n) {
						return r && e(t.prototype, r), n && e(t, n), t
					}
				}();
				var n = function() {
					function e(t) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, e), this.startPoint = performance.now(), this.reqsSent = 0, this.reqsReceived = 0, this.peerManager = t
					}
					return r(e, [{
						key: "isSeed",
						value: function() {
							return !(performance.now() - this.startPoint < 6e4) && (this.peerManager.size() > 0 && 0 === this.reqsSent && this.reqsReceived > 0)
						}
					}, {
						key: "reset",
						value: function() {
							this.reqsSent = this.reqsReceived = 0
						}
					}, {
						key: "increReqsSent",
						value: function() {
							this.reqsSent++
						}
					}, {
						key: "increReqsReceived",
						value: function() {
							this.reqsReceived++
						}
					}]), e
				}();
				t.default = n, e.exports = t.default
			},
			156: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
						return typeof e
					} : function(e) {
						return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
					},
					n = t.setItem = function(e, t) {
						"object" === (void 0 === t ? "undefined" : r(t)) && (t = JSON.stringify(t)), localStorage.setItem(e, t)
					};
				t.hasItemUnexpired = function(e) {
					var t = localStorage.getItem(e);
					try {
						var r = JSON.parse(t);
						return !(!r.duration || !r.startTime) && (new Date)
							.getTime() - r.startTime < r.duration
					} catch (e) {
						return !1
					}
				}, t.getItem = function(e) {
					var t = localStorage.getItem(e);
					try {
						var r = JSON.parse(t);
						return r.value ? r.value : r
					} catch (e) {
						return t
					}
				}, t.removeItem = function(e) {
					localStorage.removeItem(e)
				}, t.removeAllItem = function() {
					localStorage.clear()
				}, t.setItemWithExpiration = function(e, t, r) {
					var i = {
						value: t,
						duration: r,
						startTime: (new Date)
							.getTime()
					};
					n(e, i)
				}
			},
			901: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.DEFAULT_PACKET_SIZE = void 0, t.noop = function() {
					return !0
				}, t.getQueryParam = function(e) {
					return new URL(location.href)
						.searchParams.get(e)
				}, t.updateQueryStringParam = function(e, t, r) {
					var n = new RegExp("([?&])" + t + "=.*?(&|$)", "i"),
						i = -1 !== e.indexOf("?") ? "&" : "?";
					return e.match(n) ? e.replace(n, "$1" + t + "=" + r + "$2") : e + i + t + "=" + r
				}, t.getCurrentTs = function() {
					return Date.parse(new Date) / 1e3
				}, t.randomNum = function(e, t) {
					return parseInt(Math.random() * (t - e + 1) + e, 10)
				}, t.calCheckPeersDelay = function(e) {
					return 0 === e ? 3 : .5 * e + 1.67
				}, t.performRangeRequest = function(e, t, r) {
					var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 3500,
						i = new XMLHttpRequest;
					return new Promise((function(s, a) {
							i.open("GET", e, !0), i.responseType = "arraybuffer", i.timeout = n, i.onreadystatechange = function(e) {
								if (4 === i.readyState) {
									var t = i.status;
									206 === t ? s(i.response) : a("status " + t)
								}
							}, i.onerror = function(e) {
								a("request error")
							}, i.ontimeout = function(e) {
								a("timeout")
							}, i.setRequestHeader("Range", t || "bytes=0-0"), r && r(i, e), i.send()
						}))
						.catch((function(e) {}))
				}, t.navLang = function() {
					return "zh-CN" === (navigator.language || navigator.userLanguage) ? "cn" : "en"
				}, t.dontWaitFor = function(e) {
					e.then((function() {}))
				}, t.timeout = function(e) {
					return new Promise((function(t) {
						return setTimeout(t, e)
					}))
				}, t.getBrowserRTC = function() {
					if ("undefined" == typeof window) return null;
					var e = {
						RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection,
						RTCSessionDescription: window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
						RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate
					};
					return e.RTCPeerConnection ? e : null
				}, t.copyBuffer = function(e) {
					var t = n.Buffer.from(e),
						r = new n.Buffer(e.byteLength);
					return t.copy(r), r
				}, t.getMaxSequence = function(e) {
					var t = e.split("\n"),
						r = 0,
						n = 0,
						i = !0,
						s = !1,
						a = void 0;
					try {
						for (var o, l = t[Symbol.iterator](); !(i = (o = l.next())
							.done); i = !0) {
							var u = o.value,
								c = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(u);
							if (c && c[1]) {
								r = parseInt(c[1], 10);
								break
							}
						}
					} catch (e) {
						s = !0, a = e
					} finally {
						try {
							!i && l.return && l.return()
						} finally {
							if (s) throw a
						}
					}
					var d = !0,
						f = !1,
						h = void 0;
					try {
						for (var g, v = t[Symbol.iterator](); !(d = (g = v.next())
							.done); d = !0) {
							g.value.startsWith("#EXTINF") && n++
						}
					} catch (e) {
						f = !0, h = e
					} finally {
						try {
							!d && v.return && v.return()
						} finally {
							if (f) throw h
						}
					}
					return r + n - 1
				}, t.isHttps = function() {
					return location.protocol.startsWith("https")
				}, t.isInteger = function(e) {
					return "number" == typeof e && e % 1 == 0
				}, t.getHomeUrl = function() {
					return window.atob("aHR0cHM6Ly9zd2FybWNsb3VkLm5ldC9lbi8=")
				}, t.splitBytes = function(e, t) {
					for (var r = e.byteLength - t, i = [], a = t, o = Math.floor(r / s), l = r % s, u = 0; u < o; u++) {
						var c = (0, n.Buffer)(s);
						e.copy(c, 0, a, a + s), i.push(c), a += s
					}
					if (l > 0) {
						var d = (0, n.Buffer)(l);
						e.copy(d, 0, a, a + l), i.push(d)
					}
					return i
				}, t.getAvailableMemory = function() {
					var e = performance.memory;
					return e ? e.jsHeapSizeLimit - e.usedJSHeapSize : -1
				}, t.trimMap = function(e, t) {
					if (e.size <= t) return;
					var r = [].concat(i(e.keys()));
					do {
						e.delete(r.shift())
					} while (e.size > t)
				}, t.trimSet = function(e, t) {
					if (e.size <= t) return;
					var r = [].concat(i(e.values()));
					do {
						e.delete(r.shift())
					} while (e.size > t)
				};
				var n = r(9);

				function i(e) {
					if (Array.isArray(e)) {
						for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
						return r
					}
					return Array.from(e)
				}
				var s = t.DEFAULT_PACKET_SIZE = 64e3
			},
			641: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = o(r(204)),
					s = o(r(760)),
					a = r(901);

				function o(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function l(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function u(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				var c = function(e) {
					function t(e, r, n, i) {
						var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "main";
						l(this, t);
						var a = u(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this));
						return a.logger = e, a.config = r, a.wsAddr = n, a.serverVersion = 0, a.pingInterval = i || 60, a._ws = a._init(), a.name = s, a
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "_init",
						value: function() {
							var e = this,
								t = {
									maxRetries: this.config.wsMaxRetries,
									minReconnectionDelay: (0, a.randomNum)(1e4, 6e4),
									maxReconnectionDelay: 6e5,
									maxEnqueuedMessages: 20
								},
								r = new s.default(this.wsAddr, void 0, t);
							return r.addEventListener("open", (function() {
								e.logger.info("signal " + e.name + " " + e.wsAddr + " connection opened"), e.onopen && e.onopen(), e._startPing(e.pingInterval)
							})), r.push = r.send, r.send = function(e) {
								var t = JSON.stringify(e);
								r.push(t)
							}, r.addEventListener("message", (function(t) {
								var r = t.data,
									n = JSON.parse(r),
									i = n.action;
								if ("pong" !== i) {
									if ("ver" !== i) return "close" === i ? (e.logger.warn("server close signal " + e.name + " reason " + n.reason), void e.close()) : void(e.onmessage && e.onmessage(n, e.name));
									e.serverVersion = n.ver
								} else clearTimeout(e.pongTimer)
							})), r.addEventListener("close", (function(t) {
								e.logger.warn("signal " + e.name + " " + e.wsAddr + " closed " + t.code + " " + t.reason), e.onclose && e.onclose(), e._stopPing()
							})), r.addEventListener("error", (function(t) {
								e.logger.error("signal " + e.name + " " + e.wsAddr + " error"), e._stopPing(), e.onerror && e.onerror(t)
							})), r
						}
					}, {
						key: "sendSignal",
						value: function(e, t) {
							var r = {
								action: "signal",
								to_peer_id: e,
								data: t
							};
							this._send(r)
						}
					}, {
						key: "sendReject",
						value: function(e, t, r) {
							var n = {
								action: "reject",
								to_peer_id: e,
								reason: t,
								fatal: r
							};
							this._send(n)
						}
					}, {
						key: "_send",
						value: function(e) {
							this._ws && this._ws.send(e)
						}
					}, {
						key: "_startPing",
						value: function() {
							var e = this,
								t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 120;
							this.connected && (this.pingTimer = setInterval((function() {
								e._send({
									action: "ping"
								}), e.serverVersion >= 22 && e._waitForPong()
							}), 1e3 * t))
						}
					}, {
						key: "_waitForPong",
						value: function() {
							var e = this;
							this.pongTimer = setTimeout((function() {
								e.logger.warn("signal " + e.name + " wait for pong timeout, reconnect"), e.close(), e.reconnect()
							}), 15e3)
						}
					}, {
						key: "_resetPing",
						value: function() {
							this._stopPing(), this._startPing(this.pingInterval)
						}
					}, {
						key: "_stopPing",
						value: function() {
							clearInterval(this.pingTimer), clearTimeout(this.pongTimer), this.pingTimer = null, this.pongTimer = null
						}
					}, {
						key: "close",
						value: function() {
							var e = this;
							this.logger.info("close signal " + this.name), this._stopPing(), e._ws && e._ws.close(1e3, "normal close")
						}
					}, {
						key: "reconnect",
						value: function() {
							this._ws && (this.logger.info("reconnect signal " + this.name), this._ws.reconnect())
						}
					}, {
						key: "destroy",
						value: function() {
							this.close(), this._ws = null, this.removeAllListeners()
						}
					}, {
						key: "connected",
						get: function() {
							return !!this._ws && this._ws.readyState === s.default.OPEN
						}
					}]), t
				}(i.default);
				t.default = c, e.exports = t.default
			},
			980: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n, i = Object.assign || function(e) {
						for (var t = 1; t < arguments.length; t++) {
							var r = arguments[t];
							for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
						}
						return e
					},
					s = r(304);
				var a = i({}, ((n = s) && n.__esModule ? n : {
						default: n
					})
					.default, {
						p2pBlackList: ["aac", "mp3", "vtt", "webvtt", "key"],
						scheduledBySegId: !1,
						simultaneousTargetPeers: 2,
						maxSubscribeLevel: 3,
						live: !0,
						waitForPeer: !1,
						waitForPeerTimeout: 4.5,
						httpLoadTime: 2,
						sharePlaylist: !1,
						useHttpRange: !0
					});
				a.validateSegment = function(e, t) {
					return !0
				}, t.default = a, e.exports = t.default
			},
			227: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n, i = Object.assign || function(e) {
						for (var t = 1; t < arguments.length; t++) {
							var r = arguments[t];
							for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
						}
						return e
					},
					s = r(784),
					a = (n = s) && n.__esModule ? n : {
						default: n
					};
				t.default = i({}, a.default, {
					SCH_DCHAVE: "SCH_DCHAVE",
					DC_SUBSCRIBE: "SUBSCRIBE",
					DC_UNSUBSCRIBE: "UNSUBSCRIBE",
					DC_SUBSCRIBE_ACCEPT: "SUBSCRIBE_ACCEPT",
					DC_SUBSCRIBE_REJECT: "SUBSCRIBE_REJECT",
					DC_SUBSCRIBE_LEVEL: "SUBSCRIBE_LEVEL"
				}), e.exports = t.default
			},
			982: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = d(r(204)),
					s = r(57),
					a = d(r(893)),
					o = d(r(659)),
					l = d(r(3)),
					u = d(r(227)),
					c = r(901);

				function d(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}
				var f = function(e) {
					function t(e) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var r = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this));
						r.logger = e.logger;
						var n = window.__p2p_loader__,
							i = n.scheduler,
							a = n.fetcher,
							l = n.p2pBlackList,
							u = n.isHlsV0;
						return r.isHlsV0 = u, r.bufMgr = e.bufMgr, r.xhrLoader = new e.loader(e), r.p2pEnabled = e.p2pEnabled, r.isLive = e.live, r.scheduler = i, r.fetcher = a, r.segmentId = e.segmentId, r.blockTypes = l, r.forbidden = a.forbidden, r.multiBitrate = r.scheduler instanceof o.default, r.stats = r.xhrLoader.stats || (0, s.createLoadStats)(), r.waitTimer = null, r
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "destroy",
						value: function() {
							this.xhrLoader.destroy()
						}
					}, {
						key: "abort",
						value: function() {
							this.xhrLoader.abort()
						}
					}, {
						key: "load",
						value: function(e, t, r) {
							var n = this,
								i = this.logger,
								a = this.scheduler,
								o = e.frag;
							this.isHlsV0 || (o.stats = this.stats);
							var d = e.frag.segId;
							if (!d) {
								var f = void 0;
								e.rangeEnd && (f = "bytes=" + e.rangeStart + "-" + (e.rangeEnd - 1)), d = e.frag.segId = this.segmentId(String(o.level), o.sn, o.url, f)
							}
							if (!o.url || (0, s.isBlockType)(o.url, this.blockTypes)) return i.info("HTTP load blockType " + o.url), e.frag.loadByHTTP = !0, this.xhrLoader.load(e, t, r);
							if (!this.forbidden)
								if (this.fetcher.increMediaRequests(), t.maxRetry = 2, this.p2pEnabled && this.bufMgr.hasSegOfId(d)) {
									i.info("bufMgr found seg sn " + o.sn + " segId " + d);
									var h = this.bufMgr.getSegById(d),
										g = (0, c.copyBuffer)(h.data),
										v = new Uint8Array(g)
										.buffer,
										p = {
											url: e.url,
											data: v
										};
									(0, s.updateLoadStats)(this.stats, h.size), o.loaded = h.size, o.loadByP2P = !0, e.frag.fromPeerId = h.fromPeerId, (0, l.default)((function() {
										!n.isHlsV0 && r.onProgress && r.onProgress(n.stats, e, p.data), r.onSuccess(p, n.stats, e)
									}))
								} else if (this.p2pEnabled && a.hasAndSetTargetPeer(this.multiBitrate ? o.segId : o.sn)) this.loadFragByP2p(e, t, r, d);
							else {
								var m = a.mBufferedDuration;
								if (i.info("fragLoader load " + d + " at " + o.sn + " level " + o.level + " buffered " + m), this.isLive && a.hasIdlePeers && m > 6.5 && a.shouldWaitForNextSeg()) {
									var y = m - 6.5;
									y > 5.5 && (y = 5.5);
									var b = function i(s) {
										d === s && (a.off(u.default.SCH_DCHAVE, i), clearTimeout(n.waitTimer), a.hasAndSetTargetPeer(n.multiBitrate ? o.segId : o.sn) ? n.loadFragByP2p(e, t, r, d) : n.loadFragByHttp(e, t, r, d))
									};
									i.info("wait peer have for " + y + "s"), a.on(u.default.SCH_DCHAVE, b), this.waitTimer = setTimeout((function() {
										a.notifyAllPeers(o.sn, d), n.loadFragByHttp(e, t, r, d), a.off(u.default.SCH_DCHAVE, b)
									}), 1e3 * y)
								} else this.loadFragByHttp(e, t, r, d)
							}
						}
					}, {
						key: "loadFragByHttp",
						value: function(e, t, r, n) {
							var i = this;
							this.scheduler.isReceiver = !1;
							var s = this.logger,
								o = e.frag;
							if (this.isHlsV0) {
								var l = r.onSuccess;
								r.onSuccess = function(e, t, r) {
									if (!i.bufMgr.hasSegOfId(n)) {
										var u = (0, c.copyBuffer)(e.data),
											d = new a.default(o.sn, n, u, i.fetcher.peerId);
										i.bufMgr.putSeg(d)
									}
									i.fetcher.reportFlow(t.total);
									var f = t.tload - t.trequest;
									s.info("HTTP loaded " + n + " time " + f + "ms"), l(e, t, r)
								}
							} else if (r.onProgress) {
								var u = r.onProgress;
								r.onProgress = function(e, t, r) {
									if (!i.bufMgr.hasSegOfId(n)) {
										var l = (0, c.copyBuffer)(r),
											d = new a.default(o.sn, n, l, i.fetcher.peerId);
										i.bufMgr.putSeg(d)
									}
									i.fetcher.reportFlow(e.total), o.loaded = e.total;
									var f = e.loading.end - e.loading.start;
									s.info("HTTP loaded " + n + " time " + f + "ms"), u(e, t, r)
								}
							}
							e.frag.loadByHTTP = !0, this.xhrLoader.load(e, t, r)
						}
					}, {
						key: "loadFragByP2p",
						value: function(e, t, r, n) {
							var i = this,
								s = this.logger,
								o = e.frag;
							this.scheduler.load(e, t, r);
							var l = r.onSuccess,
								u = r.onTimeout;
							r.onTimeout = function(e, a) {
								s.warn("P2P timeout switched to HTTP load " + o.relurl + " at " + o.sn), r.onSuccess = l, i.loadFragByHttp(a, t, r, n), r.onTimeout = u
							}, r.onSuccess = function(e, t, u) {
								if (!i.bufMgr.hasSegOfId(n)) {
									var d = (0, c.copyBuffer)(e.data),
										f = new a.default(o.sn, n, d, o.fromPeerId || i.fetcher.peerId);
									i.bufMgr.putSeg(f)
								}
								o.loadByP2P || i.fetcher.reportFlow(t.total), o.loaded = t.loaded, s.info((o.loadByP2P ? "P2P" : "HTTP") + " loaded segment id " + n), !i.isHlsV0 && r.onProgress && r.onProgress(t, u, e.data), l(e, t, u)
							}
						}
					}]), t
				}(i.default);
				t.default = f, e.exports = t.default
			},
			659: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = function e(t, r, n) {
						null === t && (t = Function.prototype);
						var i = Object.getOwnPropertyDescriptor(t, r);
						if (void 0 === i) {
							var s = Object.getPrototypeOf(t);
							return null === s ? void 0 : e(s, r, n)
						}
						if ("value" in i) return i.value;
						var a = i.get;
						return void 0 !== a ? a.call(n) : void 0
					},
					s = c(r(893)),
					a = c(r(227)),
					o = c(r(381)),
					l = r(57),
					u = r(901);

				function c(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function d(e) {
					if (Array.isArray(e)) {
						for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
						return r
					}
					return Array.from(e)
				}
				var f = function(e) {
					function t(e, r) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var n = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this, e, r));
						return n.logger.info("use IdScheduler"), n.sequential = !1, n
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "load",
						value: function(e, t, r) {
							this.isReceiver = !0;
							var n = this.logger;
							this.context = e;
							var i = e.frag,
								s = i.segId,
								a = i.sn;
							this.callbacks = r, this.stats = (0, l.createLoadStats)(), this.criticalSeg = {
								sn: a,
								segId: s,
								targetPeers: [].concat(d(this.targetPeers.map((function(e) {
									return e.remotePeerId
								}))))
							};
							var o = this.mBufferedDuration - this.config.httpLoadTime;
							o > this.dcDownloadTimeout && (o = this.dcDownloadTimeout);
							var u = !0,
								c = !1,
								f = void 0;
							try {
								for (var h, g = this.targetPeers[Symbol.iterator](); !(u = (h = g.next())
									.done); u = !0) {
									var v = h.value;
									v.downloading || (n.info("request criticalSeg segId " + s + " at " + a + " from " + v.remotePeerId + " timeout " + o), v.requestDataById(s, a, !0)), this.requestingMap.set(s, v.remotePeerId)
								}
							} catch (e) {
								c = !0, f = e
							} finally {
								try {
									!u && g.return && g.return()
								} finally {
									if (c) throw f
								}
							}
							this.criticaltimeouter = setTimeout(this.criticaltimeout.bind(this, !0), 1e3 * o), this.targetPeers = []
						}
					}, {
						key: "onBufferManagerLost",
						value: function(e, t, r) {
							this.bitset.delete(t), this.bitCounts.delete(t)
						}
					}, {
						key: "destroy",
						value: function() {
							i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "destroy", this)
								.call(this), this.logger.warn("destroy IdScheduler")
						}
					}, {
						key: "_setupDC",
						value: function(e) {
							var r = this;
							i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "_setupDC", this)
								.call(this, e);
							var n = this.logger,
								o = this.config;
							e.on(a.default.DC_HAVE, (function(t) {
									if (t.seg_id && e.bitset) {
										var n = t.seg_id;
										e.bitset.has(n) || (e.bitset.add(n), r.bitset.has(n) || r._increBitCounts(n)), o.live && (0, u.trimSet)(e.bitset, 20), r.emit(a.default.SCH_DCHAVE, t.seg_id)
									}
								}))
								.on(a.default.DC_LOST, (function(t) {
									if (t.seg_id && e.bitset) {
										var n = t.seg_id;
										e.bitset.has(n) && (e.bitset.delete(n), r._decreBitCounts(n))
									}
								}))
								.on(a.default.DC_PIECE, (function(e) {
									e.ext && e.ext.incompletes >= 2 || r.notifyAllPeers(e.sn, e.seg_id)
								}))
								.on(a.default.DC_PIECE_NOT_FOUND, (function(t) {
									var i = t.seg_id;
									r.criticalSeg && r.criticalSeg.segId === i && (1 === r.criticalSeg.targetPeers.length ? (clearTimeout(r.criticaltimeouter), n.info("DC_PIECE_NOT_FOUND"), r.criticalSeg = null, r.callbacks.onTimeout(r.stats, r.context, null)) : r.criticalSeg.targetPeers = r.criticalSeg.targetPeers.filter((function(t) {
										return t !== e.remotePeerId
									}))), e.bitset.delete(i), r.requestingMap.delete(i), r._decreBitCounts(i), e.checkIfNeedChoke(!0)
								}))
								.on(a.default.DC_RESPONSE, (function(a, o) {
									var l = a.segId,
										u = a.sn,
										c = a.data,
										d = r.criticalSeg && r.criticalSeg.segId === l;
									if (r.config.validateSegment(l, c))
										if (r.notifyAllPeers(u, l), i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "reportDCTraffic", r)
											.call(r, l, a.size, o), d) {
											n.info("receive criticalSeg seg_id " + l), clearTimeout(r.criticaltimeouter), r.criticaltimeouter = null, e.miss = 0;
											var f = r.stats;
											f.tfirst = f.loading.first = Math.max(f.trequest, performance.now()), f.tload = f.loading.end = f.tfirst, f.loaded = f.total = c.byteLength, r.criticalSeg = null;
											var h = r.context.frag;
											h.fromPeerId = e.remotePeerId, h.loadByP2P = !0, r.callbacks.onSuccess({
												data: c
											}, f, r.context)
										} else {
											if (r.bitset.has(l)) return;
											var g = new s.default(u, l, c, e.remotePeerId);
											r.bufMgr.putSeg(g), r.updateLoaded(l)
										}
									else n.warn("segment " + l + " validate failed"), d && (clearTimeout(r.criticaltimeouter), r.criticaltimeout());
									r.requestingMap.delete(l)
								}))
								.on(a.default.DC_REQUEST, (function(t) {
									r.isUploader = !0;
									var i = t.seg_id,
										s = null;
									if (r.requestingMap.has(i) && (s = r.getPeerLoadedMore(i)), r.bufMgr.hasSegOfId(i)) {
										n.info("found seg from bufMgr");
										var o = r.bufMgr.getSegById(i);
										e.sendBuffer(o.sn, o.segId, o.data)
									} else s && s.downloading && s.pieceMsg.seg_id === i ? (n.info("target had partial buffer, wait for remain"), e.sendPartialBuffer(s.pieceMsg, s.bufArr, {
										from: "WaitForPartial",
										incompletes: 1
									}), function(t, r) {
										t.addStreamListener(!1, r.remotePeerId, (function(t, n, i, s, a) {
											i ? r.sendMsgPieceAbort(s) : r.send(s), a && (e.uploading = !1)
										}))
									}(s, e)) : (n.info("peer request " + i + " wait for seg"), r.bufMgr.once("" + a.default.BM_ADDED_SEG_ + i, (function(r) {
										r ? (n.info("peer request notify seg " + i), e.sendBuffer(r.sn, r.segId, r.data)) : e.sendPieceNotFound(t.sn, i)
									})))
								}))
						}
					}, {
						key: "_setupEngine",
						value: function() {
							var e = this;
							this.engine.on(a.default.FRAG_LOADING, (function(t, r, n) {
									e.loadingSegId = r, e.isHlsV0 && n && e.notifyAllPeers(t, r)
								}))
								.on(a.default.FRAG_LOADED, (function(t, r, n, i, s) {
									r && (!e.isHlsV0 && s && e.notifyAllPeers(t, r), e.updateLoaded(r))
								}))
						}
					}]), t
				}(o.default);
				t.default = f, e.exports = t.default
			},
			381: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = function e(t, r, n) {
						null === t && (t = Function.prototype);
						var i = Object.getOwnPropertyDescriptor(t, r);
						if (void 0 === i) {
							var s = Object.getPrototypeOf(t);
							return null === s ? void 0 : e(s, r, n)
						}
						if ("value" in i) return i.value;
						var a = i.get;
						return void 0 !== a ? a.call(n) : void 0
					},
					s = u(r(673)),
					a = u(r(227)),
					o = r(901),
					l = r(9);

				function u(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}
				var c = function(e) {
					function t(e, r) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var n = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this, e, r));
						return n.targetPeers = [], n.mBufferedDuration = 0, n.loadingSegId = "", n.allowP2pLimit = r.httpLoadTime + 2, n.playlistInfo = new Map, n.subscribeMode = !1, n.subscribeLevel = 0, n.subscribers = [], n.subscribeParent = null, n.subscriberEdgeSN = 0, n.isUploader = !1, n.isReceiver = !1, n.isHlsV0 = r.isHlsV0, n
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "hasAndSetTargetPeer",
						value: function(e) {
							var t = this.logger,
								r = this.config;
							if (this.criticalSeg && t.warn("scheduler still loading " + JSON.stringify(this.criticalSeg)), this.waitForPeer) {
								if (this.peersHas(e)) {
									var n = !0,
										i = !1,
										s = void 0;
									try {
										for (var a, o = this.peerManager.getAvailablePeers()[Symbol.iterator](); !(n = (a = o.next())
											.done); n = !0) {
											var l = a.value;
											if (l.bitset.has(e)) return t.info("found " + e + " from peer " + l.remotePeerId), this.targetPeers.push(l), !0
										}
									} catch (e) {
										i = !0, s = e
									} finally {
										try {
											!n && o.return && o.return()
										} finally {
											if (i) throw s
										}
									}
								}
								return 0 !== this.waitingPeers && this.waitingPeers === this.peersNum ? (t.info("all connected no need wait"), !1) : (t.warn("wait for peer to load " + e), this.requestingMap.setPeerUnknown(e), !0)
							}
							var u = this.bufferedDuration;
							if (this.subscribeMode) {
								var c = this.subscribeParent,
									d = c.remotePeerId;
								return c.bitset.has(e) ? c.downloading ? this._searchAvailablePeers(e) : (t.info("found " + e + " from parent " + d), this.targetPeers.push(this.subscribeParent), !0) : !(u <= 3.5) && (t.info("under subscribe to " + d), this.requestingMap.set(e, d), !0)
							}
							if (u <= this.allowP2pLimit) return !1;
							if (this.requestingMap.has(e)) {
								var f = this.requestingMap.getOnePeerId(e),
									h = this.peerManager.getPeer(f);
								return h ? !(performance.now() - h.timeSendRequest > 3e3 && !h.shouldWaitForRemain(1e3 * (u - r.httpLoadTime))) || !!this._searchAvailablePeers(e, 1) && (t.warn(f + " prefetch timeout at " + e), this.targetPeers.push(h), this.requestingMap.delete(e), !0) : this._searchAvailablePeers(e)
							}
							return this._searchAvailablePeers(e)
						}
					}, {
						key: "_searchAvailablePeers",
						value: function(e) {
							var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5;
							if (!this.hasIdlePeers || !this.peersHas(e)) return !1;
							var r = 0,
								n = !0,
								i = !1,
								s = void 0;
							try {
								for (var a, o = this.peerManager.getPeersOrderByWeight()[Symbol.iterator](); !(n = (a = o.next())
									.done); n = !0) {
									var l = a.value;
									if (l.bitset.has(e) && (this.logger.info("found " + e + " from peer " + l.remotePeerId), this.targetPeers.push(l), ++r === t || r === this.config.simultaneousTargetPeers)) return !0
								}
							} catch (e) {
								i = !0, s = e
							} finally {
								try {
									!n && o.return && o.return()
								} finally {
									if (i) throw s
								}
							}
							return this.targetPeers.length > 0
						}
					}, {
						key: "notifyAllPeers",
						value: function(e, t) {
							var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
								n = this.config.live,
								i = t;
							if (this.sequential && (i = e), !this.bitset.has(i)) {
								var s = !0,
									a = !1,
									l = void 0;
								try {
									for (var u, c = this.peerManager.getPeerValues()[Symbol.iterator](); !(s = (u = c.next())
										.done); s = !0) {
										var d = u.value;
										if (!d.notifySet.has(i) && !d.bitset.has(i)) {
											if (n && (this.subscribers.includes(d.remotePeerId) || this.subscribeParent && d.remotePeerId === this.subscribeParent.remotePeerId)) continue;
											if (!r.includes(d.remotePeerId) && (d.sendMsgHave(e, t), d.notifySet.add(i), n)) {
												var f = 20;
												if (this.sequential) {
													var h = e - f;
													h > 0 && d.notifySet.delete(h)
												} else(0, o.trimSet)(d.notifySet, f)
											}
										}
									}
								} catch (e) {
									a = !0, l = e
								} finally {
									try {
										!s && c.return && c.return()
									} finally {
										if (a) throw l
									}
								}
							}
						}
					}, {
						key: "updateLoaded",
						value: function(e) {
							this.bitset.has(e) || (this.bitset.add(e), this.bitCounts.has(e) && this.bitCounts.delete(e))
						}
					}, {
						key: "deletePeer",
						value: function(e) {
							var r = this;
							this.peerManager.hasPeer(e.remotePeerId) && e.bitset.forEach((function(e) {
									r._decreBitCounts(e)
								})), this.cleanRequestingMap(e.remotePeerId), i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "deletePeer", this)
								.call(this, e)
						}
					}, {
						key: "_setupDC",
						value: function(e) {
							var r = this;
							i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "_setupDC", this)
								.call(this, e);
							this.logger;
							e.on(a.default.DC_PIECE, (function(e) {
									r.criticalSeg && r.criticalSeg.segId === e.seg_id && (r.stats.tfirst = Math.max(performance.now(), r.stats.trequest))
								}))
								.on(a.default.DC_PIECE_DATA, (function(t, n, i, s, a) {
									1 === s && e.pieceMsg.ext && e.pieceMsg.ext.incompletes >= 2 && r.notifyAllPeers(t, n)
								}))
						}
					}, {
						key: "loadRemainBufferByHttp",
						value: function(e, r) {
							var n = this,
								s = this.context.frag.url,
								a = this.config.xhrSetup,
								u = l.Buffer.concat(e.bufArr);
							i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "reportDCTraffic", this)
								.call(this, r, u.byteLength, 0);
							var c = "bytes=";
							if (this.context.rangeEnd) {
								var d = Number(this.context.rangeStart),
									f = Number(this.context.rangeEnd);
								c = "" + c + (d + u.byteLength) + "-" + (f - 1)
							} else c = "" + c + u.byteLength + "-";
							this.logger.info("continue download from " + s + " range: " + c), (0, o.performRangeRequest)(s, c, a)
								.then((function(t) {
									var r = l.Buffer.from(t);
									n.engine.fetcher.reportFlow(r.byteLength);
									var i = l.Buffer.concat([u, r]),
										s = new Uint8Array(i)
										.buffer,
										a = n.stats;
									a.tfirst = a.loading.first = Math.max(a.trequest, performance.now()), a.tload = a.loading.end = a.tfirst, a.loaded = a.total = i.byteLength;
									var o = n.context.frag;
									o.fromPeerId = e.remotePeerId, o.loadByP2P = !0, n.callbacks.onSuccess({
										data: s
									}, a, n.context)
								}))
								.catch((function(e) {
									n.logger.error("http partial download error " + e), n.callbacks.onTimeout(n.stats, n.context, null)
								}))
						}
					}, {
						key: "broadcastPlaylist",
						value: function(e, t) {
							if (this.config.live) {
								var r = (0, o.getMaxSequence)(t),
									n = !0,
									i = !1,
									s = void 0;
								try {
									for (var a, l = this.peerManager.getPeerValues()[Symbol.iterator](); !(n = (a = l.next())
										.done); n = !0) {
										a.value.sendMsgPlaylist(e, t, r)
									}
								} catch (e) {
									i = !0, s = e
								} finally {
									try {
										!n && l.return && l.return()
									} finally {
										if (i) throw s
									}
								}
								this.playlistInfo.set(e, {
									seq: r
								})
							}
						}
					}, {
						key: "getPlaylistFromPeer",
						value: function(e) {
							if (!this.config.live) return null;
							var t = this.playlistInfo.get(e)
								.seq,
								r = !0,
								n = !1,
								i = void 0;
							try {
								for (var s, a = this.peerManager.getPeerValues()[Symbol.iterator](); !(r = (s = a.next())
									.done); r = !0) {
									var o = s.value.getLatestPlaylist(e, t);
									if (o) return o
								}
							} catch (e) {
								n = !0, i = e
							} finally {
								try {
									!r && a.return && a.return()
								} finally {
									if (n) throw i
								}
							}
							return null
						}
					}, {
						key: "_handlePieceAborted",
						value: function(e) {
							this.criticalSeg && this.criticalSeg.targetPeers.includes(e) ? 1 === this.criticalSeg.targetPeers.length ? (clearTimeout(this.criticaltimeouter), this.criticaltimeout(), this.cleanRequestingMap(e)) : this.criticalSeg.targetPeers = this.criticalSeg.targetPeers.filter((function(t) {
								return t !== e
							})) : this.cleanRequestingMap(e)
						}
					}, {
						key: "criticaltimeout",
						value: function() {
							var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
								t = this.logger,
								r = this.config;
							if (this.waitForPeer && (this.waitForPeer = !1), this.criticalSeg) {
								var n = this.criticalSeg.sn,
									i = this.criticalSeg.segId;
								this.sequential && (i = n), t.info("critical request sn " + i + " timeout");
								var s = void 0;
								this.subscribeMode ? s = this.subscribeParent : this.requestingMap.has(i) && (s = this.getPeerLoadedMore(i));
								var a = !1;
								if (s && (a = !s.loadtimeout()), a) t.info("p2p download completed");
								else {
									var o = 1e3 * r.httpLoadTime - 500;
									if (e && s && s.shouldWaitForRemain(o)) return t.info("wait for peer load remain of " + n), void(this.criticaltimeouter = setTimeout(this.criticaltimeout.bind(this), o + 200));
									r.httpRangeSupported && s && s.bufArr.length > 0 && s.segId === this.criticalSeg.segId ? this.loadRemainBufferByHttp(s, i) : this.callbacks.onTimeout(this.stats, this.context, null), this.requestingMap.delete(i), r.live && s && s.resetContinuousHits(), this.subscribeParent && this._unsubscribe("subscribe timeout for " + n), this.criticalSeg = null, this.criticaltimeouter = null
								}
							}
						}
					}, {
						key: "shouldWaitForNextSeg",
						value: function() {
							var e = void 0;
							return e = !(this.subscribers.length > 0 || this.isUploader) && (!!this.isReceiver || (0, o.randomNum)(0, 100) > 20), this.isReceiver = this.isUploader = !1, e
						}
					}, {
						key: "getStatsForPeer",
						value: function() {
							var e = this.subscribers,
								t = e.length > 0 ? e.length : void 0,
								r = this.engine.currentLevel,
								n = this.engine.media.currentTime;
							return {
								children: t,
								pos: this.config.live ? void 0 : Math.round(n),
								level: r
							}
						}
					}, {
						key: "bufferedDuration",
						get: function() {
							for (var e = this.engine.media, t = 0, r = e.currentTime, n = e.buffered, i = n.length - 1; i >= 0; i--)
								if (r >= n.start(i) && r <= n.end(i)) {
									t = n.end(i) - r;
									break
								} return this.logger.info("bufferedDuration " + t), this.mBufferedDuration = t, t > 0 ? t : 0
						}
					}]), t
				}(s.default);
				t.default = c, e.exports = t.default
			},
			373: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = function e(t, r, n) {
						null === t && (t = Function.prototype);
						var i = Object.getOwnPropertyDescriptor(t, r);
						if (void 0 === i) {
							var s = Object.getPrototypeOf(t);
							return null === s ? void 0 : e(s, r, n)
						}
						if ("value" in i) return i.value;
						var a = i.get;
						return void 0 !== a ? a.call(n) : void 0
					},
					s = d(r(893)),
					a = d(r(227)),
					o = d(r(381)),
					l = d(r(427)),
					u = r(57),
					c = d(r(3));

				function d(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function f(e) {
					if (Array.isArray(e)) {
						for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
						return r
					}
					return Array.from(e)
				}
				var h = function(e) {
					function t(e, r) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var n = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this, e, r));
						return n.logger.info("use SnScheduler"), n.sequential = !0, n.currPlaySN = 0, n.currLostSN = -1, n.nextLostSN = -1, n.config.live ? n.maxPrefetchCount = 3 : (n.maxPrefetchCount = 150, n.startCheckPeersTimer()), n.waitForPeer = r.waitForPeer || !1, n.waitingPeers = 0, n.waitForPeer && (n.waitForPeerTimer = setTimeout((function() {
							n.waitForPeer = !1
						}), 1e3 * (r.waitForPeerTimeout + 2))), n.estimatedSize = 1e6, n
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "notifySubscribeLevel",
						value: function() {
							var e = this;
							this.subscribers.forEach((function(t) {
								var r = e.peerManager.getPeer(t);
								r && r.sendSubscribeLevel(e.subscribeLevel)
							}))
						}
					}, {
						key: "updatePlaySN",
						value: function(e) {
							this.currPlaySN = e
						}
					}, {
						key: "checkPeers",
						value: function() {
							var e = this.logger,
								t = this.config,
								r = t.live;
							if (!this.waitForPeer && 0 !== this.bitCounts.size && !(!r && this.nextLostSN >= 0 && this.nextLostSN >= this.currPlaySN - 10) && this.hasPeers)
								if (this.mBufferedDuration < this.allowP2pLimit) e.info("low buffer time, skip prefetch");
								else {
									var n = this.peerManager.getPeersOrderByWeight();
									if (0 !== n.length) {
										var i = [],
											s = t.prefetchNum,
											a = t.endSN,
											o = t.startSN;
										r && (s = 1);
										var l = 0,
											u = r ? this.loadingSN + 1 : this.loadingSN + 2;
										if (!r)
											if (this.loadingSN >= a && !this.bufMgr.overflowed) u = o;
											else {
												var c = Math.min.apply(Math, f(n.filter((function(e) {
														return e.endSN >= u
													}))
													.map((function(e) {
														return e ? e.startSN : 1 / 0
													}))));
												if (!isFinite(c)) return;
												u < c && (u = c)
											} for (; i.length < s && i.length < n.length && l < this.maxPrefetchCount;) {
											if (!r && u > a) return;
											if (this.bitset.has(u)) u++;
											else {
												if (u !== this.loadingSN && this.bitCounts.has(u) && !this.requestingMap.has(u)) {
													var d = !0,
														h = !1,
														g = void 0;
													try {
														for (var v, p = n[Symbol.iterator](); !(d = (v = p.next())
															.done); d = !0) {
															var m = v.value;
															if (!i.includes(m) && m.bitset.has(u)) {
																m.requestDataBySN(u, !1), e.info("request prefetch " + u + " from peer " + m.remotePeerId + " downloadNum " + m.downloadNum), i.push(m), this.requestingMap.set(u, m.remotePeerId);
																break
															}
														}
													} catch (e) {
														h = !0, g = e
													} finally {
														try {
															!d && p.return && p.return()
														} finally {
															if (h) throw g
														}
													}
												}
												l++, u++
											}
										}
										this.loadedPeerNum = i.length
									}
								}
						}
					}, {
						key: "addPeer",
						value: function(e) {
							if (i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "addPeer", this)
								.call(this, e), this.waitForPeer && this.criticalSeg) {
								var r = this.criticalSeg.segId,
									n = this.criticalSeg.sn,
									s = e.remotePeerId,
									a = this.requestingMap;
								a.checkIfPeerUnknown(n) && (e.bitset.has(n) ? (this.logger.info("found initial seg " + n + " from peer " + s), a.set(n, s), e.requestDataById(r, n, !0)) : this.waitingPeers === this.peersNum && this.criticaltimeout())
							}
						}
					}, {
						key: "deletePeer",
						value: function(e) {
							if (i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "deletePeer", this)
								.call(this, e), this.subscribeMode && e.remotePeerId === this.subscribeParent.remotePeerId) {
								var r = "subscribe parent is leaved";
								this.logger.warn(r), this._unsubscribe(r), this.criticaltimeout()
							}
						}
					}, {
						key: "load",
						value: function(e, t, r) {
							this.isReceiver = !0;
							var n = this.logger,
								i = this.config;
							this.context = e;
							var s = e.frag,
								a = s.segId,
								o = s.sn;
							this.callbacks = r, this.stats = (0, u.createLoadStats)(), this.criticalSeg = {
								sn: o,
								segId: a
							}, this.targetPeers.length > 0 ? this.criticalSeg.targetPeers = [].concat(f(this.targetPeers.map((function(e) {
								return e.remotePeerId
							})))) : this.criticalSeg.targetPeers = [].concat(f(this.requestingMap.getAllPeerIds(o)));
							var l = this.mBufferedDuration - i.httpLoadTime;
							if (this.waitForPeer ? l = i.waitForPeerTimeout : l > this.dcDownloadTimeout && (l = this.dcDownloadTimeout), this.requestingMap.has(o)) n.info("wait for criticalSeg segId " + a + " at " + o + " timeout " + l);
							else {
								var c = !0,
									d = !1,
									h = void 0;
								try {
									for (var g, v = this.targetPeers[Symbol.iterator](); !(c = (g = v.next())
										.done); c = !0) {
										var p = g.value;
										p.downloading || (n.info("request criticalSeg segId " + a + " at " + o + " from " + p.remotePeerId + " timeout " + l), p.requestDataById(a, o, !0)), this.requestingMap.set(o, p.remotePeerId)
									}
								} catch (e) {
									d = !0, h = e
								} finally {
									try {
										!c && v.return && v.return()
									} finally {
										if (d) throw h
									}
								}
							}
							this.criticaltimeouter = setTimeout(this.criticaltimeout.bind(this, !0), 1e3 * l), this.targetPeers = []
						}
					}, {
						key: "onBufferManagerSegAdded",
						value: function(e) {
							this._sendSegmentToSubscribers(e)
						}
					}, {
						key: "onBufferManagerLost",
						value: function(e, t, r) {
							this.currLostSN = e, r && (this.nextLostSN = r), this.bitset.delete(e), this.bitCounts.delete(e)
						}
					}, {
						key: "destroy",
						value: function() {
							i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "destroy", this)
								.call(this), clearTimeout(this.waitForPeerTimer), this.logger.warn("destroy SnScheduler")
						}
					}, {
						key: "_setupDC",
						value: function(e) {
							var r = this;
							i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "_setupDC", this)
								.call(this, e);
							var n = this.logger,
								o = this.config;
							e.on(a.default.DC_HAVE, (function(t) {
									if (t.sn && e.bitset && t.sn && t.sn >= 0) {
										var n = t.sn;
										if (e.bitset.has(n) || (e.bitset.add(n), r.bitset.has(n) || r._increBitCounts(n)), o.live) {
											var i = n - 20;
											i > 0 && e.bitset.delete(i)
										}
										r.emit(a.default.SCH_DCHAVE, t.seg_id), (0, c.default)((function() {
											!o.live || r.criticalSeg || r.subscribeMode || r.checkPeers()
										}))
									}
								}))
								.on(a.default.DC_LOST, (function(t) {
									if (t.sn && e.bitset) {
										var n = t.sn;
										e.bitset.has(n) && (e.bitset.delete(n), r._decreBitCounts(n))
									}
								}))
								.on(a.default.DC_PIECE, (function(t) {
									r.subscribers.length > 0 && t.sn > r.subscriberEdgeSN && (r._sendPieceToSubscribers(t.sn, t.seg_id, !1, !1, t), e.addStreamListener(!1, void 0, (function(e, t, n, i, s) {
										n ? r._sendPieceToSubscribers(e, t, !1, !0, i) : r._sendPieceToSubscribers(e, t, !0, !1, i, s)
									})), r.subscriberEdgeSN = t.sn), t.ext && t.ext.incompletes >= 2 || r.notifyAllPeers(t.sn, t.seg_id)
								}))
								.on(a.default.DC_PIECE_NOT_FOUND, (function(t) {
									var i = t.sn;
									r.criticalSeg && r.criticalSeg.sn === i && (1 === r.criticalSeg.targetPeers.length ? (clearTimeout(r.criticaltimeouter), n.info("DC_PIECE_NOT_FOUND " + i), r.criticalSeg = null, r.callbacks.onTimeout(r.stats, r.context, null)) : r.criticalSeg.targetPeers = r.criticalSeg.targetPeers.filter((function(t) {
										return t !== e.remotePeerId
									}))), e.bitset.delete(i), o.live && e.resetContinuousHits(), r.requestingMap.delete(i), r._decreBitCounts(i), e.checkIfNeedChoke(!0)
								}))
								.on(a.default.DC_RESPONSE, (function(a, o) {
									var l = r.config,
										u = a.segId,
										c = a.sn,
										d = a.data,
										f = r.criticalSeg && r.criticalSeg.segId === u;
									if (l.validateSegment(u, d))
										if (r.notifyAllPeers(c, u), i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "reportDCTraffic", r)
											.call(r, c, a.size, o), f) {
											n.info("receive criticalSeg seg_id " + u), clearTimeout(r.criticaltimeouter), r.criticaltimeouter = null, e.miss = 0;
											var h = r.stats;
											h.tfirst = h.loading.first = Math.max(h.trequest, performance.now()), h.tload = h.loading.end = h.tfirst, h.loaded = h.total = d.byteLength, r.criticalSeg = null;
											var g = r.context.frag;
											g.fromPeerId = e.remotePeerId, g.loadByP2P = !0, r.callbacks.onSuccess({
												data: d,
												url: r.context.url
											}, h, r.context), e.increContinuousHits(), l.maxSubscribeLevel && l.live && !r.subscribeMode && e.continuousHits > 7 && e.sendSubscribe()
										} else {
											if (r.bitset.has(c)) return;
											var v = new s.default(c, u, d, e.remotePeerId);
											r.bufMgr.putSeg(v), r.updateLoaded(c)
										}
									else n.warn("segment " + u + " validate failed"), f && (clearTimeout(r.criticaltimeouter), r.criticaltimeout());
									r.requestingMap.delete(c), !l.live || r.criticalSeg || r.subscribeMode || r.checkPeers()
								}))
								.on(a.default.DC_REQUEST, (function(t) {
									var i = t.sn;
									r.isUploader = !0, r.subscribers.includes(e.remotePeerId) && (e.subscribeEdgeSN = i);
									var s = t.seg_id;
									s || (s = r.bufMgr.getSegIdBySN(i));
									var o = null;
									if (r.requestingMap.has(i) ? o = r.getPeerLoadedMore(i) : r.subscribeMode && (o = r.subscribeParent), r.bufMgr.hasSegOfId(s)) {
										n.info("found seg from bufMgr");
										var l = r.bufMgr.getSegById(s);
										e.sendBuffer(l.sn, l.segId, l.data, {
											from: "SegmentFromCache"
										})
									} else o && o.downloading && o.pieceMsg.sn === i ? (n.info("target had " + o.bufArr.length + " packets, wait for remain from upstream " + o.remotePeerId), e.sendPartialBuffer(o.pieceMsg, o.bufArr, {
										from: "WaitForPartial",
										incompletes: 1
									}), function(e, t) {
										e.addStreamListener(!1, t.remotePeerId, (function(e, r, n, i, s) {
											n ? t.sendMsgPieceAbort(i) : t.send(i), s && (t.uploading = !1)
										}))
									}(o, e)) : i >= r.loadingSN ? (n.info("peer request " + i + " wait for seg"), r.bufMgr.once("" + a.default.BM_ADDED_SN_ + i, (function(t) {
										t ? (n.info("peer request notify seg " + t.sn), e.sendBuffer(t.sn, t.segId, t.data, {
											from: "NotifySegment"
										})) : e.sendPieceNotFound(i, s)
									}))) : e.sendPieceNotFound(i, s)
								}))
								.on(a.default.DC_SUBSCRIBE, (function() {
									if (r.config.live) {
										var t = r.subscribers.length,
											i = r.config.maxSubscribeLevel;
										if (0 === i) e.sendSubscribeReject("subscribe disabled");
										else if (t >= 25) e.sendSubscribeReject("too many subscribers");
										else if (r.subscribeLevel >= i) e.sendSubscribeReject("subscribe level reach " + r.subscribeLevel);
										else if (r.subscribers.indexOf(e.remotePeerId) >= 0) e.sendSubscribeReject("subscriber already exist");
										else {
											if (t >= 2) {
												var s = [];
												if (r.subscribers.forEach((function(e) {
													var t = r.peerManager.getPeer(e)
														.uploadSpeed;
													t && s.push(t)
												})), !l.default.evaluatePeersSpeed(s, r.estimatedSize)) return void e.sendSubscribeReject("Insufficient upload capability")
											}
											r.subscribers.push(e.remotePeerId), n.info("subscribers add " + e.remotePeerId), e.sendSubscribeAccept(r.subscribeLevel)
										}
									}
								}))
								.on(a.default.DC_UNSUBSCRIBE, (function(t) {
									var i = r.subscribers.indexOf(e.remotePeerId); - 1 !== i && (n.info("subscribers remove " + e.remotePeerId + " reason " + t.reason), r.subscribers.splice(i, 1))
								}))
								.on(a.default.DC_SUBSCRIBE_ACCEPT, (function(t) {
									if (!r.subscribeMode) {
										var n = t.level || 0;
										r.subscribeMode = !0, r.subscribeLevel = n + 1, r.subscribeParent = e, r.notifySubscribeLevel()
									}
								}))
								.on(a.default.DC_SUBSCRIBE_REJECT, (function(t) {
									n.warn("subscribe rejected, reason " + t.reason), e.resetContinuousHits()
								}))
								.on(a.default.DC_SUBSCRIBE_LEVEL, (function(e) {
									if (r.subscribeMode) {
										var t = e.level || 0;
										r.subscribeLevel = t + 1, n.info("set subscribe level to " + r.subscribeLevel), r.notifySubscribeLevel()
									}
								}))
						}
					}, {
						key: "_setupEngine",
						value: function() {
							var e = this;
							this.engine.on(a.default.FRAG_LOADING, (function(t, r, n) {
									e.loadingSN = t, e.loadingSegId = r, e.isHlsV0 && n && e.notifyAllPeers(t, r)
								}))
								.on(a.default.FRAG_LOADED, (function(t, r, n, i, s) {
									e.config.live && (e.estimatedSize = n), !e.isHlsV0 && s && e.notifyAllPeers(t, r), e.updateLoaded(t)
								}))
								.on(a.default.FRAG_CHANGED, (function(t, r) {
									e.updatePlaySN(t)
								}))
						}
					}, {
						key: "notifyPeersLoaded",
						value: function(e) {
							this.logger.info("notifyPeersLoaded " + e), this.waitForPeer && (0 === e ? this.criticaltimeout() : this.waitingPeers = e)
						}
					}, {
						key: "_unsubscribe",
						value: function(e) {
							this.logger.warn("unsubscribe to " + this.subscribeParent.remotePeerId), this.subscribeParent.sendUnsubscribe(e), this.subscribeParent = null, this.subscribeLevel = 0, this.subscribeMode = !1, this.notifySubscribeLevel()
						}
					}, {
						key: "_sendSegmentToSubscribers",
						value: function(e) {
							var t = this,
								r = e.sn,
								n = e.segId,
								i = e.data;
							this.subscribers = this.subscribers.filter((function(e) {
								var s = t.peerManager.getPeer(e);
								return s ? (s.uploading || s.bitset.has(r) || (t.logger.info("send seg " + n + " to subscriber " + e), s.uploading = !0, s.sendBuffer(r, n, i, {
									from: "SegmentToSubscribers"
								}), s.bitset.add(r)), !0) : (t.logger.info("subscribers remove " + e), !1)
							}))
						}
					}, {
						key: "_sendPieceToSubscribers",
						value: function(e, t, r, n, i, s) {
							var a = this;
							this.subscribers = this.subscribers.filter((function(t) {
								var o = a.peerManager.getPeer(t);
								if (o) {
									if (r && e === o.pieceMsg.sn) o.send(i), s && (o.uploading = !1, o.bitset.add(e));
									else if (!r)
										if (n) o.sendMsgPieceAbort(i);
										else {
											if (o.uploading || e <= o.subscribeEdgeSN) return !0;
											o.subscribeEdgeSN = e, o.uploading = !0, o.pieceMsg = i, a.logger.info("downstream msg " + JSON.stringify(i) + " to subscriber " + t), o.sendMsgPiece(i, {
												from: "PieceToSubscribers",
												incompletes: 1
											})
										} return !0
								}
								return a.logger.info("subscribers remove " + t), !1
							}))
						}
					}]), t
				}(o.default);
				t.default = h, e.exports = t.default
			},
			666: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = Object.assign || function(e) {
						for (var t = 1; t < arguments.length; t++) {
							var r = arguments[t];
							for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
						}
						return e
					},
					i = function e(t, r, n) {
						null === t && (t = Function.prototype);
						var i = Object.getOwnPropertyDescriptor(t, r);
						if (void 0 === i) {
							var s = Object.getPrototypeOf(t);
							return null === s ? void 0 : e(s, r, n)
						}
						if ("value" in i) return i.value;
						var a = i.get;
						return void 0 !== a ? a.call(n) : void 0
					},
					s = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					a = T(r(622)),
					o = T(r(980)),
					l = T(r(982)),
					u = T(r(564)),
					c = T(r(233)),
					d = T(r(23)),
					f = T(r(227)),
					h = T(r(542)),
					g = T(r(702)),
					v = T(r(979)),
					p = T(r(522)),
					m = r(206),
					y = r(901),
					b = r(57),
					E = T(r(373)),
					_ = T(r(659));

				function T(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function S(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function A(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				if (window) {
					if (window.p2ploadedHls) throw new Error("You are loading the p2p library multiple times. Please load it only once.");
					window.p2ploadedHls = !0
				}
				var L = function(e) {
					function t(e) {
						var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
						S(this, t);
						var i = A(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this, r));
						i.config = Object.assign({}, o.default, r), i.rangeTested = !1, i.lastLevel = 0, i.hlsjs = e, i.config.waitForPeer && (i.config.trickleICE = !0), i.HLSEvents = e.constructor.Events, i.config.isHlsV0 = "0" === e.constructor.version.split(".")[0], i.config.xhrSetup = e.config.xhrSetup;
						var s = i.config,
							l = s.token,
							u = s.channelId,
							c = s.segmentId;
						l || (l = i.config.channelIdPrefix);
						var d = function(e) {
								var t = a.default.parseURL(e);
								return "" + (t.netLoc.substr(2) + t.path.substring(0, t.path.lastIndexOf(".")))
							},
							f = function(e, t, r, n) {
								var i = r.split("?")[0];
								return i.startsWith("http") && (i = i.split("://")[1]), n ? i + "|" + n : "" + i
							};
						u && "function" == typeof u && (d = i.makeChannelId(l, u), c || (f = function(e, t, r, n) {
							return e + "-" + t
						})), c || (i.config.segmentId = f), e.config.segmentId = i.config.segmentId;
						var g = i.makeSignalId(),
							v = function t(r, s) {
								var a = i.config,
									o = s.details,
									l = o.live;
								a.live = i.hlsjs.config.live = l, i.browserInfo = n({}, i.commonBrowserInfo, {
									abr: i.multiBitrate || void 0,
									tag: a.tag || void 0,
									live: l,
									type: "hls"
								}), i.channel = d(e.url) + "|" + g + "[" + h.default.VERSION + "]", i.browserInfo.device === m.device.PC_NATIVE && (i.browserInfo = n({}, i.browserInfo, {
									app: a.appName,
									bundle: a.appId
								}));
								var u = i.initLogger();
								i.hlsjs.config.logger = u, u.info("channel " + i.channel), l || (a.startSN = o.startSN, a.endSN = o.endSN, u.info("startSN " + o.startSN + " endSN " + o.endSN)), i.eventListened = !1, i._init(i.channel, i.browserInfo), e.off(i.HLSEvents.LEVEL_LOADED, t)
							};
						e.on(i.HLSEvents.LEVEL_LOADED, v);
						var p = function t(r, n) {
							var s = n.levels.length;
							i.multiBitrate = s > 1, e.off(i.HLSEvents.MANIFEST_PARSED, t)
						};
						return e.on(i.HLSEvents.MANIFEST_PARSED, p), i
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), s(t, null, [{
						key: "Events",
						get: function() {
							return f.default
						}
					}]), s(t, [{
						key: "_init",
						value: function(e, t) {
							if (this.p2pEnabled) {
								var r = this.multiBitrate || this.config.scheduledBySegId;
								this.hlsjs.config.p2pEnabled = this.p2pEnabled, this.hlsjs.config.sharePlaylist = this.config.sharePlaylist, this.bufMgr = new d.default(this, this.config, !r), this.hlsjs.config.bufMgr = this.bufMgr, this.media = this.hlsjs.media;
								var n = new g.default(this, this.config.token, encodeURIComponent(e), this.config.announce || "", t);
								this.fetcher = n;
								var i = void 0;
								i = r ? new _.default(this, this.config) : new E.default(this, this.config), this.tracker = new c.default(this, n, i, this.config), i.bufferManager = this.bufMgr, this.hlsjs.config.fLoader = l.default, this.config.sharePlaylist && (this.hlsjs.config.pLoader = u.default), window.__p2p_loader__ = {
									scheduler: this.tracker.scheduler,
									fetcher: n,
									p2pBlackList: this.config.p2pBlackList,
									isHlsV0: this.config.isHlsV0
								}, this.trackerTried = !1, this.eventListened || (this.hlsjs.on(this.HLSEvents.FRAG_LOADING, this._onFragLoading.bind(this)), this.hlsjs.on(this.HLSEvents.FRAG_LOADED, this._onFragLoaded.bind(this)), this.hlsjs.on(this.HLSEvents.FRAG_CHANGED, this._onFragChanged.bind(this)), this.hlsjs.on(this.HLSEvents.ERROR, this._onHlsError.bind(this)), this.eventListened = !0), this.setupWindowListeners(), this.trackerTried || this.tracker.connected || !this.config.p2pEnabled || (this.tracker.resumeP2P(), this.trackerTried = !0)
							}
						}
					}, {
						key: "_onFragLoading",
						value: function(e, t) {
							var r = t.frag,
								n = r.sn,
								i = r.segId;
							if (!(0, b.isBlockType)(r.url, this.config.p2pBlackList)) {
								if (this.logger.debug("loading frag " + n), !i) {
									var s = void 0;
									r._byteRange && (s = "bytes=" + r._byteRange[0] + "-" + r._byteRange[1]);
									var a = r.url;
									i = t.frag.segId = this.config.segmentId(String(r.level), r.sn, a, s)
								}
								this.emit(f.default.FRAG_LOADING, n, i, t.frag.loadByHTTP)
							}
						}
					}, {
						key: "_onFragLoaded",
						value: function(e, t) {
							var r = t.frag,
								n = r.sn,
								i = r.level,
								s = r.segId,
								a = r.loaded,
								o = r.duration,
								l = this.config,
								u = this.logger;
							(0, b.isBlockType)(t.frag.url, l.p2pBlackList) || (this.emit(f.default.FRAG_LOADED, n, s, a, o, t.frag.loadByHTTP, i), !this.rangeTested && l.useHttpRange && ((0, y.performRangeRequest)(t.frag.url, "bytes=0-0", l.xhrSetup)
								.then((function() {
									l.httpRangeSupported = !0, u.info("http range is supported"), l.httpLoadTime -= 1.5, l.httpLoadTime < 1.5 && (l.httpLoadTime = 1.5), l.simultaneousTargetPeers = 1
								}))
								.catch((function() {
									l.httpRangeSupported = !1, u.warn("http range is not supported")
								})), this.rangeTested = !0))
						}
					}, {
						key: "_onFragChanged",
						value: function(e, t) {
							if (!(0, b.isBlockType)(t.frag.url, this.config.p2pBlackList)) {
								this.logger.debug("frag changed: " + t.frag.sn);
								var r = t.frag,
									n = r.sn,
									i = r.duration;
								this.emit(f.default.FRAG_CHANGED, n, i)
							}
						}
					}, {
						key: "_onHlsError",
						value: function(e, t) {
							var r = this.logger;
							t.fatal ? r.error(t.type + " details " + t.details + " reason " + t.reason) : r.warn(t.type + " details " + t.details + " reason " + t.reason);
							var n = this.hlsjs.constructor.ErrorDetails;
							switch (t.details) {
								case n.BUFFER_STALLED_ERROR:
									this.fetcher && this.fetcher.increRebuffers();
									break;
								case n.INTERNAL_EXCEPTION:
									this.fetcher && (this.fetcher.errsInternalExpt++, this.fetcher.exptMsg = t.err.message), r.error("INTERNAL_EXCEPTION event " + t.event + " err " + t.err.message), this.emit(f.default.EXCEPTION, (0, p.default)(t.err, "HLSJS_EXPT"))
							}
						}
					}, {
						key: "getExtraForStats",
						value: function() {
							var e = i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getExtraForStats", this)
								.call(this);
							return this.config.live || (e.pos = Math.round(this.media.currentTime)), this.multiBitrate && this.currentLevel !== this.lastLevel && (e.level = this.currentLevel + "", this.lastLevel = this.currentLevel), e
						}
					}, {
						key: "getExtraForPeersRequest",
						value: function() {
							var e = i(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getExtraForPeersRequest", this)
								.call(this);
							return this.multiBitrate && (e.level = this.currentLevel + ""), e
						}
					}, {
						key: "disableP2P",
						value: function() {
							this.logger && this.logger.warn("disable P2P"), this.p2pEnabled && (this.p2pEnabled = !1, this.config.p2pEnabled = this.hlsjs.config.p2pEnabled = this.p2pEnabled, this.tracker && (this.tracker.stopP2P(), this.tracker = {}, this.fetcher = null, this.bufMgr.destroy(), this.bufMgr = null, this.hlsjs.config.fLoader = this.hlsjs.config.pLoader = this.hlsjs.constructor.DefaultConfig.loader))
						}
					}, {
						key: "currentLevel",
						get: function() {
							var e = this.hlsjs.currentLevel;
							return e >= 0 ? e : 0
						}
					}]), t
				}(v.default);
				window && (window.P2pEngine = window.P2pEngineHls = window.P2PEngineHls = L), t.default = L, e.exports = t.default
			},
			53: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n, i, s = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					a = r(666),
					o = (n = a) && n.__esModule ? n : {
						default: n
					};

				function l(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function u(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				i = r(305);
				var c = {
						maxBufferLength: 8
					},
					d = {
						maxBufferLength: 40
					},
					f = function(e) {
						function t() {
							var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							l(this, t);
							var r = e.p2pConfig || {},
								n = !1 === r.live ? d : c,
								s = JSON.parse(JSON.stringify(n));
							for (var a in s.liveSyncDurationCount = 10, s.manifestLoadingMaxRetry = 3, s.manifestLoadingRetryDelay = 700, s.levelLoadingRetryDelay = 700, s.maxBufferSize = 0, e) "p2pConfig" !== a && (s[a] = e[a]);
							var f = u(this, (t.__proto__ || Object.getPrototypeOf(t))
								.call(this, s));
							return f._restartEvent = function() {
								f.restartP2P()
							}, o.default.isSupported() && (f._p2pEngine = new o.default(f, r), f._p2pEngine.on(o.default.Events.RESTART_P2P, f._restartEvent)), f.on(i.Events.DESTROYING, (function() {
								f._p2pEngine && (f._p2pEngine.removeListener(o.default.Events.RESTART_P2P, f._restartEvent), f._p2pEngine.destroy(), f._p2pEngine.hlsjs = null, f._p2pEngine = null)
							})), f
						}
						return function(e, t) {
							if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
							e.prototype = Object.create(t && t.prototype, {
								constructor: {
									value: e,
									enumerable: !1,
									writable: !0,
									configurable: !0
								}
							}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
						}(t, e), s(t, null, [{
							key: "P2PEvents",
							get: function() {
								return o.default.Events
							}
						}]), s(t, [{
							key: "enableP2P",
							value: function() {
								this._p2pEngine && (this._p2pEngine = this._p2pEngine.enableP2P())
							}
						}, {
							key: "disableP2P",
							value: function() {
								this._p2pEngine && this._p2pEngine.disableP2P()
							}
						}, {
							key: "restartP2P",
							value: function() {
								var e = this;
								this._p2pEngine && (this._p2pEngine.disableP2P(), setTimeout((function() {
									e.enableP2P()
								}), 2e3), this._p2pEngine.removeListener(o.default.Events.RESTART_P2P, this._restartEvent))
							}
						}, {
							key: "p2pEngine",
							get: function() {
								return this._p2pEngine
							}
						}]), t
					}(i);
				f.engineVersion = o.default.version, f.protocolVersion = o.default.protocolVersion, f.WEBRTC_SUPPORT = o.default.isSupported(), t.default = f, e.exports = t.default
			},
			564: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = l(r(204)),
					s = l(r(659)),
					a = l(r(3)),
					o = r(57);

				function l(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}
				var u = function(e) {
					function t(e) {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, t);
						var r = function(e, t) {
							if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
							return !t || "object" != typeof t && "function" != typeof t ? e : t
						}(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this));
						r.logger = e.logger;
						var n = window.__p2p_loader__.scheduler;
						return r.isHlsV0 = e.isHlsV0, r.xhrLoader = new e.loader(e), r.p2pEnabled = e.p2pEnabled, r.scheduler = n, r.multiBitrate = r.scheduler instanceof s.default, r.stats = r.xhrLoader.stats || (0, o.createLoadStats)(), r
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "destroy",
						value: function() {
							this.xhrLoader.destroy()
						}
					}, {
						key: "abort",
						value: function() {
							this.xhrLoader.abort()
						}
					}, {
						key: "load",
						value: function(e, t, r) {
							var n = this,
								i = this.logger,
								s = e.url,
								l = s.split("?")[0],
								u = r.onSuccess;
							if (r.onSuccess = function(e, t, r) {
								n.scheduler.broadcastPlaylist(l, e.data), u(e, t, r)
							}, this.scheduler.playlistInfo.has(l)) {
								var c = this.scheduler.getPlaylistFromPeer(l);
								if (c && c.data) {
									var d = c.data,
										f = c.seq;
									i.info("got playlist from peer seq " + f), (0, o.updateLoadStats)(this.stats, d.length);
									var h = {
										url: s,
										data: d
									};
									return void(0, a.default)((function() {
										r.onSuccess(h, n.stats, e)
									}))
								}
							}
							this.xhrLoader.load(e, t, r)
						}
					}]), t
				}(i.default);
				t.default = u, e.exports = t.default
			},
			531: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = function() {
						function e(e, t) {
							for (var r = 0; r < t.length; r++) {
								var n = t[r];
								n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
							}
						}
						return function(t, r, n) {
							return r && e(t.prototype, r), n && e(t, n), t
						}
					}(),
					i = a(r(542)),
					s = a(r(227));

				function a(e) {
					return e && e.__esModule ? e : {
						default: e
					}
				}

				function o(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}

				function l(e, t) {
					if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return !t || "object" != typeof t && "function" != typeof t ? e : t
				}
				var u = function(e) {
					function t(e, r, n, i, s) {
						var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
						o(this, t);
						var u = l(this, (t.__proto__ || Object.getPrototypeOf(t))
							.call(this, e, r, n, i, s, a));
						return u.continuousHits = 0, u.subscribeEdgeSN = 0, u
					}
					return function(e, t) {
						if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
						e.prototype = Object.create(t && t.prototype, {
							constructor: {
								value: e,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
					}(t, e), n(t, [{
						key: "resetContinuousHits",
						value: function() {
							var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
							this.logger.info("reset " + this.remotePeerId + " continuousHits"), this.continuousHits = e
						}
					}, {
						key: "increContinuousHits",
						value: function() {
							this.continuousHits++
						}
					}, {
						key: "sendSubscribe",
						value: function() {
							this.sendJson({
								event: s.default.DC_SUBSCRIBE
							})
						}
					}, {
						key: "sendUnsubscribe",
						value: function(e) {
							this.resetContinuousHits(), this.sendJson({
								event: s.default.DC_UNSUBSCRIBE,
								reason: e
							})
						}
					}, {
						key: "sendSubscribeReject",
						value: function(e) {
							this.sendJson({
								event: s.default.DC_SUBSCRIBE_REJECT,
								reason: e
							})
						}
					}, {
						key: "sendSubscribeAccept",
						value: function(e) {
							this.sendJson({
								event: s.default.DC_SUBSCRIBE_ACCEPT,
								level: e
							})
						}
					}, {
						key: "sendSubscribeLevel",
						value: function(e) {
							this.sendJson({
								event: s.default.DC_SUBSCRIBE_LEVEL,
								level: e
							})
						}
					}]), t
				}(i.default);
				t.default = u, e.exports = t.default
			},
			427: (e, t) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var r = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var n = t[r];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
						}
					}
					return function(t, r, n) {
						return r && e(t.prototype, r), n && e(t, n), t
					}
				}();
				var n = function() {
					function e() {
						! function(e, t) {
							if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
						}(this, e)
					}
					return r(e, null, [{
						key: "evaluatePeersSpeed",
						value: function(e, t) {
							var r = t / 3500,
								n = r,
								i = 1.05 * r,
								s = 0;
							return e.forEach((function(e) {
								if (e) {
									if (e < n) return !1;
									s += e
								}
							})), s / e.length >= i
						}
					}]), e
				}();
				t.default = n, e.exports = t.default
			},
			57: (e, t, r) => {
				"use strict";
				Object.defineProperty(t, "__esModule", {
					value: !0
				}), t.isBlockType = function(e, t) {
					var r = s.default.parseURL(e),
						n = r.path.substring(r.path.lastIndexOf(".") + 1);
					return -1 !== t.indexOf(n)
				}, t.createLoadStats = function() {
					var e = performance.now();
					return {
						trequest: e,
						tfirst: 0,
						tload: 0,
						aborted: !1,
						loaded: 0,
						retry: 0,
						total: 0,
						chunkCount: 0,
						bwEstimate: 0,
						loading: {
							start: e,
							first: 0,
							end: 0
						},
						parsing: {
							start: 0,
							end: 0
						},
						buffering: {
							start: 0,
							first: 0,
							end: 0
						}
					}
				}, t.updateLoadStats = function(e, t) {
					var r, n, i, s, a, o = performance.now();
					r = o - 300, n = o - 200, i = o, e.trequest = r, e.tfirst = n, e.tload = i, e.loading = {
						first: r,
						start: n,
						end: i
					}, s = a = t, e.loaded = s, e.total = a
				};
				var n, i = r(622),
					s = (n = i) && n.__esModule ? n : {
						default: n
					}
			},
			204: e => {
				"use strict";
				var t, r = "object" == typeof Reflect ? Reflect : null,
					n = r && "function" == typeof r.apply ? r.apply : function(e, t, r) {
						return Function.prototype.apply.call(e, t, r)
					};
				t = r && "function" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function(e) {
					return Object.getOwnPropertyNames(e)
						.concat(Object.getOwnPropertySymbols(e))
				} : function(e) {
					return Object.getOwnPropertyNames(e)
				};
				var i = Number.isNaN || function(e) {
					return e != e
				};

				function s() {
					s.init.call(this)
				}
				e.exports = s, e.exports.once = function(e, t) {
					return new Promise((function(r, n) {
						function i(r) {
							e.removeListener(t, s), n(r)
						}

						function s() {
							"function" == typeof e.removeListener && e.removeListener("error", i), r([].slice.call(arguments))
						}
						v(e, t, s, {
							once: !0
						}), "error" !== t && function(e, t, r) {
							"function" == typeof e.on && v(e, "error", t, r)
						}(e, i, {
							once: !0
						})
					}))
				}, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
				var a = 10;

				function o(e) {
					if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
				}

				function l(e) {
					return void 0 === e._maxListeners ? s.defaultMaxListeners : e._maxListeners
				}

				function u(e, t, r, n) {
					var i, s, a, u;
					if (o(r), void 0 === (s = e._events) ? (s = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== s.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), s = e._events), a = s[t]), void 0 === a) a = s[t] = r, ++e._eventsCount;
					else if ("function" == typeof a ? a = s[t] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), (i = l(e)) > 0 && a.length > i && !a.warned) {
						a.warned = !0;
						var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
						c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = t, c.count = a.length, u = c, console && console.warn && console.warn(u)
					}
					return e
				}

				function c() {
					if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
				}

				function d(e, t, r) {
					var n = {
							fired: !1,
							wrapFn: void 0,
							target: e,
							type: t,
							listener: r
						},
						i = c.bind(n);
					return i.listener = r, n.wrapFn = i, i
				}

				function f(e, t, r) {
					var n = e._events;
					if (void 0 === n) return [];
					var i = n[t];
					return void 0 === i ? [] : "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function(e) {
						for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];
						return t
					}(i) : g(i, i.length)
				}

				function h(e) {
					var t = this._events;
					if (void 0 !== t) {
						var r = t[e];
						if ("function" == typeof r) return 1;
						if (void 0 !== r) return r.length
					}
					return 0
				}

				function g(e, t) {
					for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];
					return r
				}

				function v(e, t, r, n) {
					if ("function" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r);
					else {
						if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
						e.addEventListener(t, (function i(s) {
							n.once && e.removeEventListener(t, i), r(s)
						}))
					}
				}
				Object.defineProperty(s, "defaultMaxListeners", {
					enumerable: !0,
					get: function() {
						return a
					},
					set: function(e) {
						if ("number" != typeof e || e < 0 || i(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
						a = e
					}
				}), s.init = function() {
					void 0 !== this._events && this._events !== Object.getPrototypeOf(this)
						._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
				}, s.prototype.setMaxListeners = function(e) {
					if ("number" != typeof e || e < 0 || i(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
					return this._maxListeners = e, this
				}, s.prototype.getMaxListeners = function() {
					return l(this)
				}, s.prototype.emit = function(e) {
					for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);
					var i = "error" === e,
						s = this._events;
					if (void 0 !== s) i = i && void 0 === s.error;
					else if (!i) return !1;
					if (i) {
						var a;
						if (t.length > 0 && (a = t[0]), a instanceof Error) throw a;
						var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
						throw o.context = a, o
					}
					var l = s[e];
					if (void 0 === l) return !1;
					if ("function" == typeof l) n(l, this, t);
					else {
						var u = l.length,
							c = g(l, u);
						for (r = 0; r < u; ++r) n(c[r], this, t)
					}
					return !0
				}, s.prototype.addListener = function(e, t) {
					return u(this, e, t, !1)
				}, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(e, t) {
					return u(this, e, t, !0)
				}, s.prototype.once = function(e, t) {
					return o(t), this.on(e, d(this, e, t)), this
				}, s.prototype.prependOnceListener = function(e, t) {
					return o(t), this.prependListener(e, d(this, e, t)), this
				}, s.prototype.removeListener = function(e, t) {
					var r, n, i, s, a;
					if (o(t), void 0 === (n = this._events)) return this;
					if (void 0 === (r = n[e])) return this;
					if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t));
					else if ("function" != typeof r) {
						for (i = -1, s = r.length - 1; s >= 0; s--)
							if (r[s] === t || r[s].listener === t) {
								a = r[s].listener, i = s;
								break
							} if (i < 0) return this;
						0 === i ? r.shift() : function(e, t) {
							for (; t + 1 < e.length; t++) e[t] = e[t + 1];
							e.pop()
						}(r, i), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", e, a || t)
					}
					return this
				}, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(e) {
					var t, r, n;
					if (void 0 === (r = this._events)) return this;
					if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this;
					if (0 === arguments.length) {
						var i, s = Object.keys(r);
						for (n = 0; n < s.length; ++n) "removeListener" !== (i = s[n]) && this.removeAllListeners(i);
						return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
					}
					if ("function" == typeof(t = r[e])) this.removeListener(e, t);
					else if (void 0 !== t)
						for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);
					return this
				}, s.prototype.listeners = function(e) {
					return f(this, e, !0)
				}, s.prototype.rawListeners = function(e) {
					return f(this, e, !1)
				}, s.listenerCount = function(e, t) {
					return "function" == typeof e.listenerCount ? e.listenerCount(t) : h.call(e, t)
				}, s.prototype.listenerCount = h, s.prototype.eventNames = function() {
					return this._eventsCount > 0 ? t(this._events) : []
				}
			},
			305: function(e) {
				var t;
				"undefined" != typeof window && (t = function() {
					return function(e) {
							var t = {};

							function r(n) {
								if (t[n]) return t[n].exports;
								var i = t[n] = {
									i: n,
									l: !1,
									exports: {}
								};
								return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports
							}
							return r.m = e, r.c = t, r.d = function(e, t, n) {
								r.o(e, t) || Object.defineProperty(e, t, {
									enumerable: !0,
									get: n
								})
							}, r.r = function(e) {
								"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
									value: "Module"
								}), Object.defineProperty(e, "__esModule", {
									value: !0
								})
							}, r.t = function(e, t) {
								if (1 & t && (e = r(e)), 8 & t) return e;
								if (4 & t && "object" == typeof e && e && e.__esModule) return e;
								var n = Object.create(null);
								if (r.r(n), Object.defineProperty(n, "default", {
									enumerable: !0,
									value: e
								}), 2 & t && "string" != typeof e)
									for (var i in e) r.d(n, i, function(t) {
										return e[t]
									}.bind(null, i));
								return n
							}, r.n = function(e) {
								var t = e && e.__esModule ? function() {
									return e.default
								} : function() {
									return e
								};
								return r.d(t, "a", t), t
							}, r.o = function(e, t) {
								return Object.prototype.hasOwnProperty.call(e, t)
							}, r.p = "/dist/", r(r.s = "./src/hls.ts")
						}({
							"./node_modules/eventemitter3/index.js": function(e, t, r) {
								"use strict";
								var n = Object.prototype.hasOwnProperty,
									i = "~";

								function s() {}

								function a(e, t, r) {
									this.fn = e, this.context = t, this.once = r || !1
								}

								function o(e, t, r, n, s) {
									if ("function" != typeof r) throw new TypeError("The listener must be a function");
									var o = new a(r, n || e, s),
										l = i ? i + t : t;
									return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e
								}

								function l(e, t) {
									0 == --e._eventsCount ? e._events = new s : delete e._events[t]
								}

								function u() {
									this._events = new s, this._eventsCount = 0
								}
								Object.create && (s.prototype = Object.create(null), (new s)
									.__proto__ || (i = !1)), u.prototype.eventNames = function() {
									var e, t, r = [];
									if (0 === this._eventsCount) return r;
									for (t in e = this._events) n.call(e, t) && r.push(i ? t.slice(1) : t);
									return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r
								}, u.prototype.listeners = function(e) {
									var t = i ? i + e : e,
										r = this._events[t];
									if (!r) return [];
									if (r.fn) return [r.fn];
									for (var n = 0, s = r.length, a = new Array(s); n < s; n++) a[n] = r[n].fn;
									return a
								}, u.prototype.listenerCount = function(e) {
									var t = i ? i + e : e,
										r = this._events[t];
									return r ? r.fn ? 1 : r.length : 0
								}, u.prototype.emit = function(e, t, r, n, s, a) {
									var o = i ? i + e : e;
									if (!this._events[o]) return !1;
									var l, u, c = this._events[o],
										d = arguments.length;
									if (c.fn) {
										switch (c.once && this.removeListener(e, c.fn, void 0, !0), d) {
											case 1:
												return c.fn.call(c.context), !0;
											case 2:
												return c.fn.call(c.context, t), !0;
											case 3:
												return c.fn.call(c.context, t, r), !0;
											case 4:
												return c.fn.call(c.context, t, r, n), !0;
											case 5:
												return c.fn.call(c.context, t, r, n, s), !0;
											case 6:
												return c.fn.call(c.context, t, r, n, s, a), !0
										}
										for (u = 1, l = new Array(d - 1); u < d; u++) l[u - 1] = arguments[u];
										c.fn.apply(c.context, l)
									} else {
										var f, h = c.length;
										for (u = 0; u < h; u++) switch (c[u].once && this.removeListener(e, c[u].fn, void 0, !0), d) {
											case 1:
												c[u].fn.call(c[u].context);
												break;
											case 2:
												c[u].fn.call(c[u].context, t);
												break;
											case 3:
												c[u].fn.call(c[u].context, t, r);
												break;
											case 4:
												c[u].fn.call(c[u].context, t, r, n);
												break;
											default:
												if (!l)
													for (f = 1, l = new Array(d - 1); f < d; f++) l[f - 1] = arguments[f];
												c[u].fn.apply(c[u].context, l)
										}
									}
									return !0
								}, u.prototype.on = function(e, t, r) {
									return o(this, e, t, r, !1)
								}, u.prototype.once = function(e, t, r) {
									return o(this, e, t, r, !0)
								}, u.prototype.removeListener = function(e, t, r, n) {
									var s = i ? i + e : e;
									if (!this._events[s]) return this;
									if (!t) return l(this, s), this;
									var a = this._events[s];
									if (a.fn) a.fn !== t || n && !a.once || r && a.context !== r || l(this, s);
									else {
										for (var o = 0, u = [], c = a.length; o < c; o++)(a[o].fn !== t || n && !a[o].once || r && a[o].context !== r) && u.push(a[o]);
										u.length ? this._events[s] = 1 === u.length ? u[0] : u : l(this, s)
									}
									return this
								}, u.prototype.removeAllListeners = function(e) {
									var t;
									return e ? (t = i ? i + e : e, this._events[t] && l(this, t)) : (this._events = new s, this._eventsCount = 0), this
								}, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = i, u.EventEmitter = u, e.exports = u
							},
							"./node_modules/url-toolkit/src/url-toolkit.js": function(e, t, r) {
								var n, i, s, a, o;
								n = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/, i = /^([^\/?#]*)([^]*)$/, s = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
									buildAbsoluteURL: function(e, t, r) {
										if (r = r || {}, e = e.trim(), !(t = t.trim())) {
											if (!r.alwaysNormalize) return e;
											var n = o.parseURL(e);
											if (!n) throw new Error("Error trying to parse base URL.");
											return n.path = o.normalizePath(n.path), o.buildURLFromParts(n)
										}
										var s = o.parseURL(t);
										if (!s) throw new Error("Error trying to parse relative URL.");
										if (s.scheme) return r.alwaysNormalize ? (s.path = o.normalizePath(s.path), o.buildURLFromParts(s)) : t;
										var a = o.parseURL(e);
										if (!a) throw new Error("Error trying to parse base URL.");
										if (!a.netLoc && a.path && "/" !== a.path[0]) {
											var l = i.exec(a.path);
											a.netLoc = l[1], a.path = l[2]
										}
										a.netLoc && !a.path && (a.path = "/");
										var u = {
											scheme: a.scheme,
											netLoc: s.netLoc,
											path: null,
											params: s.params,
											query: s.query,
											fragment: s.fragment
										};
										if (!s.netLoc && (u.netLoc = a.netLoc, "/" !== s.path[0]))
											if (s.path) {
												var c = a.path,
													d = c.substring(0, c.lastIndexOf("/") + 1) + s.path;
												u.path = o.normalizePath(d)
											} else u.path = a.path, s.params || (u.params = a.params, s.query || (u.query = a.query));
										return null === u.path && (u.path = r.alwaysNormalize ? o.normalizePath(s.path) : s.path), o.buildURLFromParts(u)
									},
									parseURL: function(e) {
										var t = n.exec(e);
										return t ? {
											scheme: t[1] || "",
											netLoc: t[2] || "",
											path: t[3] || "",
											params: t[4] || "",
											query: t[5] || "",
											fragment: t[6] || ""
										} : null
									},
									normalizePath: function(e) {
										for (e = e.split("")
											.reverse()
											.join("")
											.replace(s, ""); e.length !== (e = e.replace(a, ""))
											.length;);
										return e.split("")
											.reverse()
											.join("")
									},
									buildURLFromParts: function(e) {
										return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
									}
								}, e.exports = o
							},
							"./node_modules/webworkify-webpack/index.js": function(e, t, r) {
								function n(e) {
									var t = {};

									function r(n) {
										if (t[n]) return t[n].exports;
										var i = t[n] = {
											i: n,
											l: !1,
											exports: {}
										};
										return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports
									}
									r.m = e, r.c = t, r.i = function(e) {
										return e
									}, r.d = function(e, t, n) {
										r.o(e, t) || Object.defineProperty(e, t, {
											configurable: !1,
											enumerable: !0,
											get: n
										})
									}, r.r = function(e) {
										Object.defineProperty(e, "__esModule", {
											value: !0
										})
									}, r.n = function(e) {
										var t = e && e.__esModule ? function() {
											return e.default
										} : function() {
											return e
										};
										return r.d(t, "a", t), t
									}, r.o = function(e, t) {
										return Object.prototype.hasOwnProperty.call(e, t)
									}, r.p = "/", r.oe = function(e) {
										throw console.error(e), e
									};
									var n = r(r.s = ENTRY_MODULE);
									return n.default || n
								}
								var i = "[\\.|\\-|\\+|\\w|/|@]+",
									s = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)";

								function a(e) {
									return (e + "")
										.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
								}

								function o(e, t, n) {
									var o = {};
									o[n] = [];
									var l = t.toString(),
										u = l.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
									if (!u) return o;
									for (var c, d = u[1], f = new RegExp("(\\\\n|\\W)" + a(d) + s, "g"); c = f.exec(l);) "dll-reference" !== c[3] && o[n].push(c[3]);
									for (f = new RegExp("\\(" + a(d) + '\\("(dll-reference\\s(' + i + '))"\\)\\)' + s, "g"); c = f.exec(l);) e[c[2]] || (o[n].push(c[1]), e[c[2]] = r(c[1])
										.m), o[c[2]] = o[c[2]] || [], o[c[2]].push(c[4]);
									for (var h, g = Object.keys(o), v = 0; v < g.length; v++)
										for (var p = 0; p < o[g[v]].length; p++) h = o[g[v]][p], isNaN(1 * h) || (o[g[v]][p] = 1 * o[g[v]][p]);
									return o
								}

								function l(e) {
									return Object.keys(e)
										.reduce((function(t, r) {
											return t || e[r].length > 0
										}), !1)
								}
								e.exports = function(e, t) {
									t = t || {};
									var i = {
											main: r.m
										},
										s = t.all ? {
											main: Object.keys(i.main)
										} : function(e, t) {
											for (var r = {
												main: [t]
											}, n = {
												main: []
											}, i = {
												main: {}
											}; l(r);)
												for (var s = Object.keys(r), a = 0; a < s.length; a++) {
													var u = s[a],
														c = r[u].pop();
													if (i[u] = i[u] || {}, !i[u][c] && e[u][c]) {
														i[u][c] = !0, n[u] = n[u] || [], n[u].push(c);
														for (var d = o(e, e[u][c], u), f = Object.keys(d), h = 0; h < f.length; h++) r[f[h]] = r[f[h]] || [], r[f[h]] = r[f[h]].concat(d[f[h]])
													}
												}
											return n
										}(i, e),
										a = "";
									Object.keys(s)
										.filter((function(e) {
											return "main" !== e
										}))
										.forEach((function(e) {
											for (var t = 0; s[e][t];) t++;
											s[e].push(t), i[e][t] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", a = a + "var " + e + " = (" + n.toString()
												.replace("ENTRY_MODULE", JSON.stringify(t)) + ")({" + s[e].map((function(t) {
													return JSON.stringify(t) + ": " + i[e][t].toString()
												}))
												.join(",") + "});\n"
										})), a = a + "new ((" + n.toString()
										.replace("ENTRY_MODULE", JSON.stringify(e)) + ")({" + s.main.map((function(e) {
											return JSON.stringify(e) + ": " + i.main[e].toString()
										}))
										.join(",") + "}))(self);";
									var u = new window.Blob([a], {
										type: "text/javascript"
									});
									if (t.bare) return u;
									var c = (window.URL || window.webkitURL || window.mozURL || window.msURL)
										.createObjectURL(u),
										d = new window.Worker(c);
									return d.objectURL = c, d
								}
							},
							"./src/config.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "hlsDefaultConfig", (function() {
									return S
								})), r.d(t, "mergeConfig", (function() {
									return A
								})), r.d(t, "enableStreamingMode", (function() {
									return L
								}));
								var n = r("./src/controller/abr-controller.ts"),
									i = r("./src/controller/audio-stream-controller.ts"),
									s = r("./src/controller/audio-track-controller.ts"),
									a = r("./src/controller/subtitle-stream-controller.ts"),
									o = r("./src/controller/subtitle-track-controller.ts"),
									l = r("./src/controller/buffer-controller.ts"),
									u = r("./src/controller/timeline-controller.ts"),
									c = r("./src/controller/cap-level-controller.ts"),
									d = r("./src/controller/fps-controller.ts"),
									f = r("./src/controller/eme-controller.ts"),
									h = r("./src/controller/cmcd-controller.ts"),
									g = r("./src/utils/xhr-loader.ts"),
									v = r("./src/utils/fetch-loader.ts"),
									p = r("./src/utils/cues.ts"),
									m = r("./src/utils/mediakeys-helper.ts"),
									y = r("./src/utils/logger.ts");

								function b() {
									return b = Object.assign || function(e) {
										for (var t = 1; t < arguments.length; t++) {
											var r = arguments[t];
											for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
										}
										return e
									}, b.apply(this, arguments)
								}

								function E(e, t) {
									var r = Object.keys(e);
									if (Object.getOwnPropertySymbols) {
										var n = Object.getOwnPropertySymbols(e);
										t && (n = n.filter((function(t) {
											return Object.getOwnPropertyDescriptor(e, t)
												.enumerable
										}))), r.push.apply(r, n)
									}
									return r
								}

								function _(e) {
									for (var t = 1; t < arguments.length; t++) {
										var r = null != arguments[t] ? arguments[t] : {};
										t % 2 ? E(Object(r), !0)
											.forEach((function(t) {
												T(e, t, r[t])
											})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : E(Object(r))
											.forEach((function(t) {
												Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
											}))
									}
									return e
								}

								function T(e, t, r) {
									return t in e ? Object.defineProperty(e, t, {
										value: r,
										enumerable: !0,
										configurable: !0,
										writable: !0
									}) : e[t] = r, e
								}
								var S = _(_({
									autoStartLoad: !0,
									startPosition: -1,
									defaultAudioCodec: void 0,
									debug: !1,
									capLevelOnFPSDrop: !1,
									capLevelToPlayerSize: !1,
									initialLiveManifestSize: 1,
									maxBufferLength: 30,
									backBufferLength: 1 / 0,
									maxBufferSize: 6e7,
									maxBufferHole: .1,
									highBufferWatchdogPeriod: 2,
									nudgeOffset: .1,
									nudgeMaxRetry: 3,
									maxFragLookUpTolerance: .25,
									liveSyncDurationCount: 3,
									liveMaxLatencyDurationCount: 1 / 0,
									liveSyncDuration: void 0,
									liveMaxLatencyDuration: void 0,
									maxLiveSyncPlaybackRate: 1,
									liveDurationInfinity: !1,
									liveBackBufferLength: null,
									maxMaxBufferLength: 600,
									enableWorker: !0,
									enableSoftwareAES: !0,
									manifestLoadingTimeOut: 1e4,
									manifestLoadingMaxRetry: 1,
									manifestLoadingRetryDelay: 1e3,
									manifestLoadingMaxRetryTimeout: 64e3,
									startLevel: void 0,
									levelLoadingTimeOut: 1e4,
									levelLoadingMaxRetry: 4,
									levelLoadingRetryDelay: 1e3,
									levelLoadingMaxRetryTimeout: 64e3,
									fragLoadingTimeOut: 2e4,
									fragLoadingMaxRetry: 6,
									fragLoadingRetryDelay: 1e3,
									fragLoadingMaxRetryTimeout: 64e3,
									startFragPrefetch: !1,
									fpsDroppedMonitoringPeriod: 5e3,
									fpsDroppedMonitoringThreshold: .2,
									appendErrorMaxRetry: 3,
									loader: g.default,
									fLoader: void 0,
									pLoader: void 0,
									xhrSetup: void 0,
									licenseXhrSetup: void 0,
									licenseResponseCallback: void 0,
									abrController: n.default,
									bufferController: l.default,
									capLevelController: c.default,
									fpsController: d.default,
									stretchShortVideoTrack: !1,
									maxAudioFramesDrift: 1,
									forceKeyFrameOnDiscontinuity: !0,
									abrEwmaFastLive: 3,
									abrEwmaSlowLive: 9,
									abrEwmaFastVoD: 3,
									abrEwmaSlowVoD: 9,
									abrEwmaDefaultEstimate: 5e5,
									abrBandWidthFactor: .95,
									abrBandWidthUpFactor: .7,
									abrMaxWithRealBitrate: !1,
									maxStarvationDelay: 4,
									maxLoadingDelay: 4,
									minAutoBitrate: 0,
									emeEnabled: !1,
									widevineLicenseUrl: void 0,
									drmSystemOptions: {},
									requestMediaKeySystemAccessFunc: m.requestMediaKeySystemAccess,
									testBandwidth: !0,
									progressive: !1,
									lowLatencyMode: !0,
									cmcd: void 0
								}, {
									cueHandler: p.default,
									enableCEA708Captions: !0,
									enableWebVTT: !0,
									enableIMSC1: !0,
									captionsTextTrack1Label: "English",
									captionsTextTrack1LanguageCode: "en",
									captionsTextTrack2Label: "Spanish",
									captionsTextTrack2LanguageCode: "es",
									captionsTextTrack3Label: "Unknown CC",
									captionsTextTrack3LanguageCode: "",
									captionsTextTrack4Label: "Unknown CC",
									captionsTextTrack4LanguageCode: "",
									renderTextTracksNatively: !0
								}), {}, {
									subtitleStreamController: a.SubtitleStreamController,
									subtitleTrackController: o.default,
									timelineController: u.TimelineController,
									audioStreamController: i.default,
									audioTrackController: s.default,
									emeController: f.default,
									cmcdController: h.default
								});

								function A(e, t) {
									if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
									if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
									if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
									return b({}, e, t)
								}

								function L(e) {
									var t = e.loader;
									t !== v.default && t !== g.default ? (y.logger.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1) : Object(v.fetchSupported)() && (e.loader = v.default, e.progressive = !0, e.enableSoftwareAES = !0, y.logger.log("[config]: Progressive streaming enabled, using FetchLoader"))
								}
							},
							"./src/controller/abr-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/utils/ewma-bandwidth-estimator.ts"),
									s = r("./src/events.ts"),
									a = r("./src/utils/buffer-helper.ts"),
									o = r("./src/errors.ts"),
									l = r("./src/types/loader.ts"),
									u = r("./src/utils/logger.ts");

								function c(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var d = function() {
									function e(e) {
										this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = e;
										var t = e.config;
										this.bwEstimator = new i.default(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate), this.registerListeners()
									}
									var t, r, d, f = e.prototype;
									return f.registerListeners = function() {
										var e = this.hls;
										e.on(s.Events.FRAG_LOADING, this.onFragLoading, this), e.on(s.Events.FRAG_LOADED, this.onFragLoaded, this), e.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.on(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(s.Events.ERROR, this.onError, this)
									}, f.unregisterListeners = function() {
										var e = this.hls;
										e.off(s.Events.FRAG_LOADING, this.onFragLoading, this), e.off(s.Events.FRAG_LOADED, this.onFragLoaded, this), e.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.off(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(s.Events.ERROR, this.onError, this)
									}, f.destroy = function() {
										this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null
									}, f.onFragLoading = function(e, t) {
										var r, n = t.frag;
										n.type === l.PlaylistLevelType.MAIN && (this.timer || (this.fragCurrent = n, this.partCurrent = null != (r = t.part) ? r : null, this.timer = self.setInterval(this.onCheck, 100)))
									}, f.onLevelLoaded = function(e, t) {
										var r = this.hls.config;
										t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD)
									}, f._abandonRulesCheck = function() {
										var e = this.fragCurrent,
											t = this.partCurrent,
											r = this.hls,
											i = r.autoLevelEnabled,
											o = r.config,
											l = r.media;
										if (e && l) {
											var c = t ? t.stats : e.stats,
												d = t ? t.duration : e.duration;
											if (c.aborted) return u.logger.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer(), void(this._nextAutoLevel = -1);
											if (i && !l.paused && l.playbackRate && l.readyState) {
												var f = performance.now() - c.loading.start,
													h = Math.abs(l.playbackRate);
												if (!(f <= 500 * d / h)) {
													var g = r.levels,
														v = r.minAutoLevel,
														p = g[e.level],
														m = c.total || Math.max(c.loaded, Math.round(d * p.maxBitrate / 8)),
														y = Math.max(1, c.bwEstimate ? c.bwEstimate / 8 : 1e3 * c.loaded / f),
														b = (m - c.loaded) / y,
														E = l.currentTime,
														_ = (a.BufferHelper.bufferInfo(l, E, o.maxBufferHole)
															.end - E) / h;
													if (!(_ >= 2 * d / h || b <= _)) {
														var T, S = Number.POSITIVE_INFINITY;
														for (T = e.level - 1; T > v && !((S = d * g[T].maxBitrate / (6.4 * y)) < _); T--);
														if (!(S >= b)) {
															var A = this.bwEstimator.getEstimate();
															u.logger.warn("Fragment " + e.sn + (t ? " part " + t.index : "") + " of level " + e.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + T + "\n      Current BW estimate: " + (Object(n.isFiniteNumber)(A) ? (A / 1024)
																.toFixed(3) : "Unknown") + " Kb/s\n      Estimated load time for current fragment: " + b.toFixed(3) + " s\n      Estimated load time for the next fragment: " + S.toFixed(3) + " s\n      Time to underbuffer: " + _.toFixed(3) + " s"), r.nextLoadLevel = T, this.bwEstimator.sample(f, c.loaded), this.clearTimer(), e.loader && (this.fragCurrent = this.partCurrent = null, e.loader.abort()), r.trigger(s.Events.FRAG_LOAD_EMERGENCY_ABORTED, {
																frag: e,
																part: t,
																stats: c
															})
														}
													}
												}
											}
										}
									}, f.onFragLoaded = function(e, t) {
										var r = t.frag,
											i = t.part;
										if (r.type === l.PlaylistLevelType.MAIN && Object(n.isFiniteNumber)(r.sn)) {
											var a = i ? i.stats : r.stats,
												o = i ? i.duration : r.duration;
											if (this.clearTimer(), this.lastLoadedFragLevel = r.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
												var u = this.hls.levels[r.level],
													c = (u.loaded ? u.loaded.bytes : 0) + a.loaded,
													d = (u.loaded ? u.loaded.duration : 0) + o;
												u.loaded = {
													bytes: c,
													duration: d
												}, u.realBitrate = Math.round(8 * c / d)
											}
											if (r.bitrateTest) {
												var f = {
													stats: a,
													frag: r,
													part: i,
													id: r.type
												};
												this.onFragBuffered(s.Events.FRAG_BUFFERED, f), r.bitrateTest = !1
											}
										}
									}, f.onFragBuffered = function(e, t) {
										var r = t.frag,
											n = t.part,
											i = n ? n.stats : r.stats;
										if (!i.aborted && r.type === l.PlaylistLevelType.MAIN && "initSegment" !== r.sn) {
											var s = i.parsing.end - i.loading.start;
											this.bwEstimator.sample(s, i.loaded), i.bwEstimate = this.bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = s / 1e3 : this.bitrateTestDelay = 0
										}
									}, f.onError = function(e, t) {
										switch (t.details) {
											case o.ErrorDetails.FRAG_LOAD_ERROR:
											case o.ErrorDetails.FRAG_LOAD_TIMEOUT:
												this.clearTimer()
										}
									}, f.clearTimer = function() {
										self.clearInterval(this.timer), this.timer = void 0
									}, f.getNextABRAutoLevel = function() {
										var e = this.fragCurrent,
											t = this.partCurrent,
											r = this.hls,
											n = r.maxAutoLevel,
											i = r.config,
											s = r.minAutoLevel,
											o = r.media,
											l = t ? t.duration : e ? e.duration : 0,
											c = o ? o.currentTime : 0,
											d = o && 0 !== o.playbackRate ? Math.abs(o.playbackRate) : 1,
											f = this.bwEstimator ? this.bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate,
											h = (a.BufferHelper.bufferInfo(o, c, i.maxBufferHole)
												.end - c) / d,
											g = this.findBestLevel(f, s, n, h, i.abrBandWidthFactor, i.abrBandWidthUpFactor);
										if (g >= 0) return g;
										u.logger.trace((h ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
										var v = l ? Math.min(l, i.maxStarvationDelay) : i.maxStarvationDelay,
											p = i.abrBandWidthFactor,
											m = i.abrBandWidthUpFactor;
										if (!h) {
											var y = this.bitrateTestDelay;
											y && (v = (l ? Math.min(l, i.maxLoadingDelay) : i.maxLoadingDelay) - y, u.logger.trace("bitrate test took " + Math.round(1e3 * y) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * v) + " ms"), p = m = 1)
										}
										return g = this.findBestLevel(f, s, n, h + v, p, m), Math.max(g, 0)
									}, f.findBestLevel = function(e, t, r, n, i, s) {
										for (var a, o = this.fragCurrent, l = this.partCurrent, c = this.lastLoadedFragLevel, d = this.hls.levels, f = d[c], h = !(null == f || null === (a = f.details) || void 0 === a || !a.live), g = null == f ? void 0 : f.codecSet, v = l ? l.duration : o ? o.duration : 0, p = r; p >= t; p--) {
											var m = d[p];
											if (m && (!g || m.codecSet === g)) {
												var y = m.details,
													b = (l ? null == y ? void 0 : y.partTarget : null == y ? void 0 : y.averagetargetduration) || v,
													E = void 0;
												E = p <= c ? i * e : s * e;
												var _ = d[p].maxBitrate,
													T = _ * b / E;
												if (u.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + p + "/" + Math.round(E) + "/" + _ + "/" + b + "/" + n + "/" + T), E > _ && (!T || h && !this.bitrateTestDelay || T < n)) return p
											}
										}
										return -1
									}, t = e, (r = [{
										key: "nextAutoLevel",
										get: function() {
											var e = this._nextAutoLevel,
												t = this.bwEstimator;
											if (!(-1 === e || t && t.canEstimate())) return e;
											var r = this.getNextABRAutoLevel();
											return -1 !== e && (r = Math.min(e, r)), r
										},
										set: function(e) {
											this._nextAutoLevel = e
										}
									}]) && c(t.prototype, r), d && c(t, d), e
								}();
								t.default = d
							},
							"./src/controller/audio-stream-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/controller/base-stream-controller.ts"),
									s = r("./src/events.ts"),
									a = r("./src/utils/buffer-helper.ts"),
									o = r("./src/controller/fragment-tracker.ts"),
									l = r("./src/types/level.ts"),
									u = r("./src/types/loader.ts"),
									c = r("./src/loader/fragment.ts"),
									d = r("./src/demux/chunk-cache.ts"),
									f = r("./src/demux/transmuxer-interface.ts"),
									h = r("./src/types/transmuxer.ts"),
									g = r("./src/controller/fragment-finders.ts"),
									v = r("./src/utils/discontinuities.ts"),
									p = r("./src/errors.ts"),
									m = r("./src/utils/logger.ts");

								function y() {
									return y = Object.assign || function(e) {
										for (var t = 1; t < arguments.length; t++) {
											var r = arguments[t];
											for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
										}
										return e
									}, y.apply(this, arguments)
								}

								function b(e, t) {
									return b = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, b(e, t)
								}
								var E = function(e) {
									var t, r;

									function E(t, r) {
										var n;
										return (n = e.call(this, t, r, "[audio-stream-controller]") || this)
											.videoBuffer = null, n.videoTrackCC = -1, n.waitingVideoCC = -1, n.audioSwitch = !1, n.trackId = -1, n.waitingData = null, n.mainDetails = null, n.bufferFlushed = !1, n._registerListeners(), n
									}
									r = e, (t = E)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, b(t, r);
									var _ = E.prototype;
									return _.onHandlerDestroying = function() {
										this._unregisterListeners(), this.mainDetails = null
									}, _._registerListeners = function() {
										var e = this.hls;
										e.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(s.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(s.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(s.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(s.Events.ERROR, this.onError, this), e.on(s.Events.BUFFER_RESET, this.onBufferReset, this), e.on(s.Events.BUFFER_CREATED, this.onBufferCreated, this), e.on(s.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(s.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
									}, _._unregisterListeners = function() {
										var e = this.hls;
										e.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(s.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(s.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(s.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(s.Events.ERROR, this.onError, this), e.off(s.Events.BUFFER_RESET, this.onBufferReset, this), e.off(s.Events.BUFFER_CREATED, this.onBufferCreated, this), e.off(s.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(s.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
									}, _.onInitPtsFound = function(e, t) {
										var r = t.frag,
											n = t.id,
											s = t.initPTS;
										if ("main" === n) {
											var a = r.cc;
											this.initPTS[r.cc] = s, this.log("InitPTS for cc: " + a + " found from main: " + s), this.videoTrackCC = a, this.state === i.State.WAITING_INIT_PTS && this.tick()
										}
									}, _.startLoad = function(e) {
										if (!this.levels) return this.startPosition = e, void(this.state = i.State.STOPPED);
										var t = this.lastCurrentTime;
										this.stopLoad(), this.setInterval(100), this.fragLoadError = 0, t > 0 && -1 === e ? (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)), this.state = i.State.IDLE) : (this.loadedmetadata = !1, this.state = i.State.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
									}, _.doTick = function() {
										switch (this.state) {
											case i.State.IDLE:
												this.doTickIdle();
												break;
											case i.State.WAITING_TRACK:
												var t, r = this.levels,
													n = this.trackId,
													s = null == r || null === (t = r[n]) || void 0 === t ? void 0 : t.details;
												if (s) {
													if (this.waitForCdnTuneIn(s)) break;
													this.state = i.State.WAITING_INIT_PTS
												}
												break;
											case i.State.FRAG_LOADING_WAITING_RETRY:
												var o, l = performance.now(),
													u = this.retryDate;
												(!u || l >= u || null !== (o = this.media) && void 0 !== o && o.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.state = i.State.IDLE);
												break;
											case i.State.WAITING_INIT_PTS:
												var c = this.waitingData;
												if (c) {
													var d = c.frag,
														f = c.part,
														h = c.cache,
														v = c.complete;
													if (void 0 !== this.initPTS[d.cc]) {
														this.waitingData = null, this.waitingVideoCC = -1, this.state = i.State.FRAG_LOADING;
														var p = {
															frag: d,
															part: f,
															payload: h.flush(),
															networkDetails: null
														};
														this._handleFragmentLoadProgress(p), v && e.prototype._handleFragmentLoadComplete.call(this, p)
													} else if (this.videoTrackCC !== this.waitingVideoCC) m.logger.log("Waiting fragment cc (" + d.cc + ") cancelled because video is at cc " + this.videoTrackCC), this.clearWaitingFragment();
													else {
														var y = this.getLoadPosition(),
															b = a.BufferHelper.bufferInfo(this.mediaBuffer, y, this.config.maxBufferHole);
														Object(g.fragmentWithinToleranceTest)(b.end, this.config.maxFragLookUpTolerance, d) < 0 && (m.logger.log("Waiting fragment cc (" + d.cc + ") @ " + d.start + " cancelled because another fragment at " + b.end + " is needed"), this.clearWaitingFragment())
													}
												} else this.state = i.State.IDLE
										}
										this.onTickEnd()
									}, _.clearWaitingFragment = function() {
										var e = this.waitingData;
										e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = i.State.IDLE)
									}, _.onTickEnd = function() {
										var e = this.media;
										if (e && e.readyState) {
											var t = (this.mediaBuffer ? this.mediaBuffer : e)
												.buffered;
											!this.loadedmetadata && t.length && (this.loadedmetadata = !0), this.lastCurrentTime = e.currentTime
										}
									}, _.doTickIdle = function() {
										var e, t, r = this.hls,
											n = this.levels,
											a = this.media,
											o = this.trackId,
											l = r.config;
										if (n && n[o] && (a || !this.startFragRequested && l.startFragPrefetch)) {
											var d = n[o].details;
											if (!d || d.live && this.levelLastLoaded !== o || this.waitForCdnTuneIn(d)) this.state = i.State.WAITING_TRACK;
											else {
												this.bufferFlushed && (this.bufferFlushed = !1, this.afterBufferFlushed(this.mediaBuffer ? this.mediaBuffer : this.media, c.ElementaryStreamTypes.AUDIO, u.PlaylistLevelType.AUDIO));
												var f = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, u.PlaylistLevelType.AUDIO);
												if (null !== f) {
													var h = f.len,
														g = this.getMaxBufferLength(),
														v = this.audioSwitch;
													if (!(h >= g) || v) {
														if (!v && this._streamEnded(f, d)) return r.trigger(s.Events.BUFFER_EOS, {
															type: "audio"
														}), void(this.state = i.State.ENDED);
														var p = d.fragments[0].start,
															m = f.end;
														if (v) {
															var y = this.getLoadPosition();
															m = y, d.PTSKnown && y < p && (f.end > p || f.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), a.currentTime = p + .05)
														}
														var b = this.getNextFragment(m, d);
														b ? "identity" !== (null === (e = b.decryptdata) || void 0 === e ? void 0 : e.keyFormat) || null !== (t = b.decryptdata) && void 0 !== t && t.key ? this.loadFragment(b, d, m) : this.loadKey(b, d) : this.bufferFlushed = !0
													}
												}
											}
										}
									}, _.getMaxBufferLength = function() {
										var t = e.prototype.getMaxBufferLength.call(this),
											r = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, u.PlaylistLevelType.MAIN);
										return null === r ? t : Math.max(t, r.len)
									}, _.onMediaDetaching = function() {
										this.videoBuffer = null, e.prototype.onMediaDetaching.call(this)
									}, _.onAudioTracksUpdated = function(e, t) {
										var r = t.audioTracks;
										this.resetTransmuxer(), this.levels = r.map((function(e) {
											return new l.Level(e)
										}))
									}, _.onAudioTrackSwitching = function(e, t) {
										var r = !!t.url;
										this.trackId = t.id;
										var n = this.fragCurrent;
										null != n && n.loader && n.loader.abort(), this.fragCurrent = null, this.clearWaitingFragment(), r ? this.setInterval(100) : this.resetTransmuxer(), r ? (this.audioSwitch = !0, this.state = i.State.IDLE) : this.state = i.State.STOPPED, this.tick()
									}, _.onManifestLoading = function() {
										this.mainDetails = null, this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1
									}, _.onLevelLoaded = function(e, t) {
										this.mainDetails = t.details
									}, _.onAudioTrackLoaded = function(e, t) {
										var r, n = this.levels,
											s = t.details,
											a = t.id;
										if (n) {
											this.log("Track " + a + " loaded [" + s.startSN + "," + s.endSN + "],duration:" + s.totalduration);
											var o = n[a],
												l = 0;
											if (s.live || null !== (r = o.details) && void 0 !== r && r.live) {
												var u = this.mainDetails;
												if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed || !u) return;
												!o.details && s.hasProgramDateTime && u.hasProgramDateTime ? (Object(v.alignMediaPlaylistByPDT)(s, u), l = s.fragments[0].start) : l = this.alignPlaylists(s, o.details)
											}
											o.details = s, this.levelLastLoaded = a, this.startFragRequested || !this.mainDetails && s.live || this.setStartPosition(o.details, l), this.state !== i.State.WAITING_TRACK || this.waitForCdnTuneIn(s) || (this.state = i.State.IDLE), this.tick()
										} else this.warn("Audio tracks were reset while loading level " + a)
									}, _._handleFragmentLoadProgress = function(e) {
										var t, r = e.frag,
											n = e.part,
											s = e.payload,
											a = this.config,
											o = this.trackId,
											l = this.levels;
										if (l) {
											var c = l[o];
											console.assert(c, "Audio track is defined on fragment load progress");
											var g = c.details;
											console.assert(g, "Audio track details are defined on fragment load progress");
											var v = a.defaultAudioCodec || c.audioCodec || "mp4a.40.2",
												p = this.transmuxer;
											p || (p = this.transmuxer = new f.default(this.hls, u.PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
											var y = this.initPTS[r.cc],
												b = null === (t = r.initSegment) || void 0 === t ? void 0 : t.data;
											if (void 0 !== y) {
												var E = n ? n.index : -1,
													_ = -1 !== E,
													T = new h.ChunkMetadata(r.level, r.sn, r.stats.chunkCount, s.byteLength, E, _);
												p.push(s, b, v, "", r, n, g.totalduration, !1, T, y)
											} else m.logger.log("Unknown video PTS for cc " + r.cc + ", waiting for video PTS before demuxing audio frag " + r.sn + " of [" + g.startSN + " ," + g.endSN + "],track " + o), (this.waitingData = this.waitingData || {
													frag: r,
													part: n,
													cache: new d.default,
													complete: !1
												})
												.cache.push(new Uint8Array(s)), this.waitingVideoCC = this.videoTrackCC, this.state = i.State.WAITING_INIT_PTS
										} else this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + r.sn + " of level " + r.level + " will not be buffered")
									}, _._handleFragmentLoadComplete = function(t) {
										this.waitingData ? this.waitingData.complete = !0 : e.prototype._handleFragmentLoadComplete.call(this, t)
									}, _.onBufferReset = function() {
										this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
									}, _.onBufferCreated = function(e, t) {
										var r = t.tracks.audio;
										r && (this.mediaBuffer = r.buffer), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer)
									}, _.onFragBuffered = function(e, t) {
										var r = t.frag,
											n = t.part;
										r.type === u.PlaylistLevelType.AUDIO && (this.fragContextChanged(r) ? this.warn("Fragment " + r.sn + (n ? " p: " + n.index : "") + " of level " + r.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch) : ("initSegment" !== r.sn && (this.fragPrevious = r, this.audioSwitch && (this.audioSwitch = !1, this.hls.trigger(s.Events.AUDIO_TRACK_SWITCHED, {
											id: this.trackId
										}))), this.fragBufferedComplete(r, n)))
									}, _.onError = function(t, r) {
										switch (r.details) {
											case p.ErrorDetails.FRAG_LOAD_ERROR:
											case p.ErrorDetails.FRAG_LOAD_TIMEOUT:
											case p.ErrorDetails.KEY_LOAD_ERROR:
											case p.ErrorDetails.KEY_LOAD_TIMEOUT:
												this.onFragmentOrKeyLoadError(u.PlaylistLevelType.AUDIO, r);
												break;
											case p.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
											case p.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
												this.state !== i.State.ERROR && this.state !== i.State.STOPPED && (this.state = r.fatal ? i.State.ERROR : i.State.IDLE, this.warn(r.details + " while loading frag, switching to " + this.state + " state"));
												break;
											case p.ErrorDetails.BUFFER_FULL_ERROR:
												if ("audio" === r.parent && (this.state === i.State.PARSING || this.state === i.State.PARSED)) {
													var n = !0,
														s = this.getFwdBufferInfo(this.mediaBuffer, u.PlaylistLevelType.AUDIO);
													s && s.len > .5 && (n = !this.reduceMaxBufferLength(s.len)), n && (this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, e.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.resetLoadingState()
												}
										}
									}, _.onBufferFlushed = function(e, t) {
										t.type === c.ElementaryStreamTypes.AUDIO && (this.bufferFlushed = !0)
									}, _._handleTransmuxComplete = function(e) {
										var t, r = "audio",
											n = this.hls,
											a = e.remuxResult,
											o = e.chunkMeta,
											l = this.getCurrentContext(o);
										if (!l) return this.warn("The loading context changed while buffering fragment " + o.sn + " of level " + o.level + ". This chunk will not be buffered."), void this.resetLiveStartWhenNotLoaded(o.level);
										var u = l.frag,
											d = l.part,
											f = a.audio,
											h = a.text,
											g = a.id3,
											v = a.initSegment;
										if (!this.fragContextChanged(u)) {
											if (this.state = i.State.PARSING, this.audioSwitch && f && this.completeAudioSwitch(), null != v && v.tracks && (this._bufferInitSegment(v.tracks, u, o), n.trigger(s.Events.FRAG_PARSING_INIT_SEGMENT, {
												frag: u,
												id: r,
												tracks: v.tracks
											})), f) {
												var p = f.startPTS,
													m = f.endPTS,
													b = f.startDTS,
													E = f.endDTS;
												d && (d.elementaryStreams[c.ElementaryStreamTypes.AUDIO] = {
													startPTS: p,
													endPTS: m,
													startDTS: b,
													endDTS: E
												}), u.setElementaryStreamInfo(c.ElementaryStreamTypes.AUDIO, p, m, b, E), this.bufferFragmentData(f, u, d, o)
											}
											if (null != g && null !== (t = g.samples) && void 0 !== t && t.length) {
												var _ = y({
													frag: u,
													id: r
												}, g);
												n.trigger(s.Events.FRAG_PARSING_METADATA, _)
											}
											if (h) {
												var T = y({
													frag: u,
													id: r
												}, h);
												n.trigger(s.Events.FRAG_PARSING_USERDATA, T)
											}
										}
									}, _._bufferInitSegment = function(e, t, r) {
										if (this.state === i.State.PARSING) {
											e.video && delete e.video;
											var n = e.audio;
											if (n) {
												n.levelCodec = n.codec, n.id = "audio", this.log("Init audio buffer, container:" + n.container + ", codecs[parsed]=[" + n.codec + "]"), this.hls.trigger(s.Events.BUFFER_CODECS, e);
												var a = n.initSegment;
												if (null != a && a.byteLength) {
													var o = {
														type: "audio",
														frag: t,
														part: null,
														chunkMeta: r,
														parent: t.type,
														data: a
													};
													this.hls.trigger(s.Events.BUFFER_APPENDING, o)
												}
												this.tick()
											}
										}
									}, _.loadFragment = function(t, r, s) {
										var a = this.fragmentTracker.getState(t);
										this.fragCurrent = t, (this.audioSwitch || a === o.FragmentState.NOT_LOADED || a === o.FragmentState.PARTIAL) && ("initSegment" === t.sn ? this._loadInitSegment(t) : r.live && !Object(n.isFiniteNumber)(this.initPTS[t.cc]) ? (this.log("Waiting for video PTS in continuity counter " + t.cc + " of live stream before loading audio fragment " + t.sn + " of level " + this.trackId), this.state = i.State.WAITING_INIT_PTS) : (this.startFragRequested = !0, e.prototype.loadFragment.call(this, t, r, s)))
									}, _.completeAudioSwitch = function() {
										var t = this.hls,
											r = this.media,
											n = this.trackId;
										r && (this.log("Switching audio track : flushing all audio"), e.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.audioSwitch = !1, t.trigger(s.Events.AUDIO_TRACK_SWITCHED, {
											id: n
										})
									}, E
								}(i.default);
								t.default = E
							},
							"./src/controller/audio-track-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/events.ts"),
									i = r("./src/errors.ts"),
									s = r("./src/controller/base-playlist-controller.ts"),
									a = r("./src/types/loader.ts");

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function l(e, t) {
									return l = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, l(e, t)
								}
								var u = function(e) {
									var t, r;

									function s(t) {
										var r;
										return (r = e.call(this, t, "[audio-track-controller]") || this)
											.tracks = [], r.groupId = null, r.tracksInGroup = [], r.trackId = -1, r.trackName = "", r.selectDefaultTrack = !0, r.registerListeners(), r
									}
									r = e, (t = s)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, l(t, r);
									var u, c, d, f = s.prototype;
									return f.registerListeners = function() {
										var e = this.hls;
										e.on(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(n.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(n.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(n.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(n.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(n.Events.ERROR, this.onError, this)
									}, f.unregisterListeners = function() {
										var e = this.hls;
										e.off(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(n.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(n.Events.LEVEL_LOADING, this.onLevelLoading, this), e.off(n.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(n.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(n.Events.ERROR, this.onError, this)
									}, f.destroy = function() {
										this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, e.prototype.destroy.call(this)
									}, f.onManifestLoading = function() {
										this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.trackName = "", this.selectDefaultTrack = !0
									}, f.onManifestParsed = function(e, t) {
										this.tracks = t.audioTracks || []
									}, f.onAudioTrackLoaded = function(e, t) {
										var r = t.id,
											n = t.details,
											i = this.tracksInGroup[r];
										if (i) {
											var s = i.details;
											i.details = t.details, this.log("audioTrack " + r + " loaded [" + n.startSN + "-" + n.endSN + "]"), r === this.trackId && (this.retryCount = 0, this.playlistLoaded(r, t, s))
										} else this.warn("Invalid audio track id " + r)
									}, f.onLevelLoading = function(e, t) {
										this.switchLevel(t.level)
									}, f.onLevelSwitching = function(e, t) {
										this.switchLevel(t.level)
									}, f.switchLevel = function(e) {
										var t = this.hls.levels[e];
										if (null != t && t.audioGroupIds) {
											var r = t.audioGroupIds[t.urlId];
											if (this.groupId !== r) {
												this.groupId = r;
												var i = this.tracks.filter((function(e) {
													return !r || e.groupId === r
												}));
												this.selectDefaultTrack && !i.some((function(e) {
													return e.default
												})) && (this.selectDefaultTrack = !1), this.tracksInGroup = i;
												var s = {
													audioTracks: i
												};
												this.log("Updating audio tracks, " + i.length + ' track(s) found in "' + r + '" group-id'), this.hls.trigger(n.Events.AUDIO_TRACKS_UPDATED, s), this.selectInitialTrack()
											}
										}
									}, f.onError = function(t, r) {
										e.prototype.onError.call(this, t, r), !r.fatal && r.context && r.context.type === a.PlaylistContextType.AUDIO_TRACK && r.context.id === this.trackId && r.context.groupId === this.groupId && this.retryLoadingOrFail(r)
									}, f.setAudioTrack = function(e) {
										var t = this.tracksInGroup;
										if (e < 0 || e >= t.length) this.warn("Invalid id passed to audio-track controller");
										else {
											this.clearTimer();
											var r = t[this.trackId];
											this.log("Now switching to audio-track index " + e);
											var i = t[e],
												s = i.id,
												a = i.groupId,
												o = void 0 === a ? "" : a,
												l = i.name,
												u = i.type,
												c = i.url;
											if (this.trackId = e, this.trackName = l, this.selectDefaultTrack = !1, this.hls.trigger(n.Events.AUDIO_TRACK_SWITCHING, {
												id: s,
												groupId: o,
												name: l,
												type: u,
												url: c
											}), !i.details || i.details.live) {
												var d = this.switchParams(i.url, null == r ? void 0 : r.details);
												this.loadPlaylist(d)
											}
										}
									}, f.selectInitialTrack = function() {
										var e = this.tracksInGroup;
										console.assert(e.length, "Initial audio track should be selected when tracks are known");
										var t = this.trackName,
											r = this.findTrackId(t) || this.findTrackId(); - 1 !== r ? this.setAudioTrack(r) : (this.warn("No track found for running audio group-ID: " + this.groupId), this.hls.trigger(n.Events.ERROR, {
											type: i.ErrorTypes.MEDIA_ERROR,
											details: i.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
											fatal: !0
										}))
									}, f.findTrackId = function(e) {
										for (var t = this.tracksInGroup, r = 0; r < t.length; r++) {
											var n = t[r];
											if ((!this.selectDefaultTrack || n.default) && (!e || e === n.name)) return n.id
										}
										return -1
									}, f.loadPlaylist = function(e) {
										var t = this.tracksInGroup[this.trackId];
										if (this.shouldLoadTrack(t)) {
											var r = t.id,
												i = t.groupId,
												s = t.url;
											if (e) try {
												s = e.addDirectives(s)
											} catch (e) {
												this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
											}
											this.log("loading audio-track playlist for id: " + r), this.clearTimer(), this.hls.trigger(n.Events.AUDIO_TRACK_LOADING, {
												url: s,
												id: r,
												groupId: i,
												deliveryDirectives: e || null
											})
										}
									}, u = s, (c = [{
										key: "audioTracks",
										get: function() {
											return this.tracksInGroup
										}
									}, {
										key: "audioTrack",
										get: function() {
											return this.trackId
										},
										set: function(e) {
											this.selectDefaultTrack = !1, this.setAudioTrack(e)
										}
									}]) && o(u.prototype, c), d && o(u, d), s
								}(s.default);
								t.default = u
							},
							"./src/controller/base-playlist-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return l
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/types/level.ts"),
									s = r("./src/controller/level-helper.ts"),
									a = r("./src/utils/logger.ts"),
									o = r("./src/errors.ts"),
									l = function() {
										function e(e, t) {
											this.hls = void 0, this.timer = -1, this.canLoad = !1, this.retryCount = 0, this.log = void 0, this.warn = void 0, this.log = a.logger.log.bind(a.logger, t + ":"), this.warn = a.logger.warn.bind(a.logger, t + ":"), this.hls = e
										}
										var t = e.prototype;
										return t.destroy = function() {
											this.clearTimer(), this.hls = this.log = this.warn = null
										}, t.onError = function(e, t) {
											t.fatal && t.type === o.ErrorTypes.NETWORK_ERROR && this.clearTimer()
										}, t.clearTimer = function() {
											clearTimeout(this.timer), this.timer = -1
										}, t.startLoad = function() {
											this.canLoad = !0, this.retryCount = 0, this.loadPlaylist()
										}, t.stopLoad = function() {
											this.canLoad = !1, this.clearTimer()
										}, t.switchParams = function(e, t) {
											var r = null == t ? void 0 : t.renditionReports;
											if (r)
												for (var s = 0; s < r.length; s++) {
													var a = r[s],
														o = "" + a.URI;
													if (o === e.substr(-o.length)) {
														var l = parseInt(a["LAST-MSN"]),
															u = parseInt(a["LAST-PART"]);
														if (t && this.hls.config.lowLatencyMode) {
															var c = Math.min(t.age - t.partTarget, t.targetduration);
															void 0 !== u && c > t.partTarget && (u += 1)
														}
														if (Object(n.isFiniteNumber)(l)) return new i.HlsUrlParameters(l, Object(n.isFiniteNumber)(u) ? u : void 0, i.HlsSkip.No)
													}
												}
										}, t.loadPlaylist = function(e) {}, t.shouldLoadTrack = function(e) {
											return this.canLoad && e && !!e.url && (!e.details || e.details.live)
										}, t.playlistLoaded = function(e, t, r) {
											var n = this,
												i = t.details,
												a = t.stats,
												o = a.loading.end ? Math.max(0, self.performance.now() - a.loading.end) : 0;
											if (i.advancedDateTime = Date.now() - o, i.live || null != r && r.live) {
												if (i.reloaded(r), r && this.log("live playlist " + e + " " + (i.advanced ? "REFRESHED " + i.lastPartSn + "-" + i.lastPartIndex : "MISSED")), r && i.fragments.length > 0 && Object(s.mergeDetails)(r, i), !this.canLoad || !i.live) return;
												var l, u = void 0,
													c = void 0;
												if (i.canBlockReload && i.endSN && i.advanced) {
													var d = this.hls.config.lowLatencyMode,
														f = i.lastPartSn,
														h = i.endSN,
														g = i.lastPartIndex,
														v = f === h; - 1 !== g ? (u = v ? h + 1 : f, c = v ? d ? 0 : g : g + 1) : u = h + 1;
													var p = i.age,
														m = p + i.ageHeader,
														y = Math.min(m - i.partTarget, 1.5 * i.targetduration);
													if (y > 0) {
														if (r && y > r.tuneInGoal) this.warn("CDN Tune-in goal increased from: " + r.tuneInGoal + " to: " + y + " with playlist age: " + i.age), y = 0;
														else {
															var b = Math.floor(y / i.targetduration);
															u += b, void 0 !== c && (c += Math.round(y % i.targetduration / i.partTarget)), this.log("CDN Tune-in age: " + i.ageHeader + "s last advanced " + p.toFixed(2) + "s goal: " + y + " skip sn " + b + " to part " + c)
														}
														i.tuneInGoal = y
													}
													if (l = this.getDeliveryDirectives(i, t.deliveryDirectives, u, c), d || !v) return void this.loadPlaylist(l)
												} else l = this.getDeliveryDirectives(i, t.deliveryDirectives, u, c);
												var E = Object(s.computeReloadInterval)(i, a);
												void 0 !== u && i.canBlockReload && (E -= i.partTarget || 1), this.log("reload live playlist " + e + " in " + Math.round(E) + " ms"), this.timer = self.setTimeout((function() {
													return n.loadPlaylist(l)
												}), E)
											} else this.clearTimer()
										}, t.getDeliveryDirectives = function(e, t, r, n) {
											var s = Object(i.getSkipValue)(e, r);
											return null != t && t.skip && e.deltaUpdateFailed && (r = t.msn, n = t.part, s = i.HlsSkip.No), new i.HlsUrlParameters(r, n, s)
										}, t.retryLoadingOrFail = function(e) {
											var t, r = this,
												n = this.hls.config,
												i = this.retryCount < n.levelLoadingMaxRetry;
											if (i)
												if (this.retryCount++, e.details.indexOf("LoadTimeOut") > -1 && null !== (t = e.context) && void 0 !== t && t.deliveryDirectives) this.warn("retry playlist loading #" + this.retryCount + ' after "' + e.details + '"'), this.loadPlaylist();
												else {
													var s = Math.min(Math.pow(2, this.retryCount) * n.levelLoadingRetryDelay, n.levelLoadingMaxRetryTimeout);
													this.timer = self.setTimeout((function() {
														return r.loadPlaylist()
													}), s), this.warn("retry playlist loading #" + this.retryCount + " in " + s + ' ms after "' + e.details + '"')
												}
											else this.warn('cannot recover from error "' + e.details + '"'), this.clearTimer(), e.fatal = !0;
											return i
										}, e
									}()
							},
							"./src/controller/base-stream-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "State", (function() {
									return _
								})), r.d(t, "default", (function() {
									return T
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/task-loop.ts"),
									s = r("./src/controller/fragment-tracker.ts"),
									a = r("./src/utils/buffer-helper.ts"),
									o = r("./src/utils/logger.ts"),
									l = r("./src/events.ts"),
									u = r("./src/errors.ts"),
									c = r("./src/types/transmuxer.ts"),
									d = r("./src/utils/mp4-tools.ts"),
									f = r("./src/utils/discontinuities.ts"),
									h = r("./src/controller/fragment-finders.ts"),
									g = r("./src/controller/level-helper.ts"),
									v = r("./src/loader/fragment-loader.ts"),
									p = r("./src/crypt/decrypter.ts"),
									m = r("./src/utils/time-ranges.ts"),
									y = r("./src/types/loader.ts");

								function b(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function E(e, t) {
									return E = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, E(e, t)
								}
								var _ = {
										STOPPED: "STOPPED",
										IDLE: "IDLE",
										KEY_LOADING: "KEY_LOADING",
										FRAG_LOADING: "FRAG_LOADING",
										FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
										WAITING_TRACK: "WAITING_TRACK",
										PARSING: "PARSING",
										PARSED: "PARSED",
										BACKTRACKING: "BACKTRACKING",
										ENDED: "ENDED",
										ERROR: "ERROR",
										WAITING_INIT_PTS: "WAITING_INIT_PTS",
										WAITING_LEVEL: "WAITING_LEVEL"
									},
									T = function(e) {
										var t, r;

										function i(t, r, n) {
											var i;
											return (i = e.call(this) || this)
												.hls = void 0, i.fragPrevious = null, i.fragCurrent = null, i.fragmentTracker = void 0, i.transmuxer = null, i._state = _.STOPPED, i.media = void 0, i.mediaBuffer = void 0, i.config = void 0, i.bitrateTest = !1, i.lastCurrentTime = 0, i.nextLoadPosition = 0, i.startPosition = 0, i.loadedmetadata = !1, i.fragLoadError = 0, i.retryDate = 0, i.levels = null, i.fragmentLoader = void 0, i.levelLastLoaded = null, i.startFragRequested = !1, i.decrypter = void 0, i.initPTS = [], i.onvseeking = null, i.onvended = null, i.logPrefix = "", i.log = void 0, i.warn = void 0, i.logPrefix = n, i.log = o.logger.log.bind(o.logger, n + ":"), i.warn = o.logger.warn.bind(o.logger, n + ":"), i.hls = t, i.fragmentLoader = new v.default(t.config), i.fragmentTracker = r, i.config = t.config, i.decrypter = new p.default(t, t.config), t.on(l.Events.KEY_LOADED, i.onKeyLoaded, function(e) {
													if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
													return e
												}(i)), i
										}
										r = e, (t = i)
											.prototype = Object.create(r.prototype), t.prototype.constructor = t, E(t, r);
										var T, S, A, L = i.prototype;
										return L.doTick = function() {
											this.onTickEnd()
										}, L.onTickEnd = function() {}, L.startLoad = function(e) {}, L.stopLoad = function() {
											this.fragmentLoader.abort();
											var e = this.fragCurrent;
											e && this.fragmentTracker.removeFragment(e), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = _.STOPPED
										}, L._streamEnded = function(e, t) {
											var r = this.fragCurrent,
												n = this.fragmentTracker;
											if (!t.live && r && r.sn >= t.endSN && !e.nextStart) {
												var i = t.partList;
												if (null != i && i.length) {
													var o = i[i.length - 1];
													return a.BufferHelper.isBuffered(this.media, o.start + o.duration / 2)
												}
												var l = n.getState(r);
												return l === s.FragmentState.PARTIAL || l === s.FragmentState.OK
											}
											return !1
										}, L.onMediaAttached = function(e, t) {
											var r = this.media = this.mediaBuffer = t.media;
											this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener("seeking", this.onvseeking), r.addEventListener("ended", this.onvended);
											var n = this.config;
											this.levels && n.autoStartLoad && this.state === _.STOPPED && this.startLoad(n.startPosition)
										}, L.onMediaDetaching = function() {
											var e = this.media;
											null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
										}, L.onMediaSeeking = function() {
											var e = this.config,
												t = this.fragCurrent,
												r = this.media,
												i = this.mediaBuffer,
												s = this.state,
												o = r ? r.currentTime : 0,
												l = a.BufferHelper.bufferInfo(i || r, o, e.maxBufferHole);
											if (this.log("media seeking to " + (Object(n.isFiniteNumber)(o) ? o.toFixed(3) : o) + ", state: " + s), s === _.ENDED) this.resetLoadingState();
											else if (t && !l.len) {
												var u = e.maxFragLookUpTolerance,
													c = t.start - u,
													d = o > t.start + t.duration + u;
												(o < c || d) && (d && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.loader.abort()), this.resetLoadingState())
											}
											r && (this.lastCurrentTime = o), this.loadedmetadata || l.len || (this.nextLoadPosition = this.startPosition = o), this.tickImmediate()
										}, L.onMediaEnded = function() {
											this.startPosition = this.lastCurrentTime = 0
										}, L.onKeyLoaded = function(e, t) {
											if (this.state === _.KEY_LOADING && t.frag === this.fragCurrent && this.levels) {
												this.state = _.IDLE;
												var r = this.levels[t.frag.level].details;
												r && this.loadFragment(t.frag, r, t.frag.start)
											}
										}, L.onHandlerDestroying = function() {
											this.stopLoad(), e.prototype.onHandlerDestroying.call(this)
										}, L.onHandlerDestroyed = function() {
											this.state = _.STOPPED, this.hls.off(l.Events.KEY_LOADED, this.onKeyLoaded, this), this.fragmentLoader && this.fragmentLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null, e.prototype.onHandlerDestroyed.call(this)
										}, L.loadKey = function(e, t) {
											this.log("Loading key for " + e.sn + " of [" + t.startSN + "-" + t.endSN + "], " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + e.level), this.state = _.KEY_LOADING, this.fragCurrent = e, this.hls.trigger(l.Events.KEY_LOADING, {
												frag: e
											})
										}, L.loadFragment = function(e, t, r) {
											this._loadFragForPlayback(e, t, r)
										}, L._loadFragForPlayback = function(e, t, r) {
											var n = this;
											this._doFragLoad(e, t, r, (function(t) {
													if (n.fragContextChanged(e)) return n.warn("Fragment " + e.sn + (t.part ? " p: " + t.part.index : "") + " of level " + e.level + " was dropped during download."), void n.fragmentTracker.removeFragment(e);
													e.stats.chunkCount++, n._handleFragmentLoadProgress(t)
												}))
												.then((function(t) {
													if (t) {
														n.fragLoadError = 0;
														var r = n.state;
														if (!n.fragContextChanged(e)) return "payload" in t && (n.log("Loaded fragment " + e.sn + " of level " + e.level), n.hls.trigger(l.Events.FRAG_LOADED, t), n.state === _.BACKTRACKING) ? (n.fragmentTracker.backtrack(e, t), void n.resetFragmentLoading(e)) : void n._handleFragmentLoadComplete(t);
														(r === _.FRAG_LOADING || r === _.BACKTRACKING || !n.fragCurrent && r === _.PARSING) && (n.fragmentTracker.removeFragment(e), n.state = _.IDLE)
													}
												}))
												.catch((function(t) {
													n.warn(t), n.resetFragmentLoading(e)
												}))
										}, L.flushMainBuffer = function(e, t, r) {
											if (void 0 === r && (r = null), e - t) {
												var n = {
													startOffset: e,
													endOffset: t,
													type: r
												};
												this.fragLoadError = 0, this.hls.trigger(l.Events.BUFFER_FLUSHING, n)
											}
										}, L._loadInitSegment = function(e) {
											var t = this;
											this._doFragLoad(e)
												.then((function(r) {
													if (!r || t.fragContextChanged(e) || !t.levels) throw new Error("init load aborted");
													return r
												}))
												.then((function(r) {
													var n = t.hls,
														i = r.payload,
														s = e.decryptdata;
													if (i && i.byteLength > 0 && s && s.key && s.iv && "AES-128" === s.method) {
														var a = self.performance.now();
														return t.decrypter.webCryptoDecrypt(new Uint8Array(i), s.key.buffer, s.iv.buffer)
															.then((function(t) {
																var i = self.performance.now();
																return n.trigger(l.Events.FRAG_DECRYPTED, {
																	frag: e,
																	payload: t,
																	stats: {
																		tstart: a,
																		tdecrypt: i
																	}
																}), r.payload = t, r
															}))
													}
													return r
												}))
												.then((function(r) {
													var n = t.fragCurrent,
														i = t.hls,
														s = t.levels;
													if (!s) throw new Error("init load aborted, missing levels");
													var a = s[e.level].details;
													console.assert(a, "Level details are defined when init segment is loaded");
													var o = e.stats;
													t.state = _.IDLE, t.fragLoadError = 0, e.data = new Uint8Array(r.payload), o.parsing.start = o.buffering.start = self.performance.now(), o.parsing.end = o.buffering.end = self.performance.now(), r.frag === n && i.trigger(l.Events.FRAG_BUFFERED, {
														stats: o,
														frag: n,
														part: null,
														id: e.type
													}), t.tick()
												}))
												.catch((function(r) {
													t.warn(r), t.resetFragmentLoading(e)
												}))
										}, L.fragContextChanged = function(e) {
											var t = this.fragCurrent;
											return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId
										}, L.fragBufferedComplete = function(e, t) {
											var r = this.mediaBuffer ? this.mediaBuffer : this.media;
											this.log("Buffered " + e.type + " sn: " + e.sn + (t ? " part: " + t.index : "") + " of " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + e.level + " " + m.default.toString(a.BufferHelper.getBuffered(r))), this.state = _.IDLE, this.tick()
										}, L._handleFragmentLoadComplete = function(e) {
											var t = this.transmuxer;
											if (t) {
												var r = e.frag,
													n = e.part,
													i = e.partsLoaded,
													s = !i || 0 === i.length || i.some((function(e) {
														return !e
													})),
													a = new c.ChunkMetadata(r.level, r.sn, r.stats.chunkCount + 1, 0, n ? n.index : -1, !s);
												t.flush(a)
											}
										}, L._handleFragmentLoadProgress = function(e) {}, L._doFragLoad = function(e, t, r, i) {
											var s = this;
											if (void 0 === r && (r = null), !this.levels) throw new Error("frag load aborted, missing levels");
											if (r = Math.max(e.start, r || 0), this.config.lowLatencyMode && t) {
												var a = t.partList;
												if (a && i) {
													r > e.end && t.fragmentHint && (e = t.fragmentHint);
													var o = this.getNextPart(a, e, r);
													if (o > -1) {
														var u = a[o];
														return this.log("Loading part sn: " + e.sn + " p: " + u.index + " cc: " + e.cc + " of playlist [" + t.startSN + "-" + t.endSN + "] parts [0-" + o + "-" + (a.length - 1) + "] " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + e.level + ", target: " + parseFloat(r.toFixed(3))), this.nextLoadPosition = u.start + u.duration, this.state = _.FRAG_LOADING, this.hls.trigger(l.Events.FRAG_LOADING, {
																frag: e,
																part: a[o],
																targetBufferTime: r
															}), this.doFragPartsLoad(e, a, o, i)
															.catch((function(e) {
																return s.handleFragLoadError(e)
															}))
													}
													if (!e.url || this.loadedEndOfParts(a, r)) return Promise.resolve(null)
												}
											}
											return this.log("Loading fragment " + e.sn + " cc: " + e.cc + " " + (t ? "of [" + t.startSN + "-" + t.endSN + "] " : "") + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + e.level + ", target: " + parseFloat(r.toFixed(3))), Object(n.isFiniteNumber)(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = _.FRAG_LOADING, this.hls.trigger(l.Events.FRAG_LOADING, {
													frag: e,
													targetBufferTime: r
												}), this.fragmentLoader.load(e, i)
												.catch((function(e) {
													return s.handleFragLoadError(e)
												}))
										}, L.doFragPartsLoad = function(e, t, r, n) {
											var i = this;
											return new Promise((function(s, a) {
												var o = [];
												! function r(u) {
													var c = t[u];
													i.fragmentLoader.loadPart(e, c, n)
														.then((function(n) {
															o[c.index] = n;
															var a = n.part;
															i.hls.trigger(l.Events.FRAG_LOADED, n);
															var d = t[u + 1];
															if (!d || d.fragment !== e) return s({
																frag: e,
																part: a,
																partsLoaded: o
															});
															r(u + 1)
														}))
														.catch(a)
												}(r)
											}))
										}, L.handleFragLoadError = function(e) {
											var t = e.data;
											return t && t.details === u.ErrorDetails.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(l.Events.ERROR, t), null
										}, L._handleTransmuxerFlush = function(e) {
											var t = this.getCurrentContext(e);
											if (t && this.state === _.PARSING) {
												var r = t.frag,
													n = t.part,
													i = t.level,
													s = self.performance.now();
												r.stats.parsing.end = s, n && (n.stats.parsing.end = s), this.updateLevelTiming(r, n, i, e.partial)
											} else this.fragCurrent || (this.state = _.IDLE)
										}, L.getCurrentContext = function(e) {
											var t = this.levels,
												r = e.level,
												n = e.sn,
												i = e.part;
											if (!t || !t[r]) return this.warn("Levels object was unset while buffering fragment " + n + " of level " + r + ". The current chunk will not be buffered."), null;
											var s = t[r],
												a = i > -1 ? Object(g.getPartWith)(s, n, i) : null,
												o = a ? a.fragment : Object(g.getFragmentWithSN)(s, n, this.fragCurrent);
											return o ? {
												frag: o,
												part: a,
												level: s
											} : null
										}, L.bufferFragmentData = function(e, t, r, n) {
											if (e && this.state === _.PARSING) {
												var i = e.data1,
													s = e.data2,
													a = i;
												if (i && s && (a = Object(d.appendUint8Array)(i, s)), a && a.length) {
													var o = {
														type: e.type,
														frag: t,
														part: r,
														chunkMeta: n,
														parent: t.type,
														data: a
													};
													this.hls.trigger(l.Events.BUFFER_APPENDING, o), e.dropped && e.independent && !r && this.flushBufferGap(t)
												}
											}
										}, L.flushBufferGap = function(e) {
											var t = this.media;
											if (t)
												if (a.BufferHelper.isBuffered(t, t.currentTime)) {
													var r = t.currentTime,
														n = a.BufferHelper.bufferInfo(t, r, 0),
														i = e.duration,
														s = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * i),
														o = Math.max(Math.min(e.start - s, n.end - s), r + s);
													e.start - o > s && this.flushMainBuffer(o, e.start)
												} else this.flushMainBuffer(0, e.start)
										}, L.getFwdBufferInfo = function(e, t) {
											var r = this.config,
												i = this.getLoadPosition();
											if (!Object(n.isFiniteNumber)(i)) return null;
											var s = a.BufferHelper.bufferInfo(e, i, r.maxBufferHole);
											if (0 === s.len && void 0 !== s.nextStart) {
												var o = this.fragmentTracker.getBufferedFrag(i, t);
												if (o && s.nextStart < o.end) return a.BufferHelper.bufferInfo(e, i, Math.max(s.nextStart, r.maxBufferHole))
											}
											return s
										}, L.getMaxBufferLength = function(e) {
											var t, r = this.config;
											return t = e ? Math.max(8 * r.maxBufferSize / e, r.maxBufferLength) : r.maxBufferLength, Math.min(t, r.maxMaxBufferLength)
										}, L.reduceMaxBufferLength = function(e) {
											var t = this.config,
												r = e || t.maxBufferLength;
											return t.maxMaxBufferLength >= r && (t.maxMaxBufferLength /= 2, this.warn("Reduce max buffer length to " + t.maxMaxBufferLength + "s"), !0)
										}, L.getNextFragment = function(e, t) {
											var r, n, i = t.fragments,
												s = i.length;
											if (!s) return null;
											var a, o = this.config,
												l = i[0].start;
											if (t.live) {
												var u = o.initialLiveManifestSize;
												if (s < u) return this.warn("Not enough fragments to start playback (have: " + s + ", need: " + u + ")"), null;
												t.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (a = this.getInitialLiveFragment(t, i), this.startPosition = a ? this.hls.liveSyncPosition || a.start : e)
											} else e <= l && (a = i[0]);
											if (!a) {
												var c = o.lowLatencyMode ? t.partEnd : t.fragmentEnd;
												a = this.getFragmentAtPosition(e, c, t)
											}
											return null === (r = a) || void 0 === r || !r.initSegment || null !== (n = a) && void 0 !== n && n.initSegment.data || this.bitrateTest || (a = a.initSegment), a
										}, L.getNextPart = function(e, t, r) {
											for (var n = -1, i = !1, s = !0, a = 0, o = e.length; a < o; a++) {
												var l = e[a];
												if (s = s && !l.independent, n > -1 && r < l.start) break;
												var u = l.loaded;
												!u && (i || l.independent || s) && l.fragment === t && (n = a), i = u
											}
											return n
										}, L.loadedEndOfParts = function(e, t) {
											var r = e[e.length - 1];
											return r && t > r.start && r.loaded
										}, L.getInitialLiveFragment = function(e, t) {
											var r = this.fragPrevious,
												n = null;
											if (r) {
												if (e.hasProgramDateTime && (this.log("Live playlist, switching playlist, load frag with same PDT: " + r.programDateTime), n = Object(h.findFragmentByPDT)(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !n) {
													var i = r.sn + 1;
													if (i >= e.startSN && i <= e.endSN) {
														var s = t[i - e.startSN];
														r.cc === s.cc && (n = s, this.log("Live playlist, switching playlist, load frag with next SN: " + n.sn))
													}
													n || (n = Object(h.findFragWithCC)(t, r.cc)) && this.log("Live playlist, switching playlist, load frag with same CC: " + n.sn)
												}
											} else {
												var a = this.hls.liveSyncPosition;
												null !== a && (n = this.getFragmentAtPosition(a, this.bitrateTest ? e.fragmentEnd : e.edge, e))
											}
											return n
										}, L.getFragmentAtPosition = function(e, t, r) {
											var n, i = this.config,
												a = this.fragPrevious,
												o = r.fragments,
												l = r.endSN,
												u = r.fragmentHint,
												c = i.maxFragLookUpTolerance,
												d = !!(i.lowLatencyMode && r.partList && u);
											if (d && u && !this.bitrateTest && (o = o.concat(u), l = u.sn), e < t) {
												var f = e > t - c ? 0 : c;
												n = Object(h.findFragmentByPTS)(a, o, e, f)
											} else n = o[o.length - 1];
											if (n) {
												var g = n.sn - r.startSN,
													v = a && n.level === a.level,
													p = o[g + 1];
												if (this.fragmentTracker.getState(n) === s.FragmentState.BACKTRACKED) {
													n = null;
													for (var m = g; o[m] && this.fragmentTracker.getState(o[m]) === s.FragmentState.BACKTRACKED;) n = a ? o[m--] : o[--m];
													n || (n = p)
												} else a && n.sn === a.sn && !d && v && (n.sn < l && this.fragmentTracker.getState(p) !== s.FragmentState.OK ? (this.log("SN " + n.sn + " just loaded, load next one: " + p.sn), n = p) : n = null)
											}
											return n
										}, L.synchronizeToLiveEdge = function(e) {
											var t = this.config,
												r = this.media;
											if (r) {
												var n = this.hls.liveSyncPosition,
													i = r.currentTime,
													s = e.fragments[0].start,
													a = e.edge,
													o = i >= s - t.maxFragLookUpTolerance && i <= a;
												if (null !== n && r.duration > n && (i < n || !o)) {
													var l = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
													(!o && r.readyState < 4 || i < a - l) && (this.loadedmetadata || (this.nextLoadPosition = n), r.readyState && (this.warn("Playback: " + i.toFixed(3) + " is located too far from the end of live sliding playlist: " + a + ", reset currentTime to : " + n.toFixed(3)), r.currentTime = n))
												}
											}
										}, L.alignPlaylists = function(e, t) {
											var r = this.levels,
												i = this.levelLastLoaded,
												s = this.fragPrevious,
												a = null !== i ? r[i] : null,
												o = e.fragments.length;
											if (!o) return this.warn("No fragments in live playlist"), 0;
											var l = e.fragments[0].start,
												u = !t,
												c = e.alignedSliding && Object(n.isFiniteNumber)(l);
											if (u || !c && !l) {
												Object(f.alignStream)(s, a, e);
												var d = e.fragments[0].start;
												return this.log("Live playlist sliding: " + d.toFixed(2) + " start-sn: " + (t ? t.startSN : "na") + "->" + e.startSN + " prev-sn: " + (s ? s.sn : "na") + " fragments: " + o), d
											}
											return l
										}, L.waitForCdnTuneIn = function(e) {
											return e.live && e.canBlockReload && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
										}, L.setStartPosition = function(e, t) {
											var r = this.startPosition;
											if (r < t && (r = -1), -1 === r || -1 === this.lastCurrentTime) {
												var i = e.startTimeOffset;
												Object(n.isFiniteNumber)(i) ? (r = t + i, i < 0 && (r += e.totalduration), r = Math.min(Math.max(t, r), t + e.totalduration), this.log("Start time offset " + i + " found in playlist, adjust startPosition to " + r), this.startPosition = r) : e.live ? r = this.hls.liveSyncPosition || t : this.startPosition = r = 0, this.lastCurrentTime = r
											}
											this.nextLoadPosition = r
										}, L.getLoadPosition = function() {
											var e = this.media,
												t = 0;
											return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t
										}, L.handleFragLoadAborted = function(e, t) {
											this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn("Fragment " + e.sn + (t ? " part" + t.index : "") + " of level " + e.level + " was aborted"), this.resetFragmentLoading(e))
										}, L.resetFragmentLoading = function(e) {
											this.fragCurrent && this.fragContextChanged(e) || (this.state = _.IDLE)
										}, L.onFragmentOrKeyLoadError = function(e, t) {
											if (!t.fatal) {
												var r = t.frag;
												if (r && r.type === e) {
													var n = this.fragCurrent;
													console.assert(n && r.sn === n.sn && r.level === n.level && r.urlId === n.urlId, "Frag load error must match current frag to retry");
													var i = this.config;
													if (this.fragLoadError + 1 <= i.fragLoadingMaxRetry) {
														if (this.resetLiveStartWhenNotLoaded(r.level)) return;
														var s = Math.min(Math.pow(2, this.fragLoadError) * i.fragLoadingRetryDelay, i.fragLoadingMaxRetryTimeout);
														this.warn("Fragment " + r.sn + " of " + e + " " + r.level + " failed to load, retrying in " + s + "ms"), this.retryDate = self.performance.now() + s, this.fragLoadError++, this.state = _.FRAG_LOADING_WAITING_RETRY
													} else t.levelRetry ? (e === y.PlaylistLevelType.AUDIO && (this.fragCurrent = null), this.fragLoadError = 0, this.state = _.IDLE) : (o.logger.error(t.details + " reaches max retry, redispatch as fatal ..."), t.fatal = !0, this.hls.stopLoad(), this.state = _.ERROR)
												}
											}
										}, L.afterBufferFlushed = function(e, t, r) {
											if (e) {
												var n = a.BufferHelper.getBuffered(e);
												this.fragmentTracker.detectEvictedFragments(t, n, r), this.state === _.ENDED && this.resetLoadingState()
											}
										}, L.resetLoadingState = function() {
											this.fragCurrent = null, this.fragPrevious = null, this.state = _.IDLE
										}, L.resetLiveStartWhenNotLoaded = function(e) {
											if (!this.loadedmetadata) {
												this.startFragRequested = !1;
												var t = this.levels ? this.levels[e].details : null;
												if (null != t && t.live) return this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState(), !0;
												this.nextLoadPosition = this.startPosition
											}
											return !1
										}, L.updateLevelTiming = function(e, t, r, n) {
											var i = this,
												s = r.details;
											console.assert(!!s, "level.details must be defined"), Object.keys(e.elementaryStreams)
												.reduce((function(t, a) {
													var o = e.elementaryStreams[a];
													if (o) {
														var u = o.endPTS - o.startPTS;
														if (u <= 0) return i.warn("Could not parse fragment " + e.sn + " " + a + " duration reliably (" + u + ") resetting transmuxer to fallback to playlist timing"), i.resetTransmuxer(), t || !1;
														var c = n ? 0 : Object(g.updateFragPTSDTS)(s, e, o.startPTS, o.endPTS, o.startDTS, o.endDTS);
														return i.hls.trigger(l.Events.LEVEL_PTS_UPDATED, {
															details: s,
															level: r,
															drift: c,
															type: a,
															frag: e,
															start: o.startPTS,
															end: o.endPTS
														}), !0
													}
													return t
												}), !1) ? (this.state = _.PARSED, this.hls.trigger(l.Events.FRAG_PARSED, {
													frag: e,
													part: t
												})) : this.resetLoadingState()
										}, L.resetTransmuxer = function() {
											this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
										}, T = i, (S = [{
											key: "state",
											get: function() {
												return this._state
											},
											set: function(e) {
												var t = this._state;
												t !== e && (this._state = e, this.log(t + "->" + e))
											}
										}]) && b(T.prototype, S), A && b(T, A), i
									}(i.default)
							},
							"./src/controller/buffer-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return h
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/events.ts"),
									s = r("./src/utils/logger.ts"),
									a = r("./src/errors.ts"),
									o = r("./src/utils/buffer-helper.ts"),
									l = r("./src/utils/mediasource-helper.ts"),
									u = r("./src/loader/fragment.ts"),
									c = r("./src/controller/buffer-operation-queue.ts"),
									d = Object(l.getMediaSource)(),
									f = /([ha]vc.)(?:\.[^.,]+)+/,
									h = function() {
										function e(e) {
											var t = this;
											this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function() {
												var e = t.hls,
													r = t.media,
													n = t.mediaSource;
												s.logger.log("[buffer-controller]: Media source opened"), r && (t.updateMediaElementDuration(), e.trigger(i.Events.MEDIA_ATTACHED, {
													media: r
												})), n && n.removeEventListener("sourceopen", t._onMediaSourceOpen), t.checkPendingTracks()
											}, this._onMediaSourceClose = function() {
												s.logger.log("[buffer-controller]: Media source closed")
											}, this._onMediaSourceEnded = function() {
												s.logger.log("[buffer-controller]: Media source ended")
											}, this.hls = e, this._initSourceBuffer(), this.registerListeners()
										}
										var t = e.prototype;
										return t.hasSourceTypes = function() {
											return this.getSourceBufferTypes()
												.length > 0 || Object.keys(this.pendingTracks)
												.length > 0
										}, t.destroy = function() {
											this.unregisterListeners(), this.details = null
										}, t.registerListeners = function() {
											var e = this.hls;
											e.on(i.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(i.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(i.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(i.Events.BUFFER_RESET, this.onBufferReset, this), e.on(i.Events.BUFFER_APPENDING, this.onBufferAppending, this), e.on(i.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.on(i.Events.BUFFER_EOS, this.onBufferEos, this), e.on(i.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(i.Events.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(i.Events.FRAG_PARSED, this.onFragParsed, this), e.on(i.Events.FRAG_CHANGED, this.onFragChanged, this)
										}, t.unregisterListeners = function() {
											var e = this.hls;
											e.off(i.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(i.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(i.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(i.Events.BUFFER_RESET, this.onBufferReset, this), e.off(i.Events.BUFFER_APPENDING, this.onBufferAppending, this), e.off(i.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.off(i.Events.BUFFER_EOS, this.onBufferEos, this), e.off(i.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(i.Events.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(i.Events.FRAG_PARSED, this.onFragParsed, this), e.off(i.Events.FRAG_CHANGED, this.onFragChanged, this)
										}, t._initSourceBuffer = function() {
											this.sourceBuffer = {}, this.operationQueue = new c.default(this.sourceBuffer), this.listeners = {
												audio: [],
												video: [],
												audiovideo: []
											}
										}, t.onManifestParsed = function(e, t) {
											var r = 2;
											(t.audio && !t.video || !t.altAudio) && (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, this.details = null, s.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected")
										}, t.onMediaAttaching = function(e, t) {
											var r = this.media = t.media;
											if (r && d) {
												var n = this.mediaSource = new d;
												n.addEventListener("sourceopen", this._onMediaSourceOpen), n.addEventListener("sourceended", this._onMediaSourceEnded), n.addEventListener("sourceclose", this._onMediaSourceClose), r.src = self.URL.createObjectURL(n), this._objectUrl = r.src
											}
										}, t.onMediaDetaching = function() {
											var e = this.media,
												t = this.mediaSource,
												r = this._objectUrl;
											if (t) {
												if (s.logger.log("[buffer-controller]: media source detaching"), "open" === t.readyState) try {
													t.endOfStream()
												} catch (e) {
													s.logger.warn("[buffer-controller]: onMediaDetaching: " + e.message + " while calling endOfStream")
												}
												this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), e && (r && self.URL.revokeObjectURL(r), e.src === r ? (e.removeAttribute("src"), e.load()) : s.logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
											}
											this.hls.trigger(i.Events.MEDIA_DETACHED, void 0)
										}, t.onBufferReset = function() {
											var e = this;
											this.getSourceBufferTypes()
												.forEach((function(t) {
													var r = e.sourceBuffer[t];
													try {
														r && (e.removeBufferListeners(t), e.mediaSource && e.mediaSource.removeSourceBuffer(r), e.sourceBuffer[t] = void 0)
													} catch (e) {
														s.logger.warn("[buffer-controller]: Failed to reset the " + t + " buffer", e)
													}
												})), this._initSourceBuffer()
										}, t.onBufferCodecs = function(e, t) {
											var r = this,
												n = this.getSourceBufferTypes()
												.length;
											Object.keys(t)
												.forEach((function(e) {
													if (n) {
														var i = r.tracks[e];
														if (i && "function" == typeof i.buffer.changeType) {
															var s = t[e],
																a = s.codec,
																o = s.levelCodec,
																l = s.container;
															if ((i.levelCodec || i.codec)
																.replace(f, "$1") !== (o || a)
																.replace(f, "$1")) {
																var u = l + ";codecs=" + (o || a);
																r.appendChangeType(e, u)
															}
														}
													} else r.pendingTracks[e] = t[e]
												})), n || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
										}, t.appendChangeType = function(e, t) {
											var r = this,
												n = this.operationQueue,
												i = {
													execute: function() {
														var i = r.sourceBuffer[e];
														i && (s.logger.log("[buffer-controller]: changing " + e + " sourceBuffer type to " + t), i.changeType(t)), n.shiftAndExecuteNext(e)
													},
													onStart: function() {},
													onComplete: function() {},
													onError: function(t) {
														s.logger.warn("[buffer-controller]: Failed to change " + e + " SourceBuffer type", t)
													}
												};
											n.append(i, e)
										}, t.onBufferAppending = function(e, t) {
											var r = this,
												n = this.hls,
												l = this.operationQueue,
												u = this.tracks,
												c = t.data,
												d = t.type,
												f = t.frag,
												h = t.part,
												g = t.chunkMeta,
												v = g.buffering[d],
												p = self.performance.now();
											v.start = p;
											var m = f.stats.buffering,
												y = h ? h.stats.buffering : null;
											0 === m.start && (m.start = p), y && 0 === y.start && (y.start = p);
											var b = u.audio,
												E = "audio" === d && 1 === g.id && "audio/mpeg" === (null == b ? void 0 : b.container),
												_ = {
													execute: function() {
														if (v.executeStart = self.performance.now(), E) {
															var e = r.sourceBuffer[d];
															if (e) {
																var t = f.start - e.timestampOffset;
																Math.abs(t) >= .1 && (s.logger.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + f.start + " (delta: " + t + ") sn: " + f.sn + ")"), e.timestampOffset = f.start)
															}
														}
														r.appendExecutor(c, d)
													},
													onStart: function() {},
													onComplete: function() {
														var e = self.performance.now();
														v.executeEnd = v.end = e, 0 === m.first && (m.first = e), y && 0 === y.first && (y.first = e);
														var t = r.sourceBuffer,
															n = {};
														for (var s in t) n[s] = o.BufferHelper.getBuffered(t[s]);
														r.appendError = 0, r.hls.trigger(i.Events.BUFFER_APPENDED, {
															type: d,
															frag: f,
															part: h,
															chunkMeta: g,
															parent: f.type,
															timeRanges: n
														})
													},
													onError: function(e) {
														s.logger.error("[buffer-controller]: Error encountered while trying to append to the " + d + " SourceBuffer", e);
														var t = {
															type: a.ErrorTypes.MEDIA_ERROR,
															parent: f.type,
															details: a.ErrorDetails.BUFFER_APPEND_ERROR,
															err: e,
															fatal: !1
														};
														e.code === DOMException.QUOTA_EXCEEDED_ERR ? t.details = a.ErrorDetails.BUFFER_FULL_ERROR : (r.appendError++, t.details = a.ErrorDetails.BUFFER_APPEND_ERROR, r.appendError > n.config.appendErrorMaxRetry && (s.logger.error("[buffer-controller]: Failed " + n.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), t.fatal = !0)), n.trigger(i.Events.ERROR, t)
													}
												};
											l.append(_, d)
										}, t.onBufferFlushing = function(e, t) {
											var r = this,
												n = this.operationQueue,
												a = function(e) {
													return {
														execute: r.removeExecutor.bind(r, e, t.startOffset, t.endOffset),
														onStart: function() {},
														onComplete: function() {
															r.hls.trigger(i.Events.BUFFER_FLUSHED, {
																type: e
															})
														},
														onError: function(t) {
															s.logger.warn("[buffer-controller]: Failed to remove from " + e + " SourceBuffer", t)
														}
													}
												};
											t.type ? n.append(a(t.type), t.type) : this.getSourceBufferTypes()
												.forEach((function(e) {
													n.append(a(e), e)
												}))
										}, t.onFragParsed = function(e, t) {
											var r = this,
												n = t.frag,
												a = t.part,
												o = [],
												l = a ? a.elementaryStreams : n.elementaryStreams;
											l[u.ElementaryStreamTypes.AUDIOVIDEO] ? o.push("audiovideo") : (l[u.ElementaryStreamTypes.AUDIO] && o.push("audio"), l[u.ElementaryStreamTypes.VIDEO] && o.push("video")), 0 === o.length && s.logger.warn("Fragments must have at least one ElementaryStreamType set. type: " + n.type + " level: " + n.level + " sn: " + n.sn), this.blockBuffers((function() {
												var e = self.performance.now();
												n.stats.buffering.end = e, a && (a.stats.buffering.end = e);
												var t = a ? a.stats : n.stats;
												r.hls.trigger(i.Events.FRAG_BUFFERED, {
													frag: n,
													part: a,
													stats: t,
													id: n.type
												})
											}), o)
										}, t.onFragChanged = function(e, t) {
											this.flushBackBuffer()
										}, t.onBufferEos = function(e, t) {
											var r = this;
											this.getSourceBufferTypes()
												.reduce((function(e, n) {
													var i = r.sourceBuffer[n];
													return t.type && t.type !== n || i && !i.ended && (i.ended = !0, s.logger.log("[buffer-controller]: " + n + " sourceBuffer now EOS")), e && !(i && !i.ended)
												}), !0) && this.blockBuffers((function() {
													var e = r.mediaSource;
													e && "open" === e.readyState && e.endOfStream()
												}))
										}, t.onLevelUpdated = function(e, t) {
											var r = t.details;
											r.fragments.length && (this.details = r, this.getSourceBufferTypes()
												.length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
										}, t.flushBackBuffer = function() {
											var e = this.hls,
												t = this.details,
												r = this.media,
												s = this.sourceBuffer;
											if (r && null !== t) {
												var a = this.getSourceBufferTypes();
												if (a.length) {
													var l = t.live && null !== e.config.liveBackBufferLength ? e.config.liveBackBufferLength : e.config.backBufferLength;
													if (Object(n.isFiniteNumber)(l) && !(l < 0)) {
														var u = r.currentTime,
															c = t.levelTargetDuration,
															d = Math.max(l, c),
															f = Math.floor(u / c) * c - d;
														a.forEach((function(r) {
															var n = s[r];
															if (n) {
																var a = o.BufferHelper.getBuffered(n);
																a.length > 0 && f > a.start(0) && (e.trigger(i.Events.BACK_BUFFER_REACHED, {
																	bufferEnd: f
																}), t.live && e.trigger(i.Events.LIVE_BACK_BUFFER_REACHED, {
																	bufferEnd: f
																}), e.trigger(i.Events.BUFFER_FLUSHING, {
																	startOffset: 0,
																	endOffset: f,
																	type: r
																}))
															}
														}))
													}
												}
											}
										}, t.updateMediaElementDuration = function() {
											if (this.details && this.media && this.mediaSource && "open" === this.mediaSource.readyState) {
												var e = this.details,
													t = this.hls,
													r = this.media,
													i = this.mediaSource,
													a = e.fragments[0].start + e.totalduration,
													o = r.duration,
													l = Object(n.isFiniteNumber)(i.duration) ? i.duration : 0;
												e.live && t.config.liveDurationInfinity ? (s.logger.log("[buffer-controller]: Media Source duration is set to Infinity"), i.duration = 1 / 0, this.updateSeekableRange(e)) : (a > l && a > o || !Object(n.isFiniteNumber)(o)) && (s.logger.log("[buffer-controller]: Updating Media Source duration to " + a.toFixed(3)), i.duration = a)
											}
										}, t.updateSeekableRange = function(e) {
											var t = this.mediaSource,
												r = e.fragments;
											if (r.length && e.live && null != t && t.setLiveSeekableRange) {
												var n = Math.max(0, r[0].start),
													i = Math.max(n, n + e.totalduration);
												t.setLiveSeekableRange(n, i)
											}
										}, t.checkPendingTracks = function() {
											var e = this.bufferCodecEventsExpected,
												t = this.operationQueue,
												r = this.pendingTracks,
												n = Object.keys(r)
												.length;
											if (n && !e || 2 === n) {
												this.createSourceBuffers(r), this.pendingTracks = {};
												var s = this.getSourceBufferTypes();
												if (0 === s.length) return void this.hls.trigger(i.Events.ERROR, {
													type: a.ErrorTypes.MEDIA_ERROR,
													details: a.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
													fatal: !0,
													reason: "could not create source buffer for media codec(s)"
												});
												s.forEach((function(e) {
													t.executeNext(e)
												}))
											}
										}, t.createSourceBuffers = function(e) {
											var t = this.sourceBuffer,
												r = this.mediaSource;
											if (!r) throw Error("createSourceBuffers called when mediaSource was null");
											var n = 0;
											for (var o in e)
												if (!t[o]) {
													var l = e[o];
													if (!l) throw Error("source buffer exists for track " + o + ", however track does not");
													var u = l.levelCodec || l.codec,
														c = l.container + ";codecs=" + u;
													s.logger.log("[buffer-controller]: creating sourceBuffer(" + c + ")");
													try {
														var d = t[o] = r.addSourceBuffer(c),
															f = o;
														this.addBufferListener(f, "updatestart", this._onSBUpdateStart), this.addBufferListener(f, "updateend", this._onSBUpdateEnd), this.addBufferListener(f, "error", this._onSBUpdateError), this.tracks[o] = {
															buffer: d,
															codec: u,
															container: l.container,
															levelCodec: l.levelCodec,
															id: l.id
														}, n++
													} catch (e) {
														s.logger.error("[buffer-controller]: error while trying to add sourceBuffer: " + e.message), this.hls.trigger(i.Events.ERROR, {
															type: a.ErrorTypes.MEDIA_ERROR,
															details: a.ErrorDetails.BUFFER_ADD_CODEC_ERROR,
															fatal: !1,
															error: e,
															mimeType: c
														})
													}
												} n && this.hls.trigger(i.Events.BUFFER_CREATED, {
												tracks: this.tracks
											})
										}, t._onSBUpdateStart = function(e) {
											this.operationQueue.current(e)
												.onStart()
										}, t._onSBUpdateEnd = function(e) {
											var t = this.operationQueue;
											t.current(e)
												.onComplete(), t.shiftAndExecuteNext(e)
										}, t._onSBUpdateError = function(e, t) {
											s.logger.error("[buffer-controller]: " + e + " SourceBuffer error", t), this.hls.trigger(i.Events.ERROR, {
												type: a.ErrorTypes.MEDIA_ERROR,
												details: a.ErrorDetails.BUFFER_APPENDING_ERROR,
												fatal: !1
											});
											var r = this.operationQueue.current(e);
											r && r.onError(t)
										}, t.removeExecutor = function(e, t, r) {
											var i = this.media,
												a = this.mediaSource,
												o = this.operationQueue,
												l = this.sourceBuffer[e];
											if (!i || !a || !l) return s.logger.warn("[buffer-controller]: Attempting to remove from the " + e + " SourceBuffer, but it does not exist"), void o.shiftAndExecuteNext(e);
											var u = Object(n.isFiniteNumber)(i.duration) ? i.duration : 1 / 0,
												c = Object(n.isFiniteNumber)(a.duration) ? a.duration : 1 / 0,
												d = Math.max(0, t),
												f = Math.min(r, u, c);
											f > d ? (s.logger.log("[buffer-controller]: Removing [" + d + "," + f + "] from the " + e + " SourceBuffer"), console.assert(!l.updating, e + " sourceBuffer must not be updating"), l.remove(d, f)) : o.shiftAndExecuteNext(e)
										}, t.appendExecutor = function(e, t) {
											var r = this.operationQueue,
												n = this.sourceBuffer[t];
											if (!n) return s.logger.warn("[buffer-controller]: Attempting to append to the " + t + " SourceBuffer, but it does not exist"), void r.shiftAndExecuteNext(t);
											n.ended = !1, console.assert(!n.updating, t + " sourceBuffer must not be updating"), n.appendBuffer(e)
										}, t.blockBuffers = function(e, t) {
											var r = this;
											if (void 0 === t && (t = this.getSourceBufferTypes()), !t.length) return s.logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve(e);
											var n = this.operationQueue,
												i = t.map((function(e) {
													return n.appendBlocker(e)
												}));
											Promise.all(i)
												.then((function() {
													e(), t.forEach((function(e) {
														var t = r.sourceBuffer[e];
														t && t.updating || n.shiftAndExecuteNext(e)
													}))
												}))
										}, t.getSourceBufferTypes = function() {
											return Object.keys(this.sourceBuffer)
										}, t.addBufferListener = function(e, t, r) {
											var n = this.sourceBuffer[e];
											if (n) {
												var i = r.bind(this, e);
												this.listeners[e].push({
													event: t,
													listener: i
												}), n.addEventListener(t, i)
											}
										}, t.removeBufferListeners = function(e) {
											var t = this.sourceBuffer[e];
											t && this.listeners[e].forEach((function(e) {
												t.removeEventListener(e.event, e.listener)
											}))
										}, e
									}()
							},
							"./src/controller/buffer-operation-queue.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return i
								}));
								var n = r("./src/utils/logger.ts"),
									i = function() {
										function e(e) {
											this.buffers = void 0, this.queues = {
												video: [],
												audio: [],
												audiovideo: []
											}, this.buffers = e
										}
										var t = e.prototype;
										return t.append = function(e, t) {
											var r = this.queues[t];
											r.push(e), 1 === r.length && this.buffers[t] && this.executeNext(t)
										}, t.insertAbort = function(e, t) {
											this.queues[t].unshift(e), this.executeNext(t)
										}, t.appendBlocker = function(e) {
											var t, r = new Promise((function(e) {
													t = e
												})),
												n = {
													execute: t,
													onStart: function() {},
													onComplete: function() {},
													onError: function() {}
												};
											return this.append(n, e), r
										}, t.executeNext = function(e) {
											var t = this.buffers,
												r = this.queues,
												i = t[e],
												s = r[e];
											if (s.length) {
												var a = s[0];
												try {
													a.execute()
												} catch (t) {
													n.logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), a.onError(t), i && i.updating || (s.shift(), this.executeNext(e))
												}
											}
										}, t.shiftAndExecuteNext = function(e) {
											this.queues[e].shift(), this.executeNext(e)
										}, t.current = function(e) {
											return this.queues[e][0]
										}, e
									}()
							},
							"./src/controller/cap-level-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/events.ts");

								function i(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var s = function() {
									function e(e) {
										this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
									}
									var t, r, s, a = e.prototype;
									return a.setStreamController = function(e) {
										this.streamController = e
									}, a.destroy = function() {
										this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
									}, a.registerListeners = function() {
										var e = this.hls;
										e.on(n.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(n.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(n.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(n.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.on(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
									}, a.unregisterListener = function() {
										var e = this.hls;
										e.off(n.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(n.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(n.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(n.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.off(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
									}, a.onFpsDropLevelCapping = function(t, r) {
										e.isLevelAllowed(r.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(r.droppedLevel)
									}, a.onMediaAttaching = function(e, t) {
										this.media = t.media instanceof HTMLVideoElement ? t.media : null
									}, a.onManifestParsed = function(e, t) {
										var r = this.hls;
										this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize && t.video && this.startCapping()
									}, a.onBufferCodecs = function(e, t) {
										this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
									}, a.onMediaDetaching = function() {
										this.stopCapping()
									}, a.detectPlayerSize = function() {
										if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
											var e = this.hls.levels;
											if (e.length) {
												var t = this.hls;
												t.autoLevelCapping = this.getMaxLevel(e.length - 1), t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping
											}
										}
									}, a.getMaxLevel = function(t) {
										var r = this,
											n = this.hls.levels;
										if (!n.length) return -1;
										var i = n.filter((function(n, i) {
											return e.isLevelAllowed(i, r.restrictedLevels) && i <= t
										}));
										return this.clientRect = null, e.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight)
									}, a.startCapping = function() {
										this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
									}, a.stopCapping = function() {
										this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
									}, a.getDimensions = function() {
										if (this.clientRect) return this.clientRect;
										var e = this.media,
											t = {
												width: 0,
												height: 0
											};
										if (e) {
											var r = e.getBoundingClientRect();
											t.width = r.width, t.height = r.height, t.width || t.height || (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0)
										}
										return this.clientRect = t, t
									}, e.isLevelAllowed = function(e, t) {
										return void 0 === t && (t = []), -1 === t.indexOf(e)
									}, e.getMaxLevelByMediaSize = function(e, t, r) {
										if (!e || !e.length) return -1;
										for (var n, i, s = e.length - 1, a = 0; a < e.length; a += 1) {
											var o = e[a];
											if ((o.width >= t || o.height >= r) && (n = o, !(i = e[a + 1]) || n.width !== i.width || n.height !== i.height)) {
												s = a;
												break
											}
										}
										return s
									}, t = e, s = [{
										key: "contentScaleFactor",
										get: function() {
											var e = 1;
											try {
												e = self.devicePixelRatio
											} catch (e) {}
											return e
										}
									}], (r = [{
										key: "mediaWidth",
										get: function() {
											return this.getDimensions()
												.width * e.contentScaleFactor
										}
									}, {
										key: "mediaHeight",
										get: function() {
											return this.getDimensions()
												.height * e.contentScaleFactor
										}
									}]) && i(t.prototype, r), s && i(t, s), e
								}();
								t.default = s
							},
							"./src/controller/cmcd-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return f
								}));
								var n = r("./src/events.ts"),
									i = r("./src/types/cmcd.ts"),
									s = r("./src/utils/buffer-helper.ts"),
									a = r("./src/utils/logger.ts");

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function l(e, t, r) {
									return t && o(e.prototype, t), r && o(e, r), e
								}

								function u(e, t) {
									var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
									if (r) return (r = r.call(e))
										.next.bind(r);
									if (Array.isArray(e) || (r = function(e, t) {
										if (e) {
											if ("string" == typeof e) return c(e, t);
											var r = Object.prototype.toString.call(e)
												.slice(8, -1);
											return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? c(e, t) : void 0
										}
									}(e)) || t && e && "number" == typeof e.length) {
										r && (e = r);
										var n = 0;
										return function() {
											return n >= e.length ? {
												done: !0
											} : {
												done: !1,
												value: e[n++]
											}
										}
									}
									throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
								}

								function c(e, t) {
									(null == t || t > e.length) && (t = e.length);
									for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
									return n
								}

								function d() {
									return d = Object.assign || function(e) {
										for (var t = 1; t < arguments.length; t++) {
											var r = arguments[t];
											for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
										}
										return e
									}, d.apply(this, arguments)
								}
								var f = function() {
									function e(t) {
										var r = this;
										this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = function() {
											r.initialized && (r.starved = !0), r.buffering = !0
										}, this.onPlaying = function() {
											r.initialized || (r.initialized = !0), r.buffering = !1
										}, this.applyPlaylistData = function(e) {
											try {
												r.apply(e, {
													ot: i.CMCDObjectType.MANIFEST,
													su: !r.initialized
												})
											} catch (e) {
												a.logger.warn("Could not generate manifest CMCD data.", e)
											}
										}, this.applyFragmentData = function(e) {
											try {
												var t = e.frag,
													n = r.hls.levels[t.level],
													s = r.getObjectType(t),
													o = {
														d: 1e3 * t.duration,
														ot: s
													};
												s !== i.CMCDObjectType.VIDEO && s !== i.CMCDObjectType.AUDIO && s != i.CMCDObjectType.MUXED || (o.br = n.bitrate / 1e3, o.tb = r.getTopBandwidth(s) / 1e3, o.bl = r.getBufferLength(s)), r.apply(e, o)
											} catch (e) {
												a.logger.warn("Could not generate segment CMCD data.", e)
											}
										}, this.hls = t;
										var n = this.config = t.config,
											s = n.cmcd;
										null != s && (n.pLoader = this.createPlaylistLoader(), n.fLoader = this.createFragmentLoader(), this.sid = s.sessionId || e.uuid(), this.cid = s.contentId, this.useHeaders = !0 === s.useHeaders, this.registerListeners())
									}
									var t = e.prototype;
									return t.registerListeners = function() {
										var e = this.hls;
										e.on(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(n.Events.MEDIA_DETACHED, this.onMediaDetached, this), e.on(n.Events.BUFFER_CREATED, this.onBufferCreated, this)
									}, t.unregisterListeners = function() {
										var e = this.hls;
										e.off(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(n.Events.MEDIA_DETACHED, this.onMediaDetached, this), e.off(n.Events.BUFFER_CREATED, this.onBufferCreated, this), this.onMediaDetached()
									}, t.destroy = function() {
										this.unregisterListeners(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null
									}, t.onMediaAttached = function(e, t) {
										this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
									}, t.onMediaDetached = function() {
										this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
									}, t.onBufferCreated = function(e, t) {
										var r, n;
										this.audioBuffer = null === (r = t.tracks.audio) || void 0 === r ? void 0 : r.buffer, this.videoBuffer = null === (n = t.tracks.video) || void 0 === n ? void 0 : n.buffer
									}, t.createData = function() {
										var e;
										return {
											v: i.CMCDVersion,
											sf: i.CMCDStreamingFormat.HLS,
											sid: this.sid,
											cid: this.cid,
											pr: null === (e = this.media) || void 0 === e ? void 0 : e.playbackRate,
											mtp: this.hls.bandwidthEstimate / 1e3
										}
									}, t.apply = function(t, r) {
										void 0 === r && (r = {}), d(r, this.createData());
										var n = r.ot === i.CMCDObjectType.INIT || r.ot === i.CMCDObjectType.VIDEO || r.ot === i.CMCDObjectType.MUXED;
										if (this.starved && n && (r.bs = !0, r.su = !0, this.starved = !1), null == r.su && (r.su = this.buffering), this.useHeaders) {
											var s = e.toHeaders(r);
											if (!Object.keys(s)
												.length) return;
											t.headers || (t.headers = {}), d(t.headers, s)
										} else {
											var a = e.toQuery(r);
											if (!a) return;
											t.url = e.appendQueryToUri(t.url, a)
										}
									}, t.getObjectType = function(e) {
										var t = e.type;
										return "subtitle" === t ? i.CMCDObjectType.TIMED_TEXT : "initSegment" === e.sn ? i.CMCDObjectType.INIT : "audio" === t ? i.CMCDObjectType.AUDIO : "main" === t ? this.hls.audioTracks.length ? i.CMCDObjectType.VIDEO : i.CMCDObjectType.MUXED : void 0
									}, t.getTopBandwidth = function(e) {
										var t, r = 0,
											n = this.hls;
										if (e === i.CMCDObjectType.AUDIO) t = n.audioTracks;
										else {
											var s = n.maxAutoLevel,
												a = s > -1 ? s + 1 : n.levels.length;
											t = n.levels.slice(0, a)
										}
										for (var o, l = u(t); !(o = l())
											.done;) {
											var c = o.value;
											c.bitrate > r && (r = c.bitrate)
										}
										return r > 0 ? r : NaN
									}, t.getBufferLength = function(e) {
										var t = this.hls.media,
											r = e === i.CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
										return r && t ? 1e3 * s.BufferHelper.bufferInfo(r, t.currentTime, this.config.maxBufferHole)
											.len : NaN
									}, t.createPlaylistLoader = function() {
										var e = this.config.pLoader,
											t = this.applyPlaylistData,
											r = e || this.config.loader;
										return function() {
											function e(e) {
												this.loader = void 0, this.loader = new r(e)
											}
											var n = e.prototype;
											return n.destroy = function() {
												this.loader.destroy()
											}, n.abort = function() {
												this.loader.abort()
											}, n.load = function(e, r, n) {
												t(e), this.loader.load(e, r, n)
											}, l(e, [{
												key: "stats",
												get: function() {
													return this.loader.stats
												}
											}, {
												key: "context",
												get: function() {
													return this.loader.context
												}
											}]), e
										}()
									}, t.createFragmentLoader = function() {
										var e = this.config.fLoader,
											t = this.applyFragmentData,
											r = e || this.config.loader;
										return function() {
											function e(e) {
												this.loader = void 0, this.loader = new r(e)
											}
											var n = e.prototype;
											return n.destroy = function() {
												this.loader.destroy()
											}, n.abort = function() {
												this.loader.abort()
											}, n.load = function(e, r, n) {
												t(e), this.loader.load(e, r, n)
											}, l(e, [{
												key: "stats",
												get: function() {
													return this.loader.stats
												}
											}, {
												key: "context",
												get: function() {
													return this.loader.context
												}
											}]), e
										}()
									}, e.uuid = function() {
										var e = URL.createObjectURL(new Blob),
											t = e.toString();
										return URL.revokeObjectURL(e), t.substr(t.lastIndexOf("/") + 1)
									}, e.serialize = function(e) {
										for (var t, r = [], n = function(e) {
												return !Number.isNaN(e) && null != e && "" !== e && !1 !== e
											}, i = function(e) {
												return Math.round(e)
											}, s = function(e) {
												return 100 * i(e / 100)
											}, a = {
												br: i,
												d: i,
												bl: s,
												dl: s,
												mtp: s,
												nor: function(e) {
													return encodeURIComponent(e)
												},
												rtp: s,
												tb: i
											}, o = u(Object.keys(e || {})
												.sort()); !(t = o())
											.done;) {
											var l = t.value,
												c = e[l];
											if (n(c) && !("v" === l && 1 === c || "pr" == l && 1 === c)) {
												var d = a[l];
												d && (c = d(c));
												var f = typeof c,
													h = void 0;
												h = "ot" === l || "sf" === l || "st" === l ? l + "=" + c : "boolean" === f ? l : "number" === f ? l + "=" + c : l + "=" + JSON.stringify(c), r.push(h)
											}
										}
										return r.join(",")
									}, e.toHeaders = function(t) {
										for (var r = {}, n = ["Object", "Request", "Session", "Status"], i = [{}, {}, {}, {}], s = {
											br: 0,
											d: 0,
											ot: 0,
											tb: 0,
											bl: 1,
											dl: 1,
											mtp: 1,
											nor: 1,
											nrr: 1,
											su: 1,
											cid: 2,
											pr: 2,
											sf: 2,
											sid: 2,
											st: 2,
											v: 2,
											bs: 3,
											rtp: 3
										}, a = 0, o = Object.keys(t); a < o.length; a++) {
											var l = o[a];
											i[null != s[l] ? s[l] : 1][l] = t[l]
										}
										for (var u = 0; u < i.length; u++) {
											var c = e.serialize(i[u]);
											c && (r["CMCD-" + n[u]] = c)
										}
										return r
									}, e.toQuery = function(t) {
										return "CMCD=" + encodeURIComponent(e.serialize(t))
									}, e.appendQueryToUri = function(e, t) {
										if (!t) return e;
										var r = e.includes("?") ? "&" : "?";
										return "" + e + r + t
									}, e
								}()
							},
							"./src/controller/eme-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/events.ts"),
									i = r("./src/errors.ts"),
									s = r("./src/utils/logger.ts"),
									a = r("./src/utils/mediakeys-helper.ts");

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var l = function() {
									function e(e) {
										this.hls = void 0, this._widevineLicenseUrl = void 0, this._licenseXhrSetup = void 0, this._licenseResponseCallback = void 0, this._emeEnabled = void 0, this._requestMediaKeySystemAccess = void 0, this._drmSystemOptions = void 0, this._config = void 0, this._mediaKeysList = [], this._media = null, this._hasSetMediaKeys = !1, this._requestLicenseFailureCount = 0, this.mediaKeysPromise = null, this._onMediaEncrypted = this.onMediaEncrypted.bind(this), this.hls = e, this._config = e.config, this._widevineLicenseUrl = this._config.widevineLicenseUrl, this._licenseXhrSetup = this._config.licenseXhrSetup, this._licenseResponseCallback = this._config.licenseResponseCallback, this._emeEnabled = this._config.emeEnabled, this._requestMediaKeySystemAccess = this._config.requestMediaKeySystemAccessFunc, this._drmSystemOptions = this._config.drmSystemOptions, this._registerListeners()
									}
									var t, r, l, u = e.prototype;
									return u.destroy = function() {
										this._unregisterListeners(), this.hls = this._onMediaEncrypted = null, this._requestMediaKeySystemAccess = null
									}, u._registerListeners = function() {
										this.hls.on(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(n.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(n.Events.MANIFEST_PARSED, this.onManifestParsed, this)
									}, u._unregisterListeners = function() {
										this.hls.off(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(n.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(n.Events.MANIFEST_PARSED, this.onManifestParsed, this)
									}, u.getLicenseServerUrl = function(e) {
										switch (e) {
											case a.KeySystems.WIDEVINE:
												if (!this._widevineLicenseUrl) break;
												return this._widevineLicenseUrl
										}
										throw new Error('no license server URL configured for key-system "' + e + '"')
									}, u._attemptKeySystemAccess = function(e, t, r) {
										var n = this,
											i = function(e, t, r, n) {
												if (e === a.KeySystems.WIDEVINE) return function(e, t, r) {
													var n = {
														audioCapabilities: [],
														videoCapabilities: []
													};
													return e.forEach((function(e) {
														n.audioCapabilities.push({
															contentType: 'audio/mp4; codecs="' + e + '"',
															robustness: r.audioRobustness || ""
														})
													})), t.forEach((function(e) {
														n.videoCapabilities.push({
															contentType: 'video/mp4; codecs="' + e + '"',
															robustness: r.videoRobustness || ""
														})
													})), [n]
												}(t, r, n);
												throw new Error("Unknown key-system: " + e)
											}(e, t, r, this._drmSystemOptions);
										s.logger.log("Requesting encrypted media key-system access");
										var o = this.requestMediaKeySystemAccess(e, i);
										this.mediaKeysPromise = o.then((function(t) {
											return n._onMediaKeySystemAccessObtained(e, t)
										})), o.catch((function(t) {
											s.logger.error('Failed to obtain key-system "' + e + '" access:', t)
										}))
									}, u._onMediaKeySystemAccessObtained = function(e, t) {
										var r = this;
										s.logger.log('Access for key-system "' + e + '" obtained');
										var n = {
											mediaKeysSessionInitialized: !1,
											mediaKeySystemAccess: t,
											mediaKeySystemDomain: e
										};
										this._mediaKeysList.push(n);
										var i = Promise.resolve()
											.then((function() {
												return t.createMediaKeys()
											}))
											.then((function(t) {
												return n.mediaKeys = t, s.logger.log('Media-keys created for key-system "' + e + '"'), r._onMediaKeysCreated(), t
											}));
										return i.catch((function(e) {
											s.logger.error("Failed to create media-keys:", e)
										})), i
									}, u._onMediaKeysCreated = function() {
										var e = this;
										this._mediaKeysList.forEach((function(t) {
											t.mediaKeysSession || (t.mediaKeysSession = t.mediaKeys.createSession(), e._onNewMediaKeySession(t.mediaKeysSession))
										}))
									}, u._onNewMediaKeySession = function(e) {
										var t = this;
										s.logger.log("New key-system session " + e.sessionId), e.addEventListener("message", (function(r) {
											t._onKeySessionMessage(e, r.message)
										}), !1)
									}, u._onKeySessionMessage = function(e, t) {
										s.logger.log("Got EME message event, creating license request"), this._requestLicense(t, (function(t) {
											s.logger.log("Received license data (length: " + (t ? t.byteLength : t) + "), updating key-session"), e.update(t)
										}))
									}, u.onMediaEncrypted = function(e) {
										var t = this;
										if (s.logger.log('Media is encrypted using "' + e.initDataType + '" init data type'), !this.mediaKeysPromise) return s.logger.error("Fatal: Media is encrypted but no CDM access or no keys have been requested"), void this.hls.trigger(n.Events.ERROR, {
											type: i.ErrorTypes.KEY_SYSTEM_ERROR,
											details: i.ErrorDetails.KEY_SYSTEM_NO_KEYS,
											fatal: !0
										});
										var r = function(r) {
											t._media && (t._attemptSetMediaKeys(r), t._generateRequestWithPreferredKeySession(e.initDataType, e.initData))
										};
										this.mediaKeysPromise.then(r)
											.catch(r)
									}, u._attemptSetMediaKeys = function(e) {
										if (!this._media) throw new Error("Attempted to set mediaKeys without first attaching a media element");
										if (!this._hasSetMediaKeys) {
											var t = this._mediaKeysList[0];
											if (!t || !t.mediaKeys) return s.logger.error("Fatal: Media is encrypted but no CDM access or no keys have been obtained yet"), void this.hls.trigger(n.Events.ERROR, {
												type: i.ErrorTypes.KEY_SYSTEM_ERROR,
												details: i.ErrorDetails.KEY_SYSTEM_NO_KEYS,
												fatal: !0
											});
											s.logger.log("Setting keys for encrypted media"), this._media.setMediaKeys(t.mediaKeys), this._hasSetMediaKeys = !0
										}
									}, u._generateRequestWithPreferredKeySession = function(e, t) {
										var r = this,
											a = this._mediaKeysList[0];
										if (!a) return s.logger.error("Fatal: Media is encrypted but not any key-system access has been obtained yet"), void this.hls.trigger(n.Events.ERROR, {
											type: i.ErrorTypes.KEY_SYSTEM_ERROR,
											details: i.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
											fatal: !0
										});
										if (a.mediaKeysSessionInitialized) s.logger.warn("Key-Session already initialized but requested again");
										else {
											var o = a.mediaKeysSession;
											if (!o) return s.logger.error("Fatal: Media is encrypted but no key-session existing"), void this.hls.trigger(n.Events.ERROR, {
												type: i.ErrorTypes.KEY_SYSTEM_ERROR,
												details: i.ErrorDetails.KEY_SYSTEM_NO_SESSION,
												fatal: !0
											});
											if (!t) return s.logger.warn("Fatal: initData required for generating a key session is null"), void this.hls.trigger(n.Events.ERROR, {
												type: i.ErrorTypes.KEY_SYSTEM_ERROR,
												details: i.ErrorDetails.KEY_SYSTEM_NO_INIT_DATA,
												fatal: !0
											});
											s.logger.log('Generating key-session request for "' + e + '" init data type'), a.mediaKeysSessionInitialized = !0, o.generateRequest(e, t)
												.then((function() {
													s.logger.debug("Key-session generation succeeded")
												}))
												.catch((function(e) {
													s.logger.error("Error generating key-session request:", e), r.hls.trigger(n.Events.ERROR, {
														type: i.ErrorTypes.KEY_SYSTEM_ERROR,
														details: i.ErrorDetails.KEY_SYSTEM_NO_SESSION,
														fatal: !1
													})
												}))
										}
									}, u._createLicenseXhr = function(e, t, r) {
										var n = new XMLHttpRequest;
										n.responseType = "arraybuffer", n.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, n, e, t, r);
										var i = this._licenseXhrSetup;
										if (i) try {
											i.call(this.hls, n, e), i = void 0
										} catch (e) {
											s.logger.error(e)
										}
										try {
											n.readyState || n.open("POST", e, !0), i && i.call(this.hls, n, e)
										} catch (e) {
											throw new Error("issue setting up KeySystem license XHR " + e)
										}
										return n
									}, u._onLicenseRequestReadyStageChange = function(e, t, r, a) {
										if (4 === e.readyState)
											if (200 === e.status) {
												this._requestLicenseFailureCount = 0, s.logger.log("License request succeeded");
												var o = e.response,
													l = this._licenseResponseCallback;
												if (l) try {
													o = l.call(this.hls, e, t)
												} catch (e) {
													s.logger.error(e)
												}
												a(o)
											} else {
												if (s.logger.error("License Request XHR failed (" + t + "). Status: " + e.status + " (" + e.statusText + ")"), this._requestLicenseFailureCount++, this._requestLicenseFailureCount > 3) return void this.hls.trigger(n.Events.ERROR, {
													type: i.ErrorTypes.KEY_SYSTEM_ERROR,
													details: i.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
													fatal: !0
												});
												var u = 3 - this._requestLicenseFailureCount + 1;
												s.logger.warn("Retrying license request, " + u + " attempts left"), this._requestLicense(r, a)
											}
									}, u._generateLicenseRequestChallenge = function(e, t) {
										if (e.mediaKeySystemDomain === a.KeySystems.WIDEVINE) return t;
										throw new Error("unsupported key-system: " + e.mediaKeySystemDomain)
									}, u._requestLicense = function(e, t) {
										s.logger.log("Requesting content license for key-system");
										var r = this._mediaKeysList[0];
										if (!r) return s.logger.error("Fatal error: Media is encrypted but no key-system access has been obtained yet"), void this.hls.trigger(n.Events.ERROR, {
											type: i.ErrorTypes.KEY_SYSTEM_ERROR,
											details: i.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
											fatal: !0
										});
										try {
											var a = this.getLicenseServerUrl(r.mediaKeySystemDomain),
												o = this._createLicenseXhr(a, e, t);
											s.logger.log("Sending license request to URL: " + a);
											var l = this._generateLicenseRequestChallenge(r, e);
											o.send(l)
										} catch (e) {
											s.logger.error("Failure requesting DRM license: " + e), this.hls.trigger(n.Events.ERROR, {
												type: i.ErrorTypes.KEY_SYSTEM_ERROR,
												details: i.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
												fatal: !0
											})
										}
									}, u.onMediaAttached = function(e, t) {
										if (this._emeEnabled) {
											var r = t.media;
											this._media = r, r.addEventListener("encrypted", this._onMediaEncrypted)
										}
									}, u.onMediaDetached = function() {
										var e = this._media,
											t = this._mediaKeysList;
										e && (e.removeEventListener("encrypted", this._onMediaEncrypted), this._media = null, this._mediaKeysList = [], Promise.all(t.map((function(e) {
												if (e.mediaKeysSession) return e.mediaKeysSession.close()
													.catch((function() {}))
											})))
											.then((function() {
												return e.setMediaKeys(null)
											}))
											.catch((function() {})))
									}, u.onManifestParsed = function(e, t) {
										if (this._emeEnabled) {
											var r = t.levels.map((function(e) {
													return e.audioCodec
												}))
												.filter((function(e) {
													return !!e
												})),
												n = t.levels.map((function(e) {
													return e.videoCodec
												}))
												.filter((function(e) {
													return !!e
												}));
											this._attemptKeySystemAccess(a.KeySystems.WIDEVINE, r, n)
										}
									}, t = e, (r = [{
										key: "requestMediaKeySystemAccess",
										get: function() {
											if (!this._requestMediaKeySystemAccess) throw new Error("No requestMediaKeySystemAccess function configured");
											return this._requestMediaKeySystemAccess
										}
									}]) && o(t.prototype, r), l && o(t, l), e
								}();
								t.default = l
							},
							"./src/controller/fps-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/events.ts"),
									i = r("./src/utils/logger.ts"),
									s = function() {
										function e(e) {
											this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners()
										}
										var t = e.prototype;
										return t.setStreamController = function(e) {
											this.streamController = e
										}, t.registerListeners = function() {
											this.hls.on(n.Events.MEDIA_ATTACHING, this.onMediaAttaching, this)
										}, t.unregisterListeners = function() {
											this.hls.off(n.Events.MEDIA_ATTACHING, this.onMediaAttaching)
										}, t.destroy = function() {
											this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
										}, t.onMediaAttaching = function(e, t) {
											var r = this.hls.config;
											if (r.capLevelOnFPSDrop) {
												var n = t.media instanceof self.HTMLVideoElement ? t.media : null;
												this.media = n, n && "function" == typeof n.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod)
											}
										}, t.checkFPS = function(e, t, r) {
											var s = performance.now();
											if (t) {
												if (this.lastTime) {
													var a = s - this.lastTime,
														o = r - this.lastDroppedFrames,
														l = t - this.lastDecodedFrames,
														u = 1e3 * o / a,
														c = this.hls;
													if (c.trigger(n.Events.FPS_DROP, {
														currentDropped: o,
														currentDecoded: l,
														totalDroppedFrames: r
													}), u > 0 && o > c.config.fpsDroppedMonitoringThreshold * l) {
														var d = c.currentLevel;
														i.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + d), d > 0 && (-1 === c.autoLevelCapping || c.autoLevelCapping >= d) && (d -= 1, c.trigger(n.Events.FPS_DROP_LEVEL_CAPPING, {
															level: d,
															droppedLevel: c.currentLevel
														}), c.autoLevelCapping = d, this.streamController.nextLevelSwitch())
													}
												}
												this.lastTime = s, this.lastDroppedFrames = r, this.lastDecodedFrames = t
											}
										}, t.checkFPSInterval = function() {
											var e = this.media;
											if (e)
												if (this.isVideoPlaybackQualityAvailable) {
													var t = e.getVideoPlaybackQuality();
													this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
												} else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
										}, e
									}();
								t.default = s
							},
							"./src/controller/fragment-finders.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "findFragmentByPDT", (function() {
									return s
								})), r.d(t, "findFragmentByPTS", (function() {
									return a
								})), r.d(t, "fragmentWithinToleranceTest", (function() {
									return o
								})), r.d(t, "pdtWithinToleranceTest", (function() {
									return l
								})), r.d(t, "findFragWithCC", (function() {
									return u
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/utils/binary-search.ts");

								function s(e, t, r) {
									if (null === t || !Array.isArray(e) || !e.length || !Object(n.isFiniteNumber)(t)) return null;
									if (t < (e[0].programDateTime || 0)) return null;
									if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;
									r = r || 0;
									for (var i = 0; i < e.length; ++i) {
										var s = e[i];
										if (l(t, r, s)) return s
									}
									return null
								}

								function a(e, t, r, n) {
									void 0 === r && (r = 0), void 0 === n && (n = 0);
									var s = null;
									if (e ? s = t[e.sn - t[0].sn + 1] || null : 0 === r && 0 === t[0].start && (s = t[0]), s && 0 === o(r, n, s)) return s;
									var a = i.default.search(t, o.bind(null, r, n));
									return a || s
								}

								function o(e, t, r) {
									void 0 === e && (e = 0), void 0 === t && (t = 0);
									var n = Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
									return r.start + r.duration - n <= e ? 1 : r.start - n > e && r.start ? -1 : 0
								}

								function l(e, t, r) {
									var n = 1e3 * Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
									return (r.endProgramDateTime || 0) - n > e
								}

								function u(e, t) {
									return i.default.search(e, (function(e) {
										return e.cc < t ? 1 : e.cc > t ? -1 : 0
									}))
								}
							},
							"./src/controller/fragment-tracker.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "FragmentState", (function() {
									return n
								})), r.d(t, "FragmentTracker", (function() {
									return a
								}));
								var n, i = r("./src/events.ts"),
									s = r("./src/types/loader.ts");
								! function(e) {
									e.NOT_LOADED = "NOT_LOADED", e.BACKTRACKED = "BACKTRACKED", e.APPENDING = "APPENDING", e.PARTIAL = "PARTIAL", e.OK = "OK"
								}(n || (n = {}));
								var a = function() {
									function e(e) {
										this.activeFragment = null, this.activeParts = null, this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hls = e, this._registerListeners()
									}
									var t = e.prototype;
									return t._registerListeners = function() {
										var e = this.hls;
										e.on(i.Events.BUFFER_APPENDED, this.onBufferAppended, this), e.on(i.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.on(i.Events.FRAG_LOADED, this.onFragLoaded, this)
									}, t._unregisterListeners = function() {
										var e = this.hls;
										e.off(i.Events.BUFFER_APPENDED, this.onBufferAppended, this), e.off(i.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.off(i.Events.FRAG_LOADED, this.onFragLoaded, this)
									}, t.destroy = function() {
										this._unregisterListeners(), this.fragments = this.timeRanges = null
									}, t.getAppendedFrag = function(e, t) {
										if (t === s.PlaylistLevelType.MAIN) {
											var r = this.activeFragment,
												n = this.activeParts;
											if (!r) return null;
											if (n)
												for (var i = n.length; i--;) {
													var a = n[i],
														o = a ? a.end : r.appendedPTS;
													if (a.start <= e && void 0 !== o && e <= o) return i > 9 && (this.activeParts = n.slice(i - 9)), a
												} else if (r.start <= e && void 0 !== r.appendedPTS && e <= r.appendedPTS) return r
										}
										return this.getBufferedFrag(e, t)
									}, t.getBufferedFrag = function(e, t) {
										for (var r = this.fragments, n = Object.keys(r), i = n.length; i--;) {
											var s = r[n[i]];
											if ((null == s ? void 0 : s.body.type) === t && s.buffered) {
												var a = s.body;
												if (a.start <= e && e <= a.end) return a
											}
										}
										return null
									}, t.detectEvictedFragments = function(e, t, r) {
										var n = this;
										Object.keys(this.fragments)
											.forEach((function(i) {
												var s = n.fragments[i];
												if (s)
													if (s.buffered) {
														var a = s.range[e];
														a && a.time.some((function(e) {
															var r = !n.isTimeBuffered(e.startPTS, e.endPTS, t);
															return r && n.removeFragment(s.body), r
														}))
													} else s.body.type === r && n.removeFragment(s.body)
											}))
									}, t.detectPartialFragments = function(e) {
										var t = this,
											r = this.timeRanges,
											n = e.frag,
											i = e.part;
										if (r && "initSegment" !== n.sn) {
											var s = l(n),
												a = this.fragments[s];
											a && (Object.keys(r)
												.forEach((function(e) {
													var s = n.elementaryStreams[e];
													if (s) {
														var o = r[e],
															l = null !== i || !0 === s.partial;
														a.range[e] = t.getBufferedTimes(n, i, l, o)
													}
												})), a.backtrack = a.loaded = null, Object.keys(a.range)
												.length ? a.buffered = !0 : this.removeFragment(a.body))
										}
									}, t.fragBuffered = function(e) {
										var t = l(e),
											r = this.fragments[t];
										r && (r.backtrack = r.loaded = null, r.buffered = !0)
									}, t.getBufferedTimes = function(e, t, r, n) {
										for (var i = {
											time: [],
											partial: r
										}, s = t ? t.start : e.start, a = t ? t.end : e.end, o = e.minEndPTS || a, l = e.maxStartPTS || s, u = 0; u < n.length; u++) {
											var c = n.start(u) - this.bufferPadding,
												d = n.end(u) + this.bufferPadding;
											if (l >= c && o <= d) {
												i.time.push({
													startPTS: Math.max(s, n.start(u)),
													endPTS: Math.min(a, n.end(u))
												});
												break
											}
											if (s < d && a > c) i.partial = !0, i.time.push({
												startPTS: Math.max(s, n.start(u)),
												endPTS: Math.min(a, n.end(u))
											});
											else if (a <= c) break
										}
										return i
									}, t.getPartialFragment = function(e) {
										var t, r, n, i = null,
											s = 0,
											a = this.bufferPadding,
											l = this.fragments;
										return Object.keys(l)
											.forEach((function(u) {
												var c = l[u];
												c && o(c) && (r = c.body.start - a, n = c.body.end + a, e >= r && e <= n && (t = Math.min(e - r, n - e), s <= t && (i = c.body, s = t)))
											})), i
									}, t.getState = function(e) {
										var t = l(e),
											r = this.fragments[t];
										return r ? r.buffered ? o(r) ? n.PARTIAL : n.OK : r.backtrack ? n.BACKTRACKED : n.APPENDING : n.NOT_LOADED
									}, t.backtrack = function(e, t) {
										var r = l(e),
											n = this.fragments[r];
										if (!n || n.backtrack) return null;
										var i = n.backtrack = t || n.loaded;
										return n.loaded = null, i
									}, t.getBacktrackData = function(e) {
										var t = l(e),
											r = this.fragments[t];
										if (r) {
											var n, i = r.backtrack;
											if (null != i && null !== (n = i.payload) && void 0 !== n && n.byteLength) return i;
											this.removeFragment(e)
										}
										return null
									}, t.isTimeBuffered = function(e, t, r) {
										for (var n, i, s = 0; s < r.length; s++) {
											if (n = r.start(s) - this.bufferPadding, i = r.end(s) + this.bufferPadding, e >= n && t <= i) return !0;
											if (t <= n) return !1
										}
										return !1
									}, t.onFragLoaded = function(e, t) {
										var r = t.frag,
											n = t.part;
										if ("initSegment" !== r.sn && !r.bitrateTest && !n) {
											var i = l(r);
											this.fragments[i] = {
												body: r,
												loaded: t,
												backtrack: null,
												buffered: !1,
												range: Object.create(null)
											}
										}
									}, t.onBufferAppended = function(e, t) {
										var r = this,
											n = t.frag,
											i = t.part,
											a = t.timeRanges;
										if (n.type === s.PlaylistLevelType.MAIN)
											if (this.activeFragment = n, i) {
												var o = this.activeParts;
												o || (this.activeParts = o = []), o.push(i)
											} else this.activeParts = null;
										this.timeRanges = a, Object.keys(a)
											.forEach((function(e) {
												var t = a[e];
												if (r.detectEvictedFragments(e, t), !i)
													for (var s = 0; s < t.length; s++) n.appendedPTS = Math.max(t.end(s), n.appendedPTS || 0)
											}))
									}, t.onFragBuffered = function(e, t) {
										this.detectPartialFragments(t)
									}, t.hasFragment = function(e) {
										var t = l(e);
										return !!this.fragments[t]
									}, t.removeFragmentsInRange = function(e, t, r) {
										var n = this;
										Object.keys(this.fragments)
											.forEach((function(i) {
												var s = n.fragments[i];
												if (s && s.buffered) {
													var a = s.body;
													a.type === r && a.start < t && a.end > e && n.removeFragment(a)
												}
											}))
									}, t.removeFragment = function(e) {
										var t = l(e);
										e.stats.loaded = 0, e.clearElementaryStreamInfo(), delete this.fragments[t]
									}, t.removeAllFragments = function() {
										this.fragments = Object.create(null), this.activeFragment = null, this.activeParts = null
									}, e
								}();

								function o(e) {
									var t, r;
									return e.buffered && ((null === (t = e.range.video) || void 0 === t ? void 0 : t.partial) || (null === (r = e.range.audio) || void 0 === r ? void 0 : r.partial))
								}

								function l(e) {
									return e.type + "_" + e.level + "_" + e.urlId + "_" + e.sn
								}
							},
							"./src/controller/gap-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "STALL_MINIMUM_DURATION_MS", (function() {
									return o
								})), r.d(t, "MAX_START_GAP_JUMP", (function() {
									return l
								})), r.d(t, "SKIP_BUFFER_HOLE_STEP_SECONDS", (function() {
									return u
								})), r.d(t, "SKIP_BUFFER_RANGE_START", (function() {
									return c
								})), r.d(t, "default", (function() {
									return d
								}));
								var n = r("./src/utils/buffer-helper.ts"),
									i = r("./src/errors.ts"),
									s = r("./src/events.ts"),
									a = r("./src/utils/logger.ts"),
									o = 250,
									l = 2,
									u = .1,
									c = .05,
									d = function() {
										function e(e, t, r, n) {
											this.config = void 0, this.media = void 0, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = r, this.hls = n
										}
										var t = e.prototype;
										return t.destroy = function() {
											this.hls = this.fragmentTracker = this.media = null
										}, t.poll = function(e) {
											var t = this.config,
												r = this.media,
												i = this.stalled,
												s = r.currentTime,
												u = r.seeking,
												c = this.seeking && !u,
												d = !this.seeking && u;
											if (this.seeking = u, s === e) {
												if ((d || c) && (this.stalled = null), !r.paused && !r.ended && 0 !== r.playbackRate && n.BufferHelper.getBuffered(r)
													.length) {
													var f = n.BufferHelper.bufferInfo(r, s, 0),
														h = f.len > 0,
														g = f.nextStart || 0;
													if (h || g) {
														if (u) {
															var v = f.len > l,
																p = !g || g - s > l && !this.fragmentTracker.getPartialFragment(s);
															if (v || p) return;
															this.moved = !1
														}
														if (!this.moved && null !== this.stalled) {
															var m, y = Math.max(g, f.start || 0) - s,
																b = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
																E = (null == b || null === (m = b.details) || void 0 === m ? void 0 : m.live) ? 2 * b.details.targetduration : l;
															if (y > 0 && y <= E) return void this._trySkipBufferHole(null)
														}
														var _ = self.performance.now();
														if (null !== i) {
															var T = _ - i;
															!u && T >= o && this._reportStall(f.len);
															var S = n.BufferHelper.bufferInfo(r, s, t.maxBufferHole);
															this._tryFixBufferStall(S, T)
														} else this.stalled = _
													}
												}
											} else if (this.moved = !0, null !== i) {
												if (this.stallReported) {
													var A = self.performance.now() - i;
													a.logger.warn("playback not stuck anymore @" + s + ", after " + Math.round(A) + "ms"), this.stallReported = !1
												}
												this.stalled = null, this.nudgeRetry = 0
											}
										}, t._tryFixBufferStall = function(e, t) {
											var r = this.config,
												n = this.fragmentTracker,
												i = this.media.currentTime,
												s = n.getPartialFragment(i);
											s && this._trySkipBufferHole(s) || e.len > r.maxBufferHole && t > 1e3 * r.highBufferWatchdogPeriod && (a.logger.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
										}, t._reportStall = function(e) {
											var t = this.hls,
												r = this.media;
											this.stallReported || (this.stallReported = !0, a.logger.warn("Playback stalling at @" + r.currentTime + " due to low buffer (buffer=" + e + ")"), t.trigger(s.Events.ERROR, {
												type: i.ErrorTypes.MEDIA_ERROR,
												details: i.ErrorDetails.BUFFER_STALLED_ERROR,
												fatal: !1,
												buffer: e
											}))
										}, t._trySkipBufferHole = function(e) {
											for (var t = this.config, r = this.hls, o = this.media, l = o.currentTime, d = 0, f = n.BufferHelper.getBuffered(o), h = 0; h < f.length; h++) {
												var g = f.start(h);
												if (l + t.maxBufferHole >= d && l < g) {
													var v = Math.max(g + c, o.currentTime + u);
													return a.logger.warn("skipping hole, adjusting currentTime from " + l + " to " + v), this.moved = !0, this.stalled = null, o.currentTime = v, e && r.trigger(s.Events.ERROR, {
														type: i.ErrorTypes.MEDIA_ERROR,
														details: i.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
														fatal: !1,
														reason: "fragment loaded with buffer holes, seeking from " + l + " to " + v,
														frag: e
													}), v
												}
												d = f.end(h)
											}
											return 0
										}, t._tryNudgeBuffer = function() {
											var e = this.config,
												t = this.hls,
												r = this.media,
												n = r.currentTime,
												o = (this.nudgeRetry || 0) + 1;
											if (this.nudgeRetry = o, o < e.nudgeMaxRetry) {
												var l = n + o * e.nudgeOffset;
												a.logger.warn("Nudging 'currentTime' from " + n + " to " + l), r.currentTime = l, t.trigger(s.Events.ERROR, {
													type: i.ErrorTypes.MEDIA_ERROR,
													details: i.ErrorDetails.BUFFER_NUDGE_ON_STALL,
													fatal: !1
												})
											} else a.logger.error("Playhead still not moving while enough data buffered @" + n + " after " + e.nudgeMaxRetry + " nudges"), t.trigger(s.Events.ERROR, {
												type: i.ErrorTypes.MEDIA_ERROR,
												details: i.ErrorDetails.BUFFER_STALLED_ERROR,
												fatal: !0
											})
										}, e
									}()
							},
							"./src/controller/id3-track-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/events.ts"),
									i = r("./src/utils/texttrack-utils.ts"),
									s = r("./src/demux/id3.ts"),
									a = function() {
										function e(e) {
											this.hls = void 0, this.id3Track = null, this.media = null, this.hls = e, this._registerListeners()
										}
										var t = e.prototype;
										return t.destroy = function() {
											this._unregisterListeners()
										}, t._registerListeners = function() {
											var e = this.hls;
											e.on(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(n.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(n.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
										}, t._unregisterListeners = function() {
											var e = this.hls;
											e.off(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(n.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(n.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
										}, t.onMediaAttached = function(e, t) {
											this.media = t.media
										}, t.onMediaDetaching = function() {
											this.id3Track && (Object(i.clearCurrentCues)(this.id3Track), this.id3Track = null, this.media = null)
										}, t.getID3Track = function(e) {
											if (this.media) {
												for (var t = 0; t < e.length; t++) {
													var r = e[t];
													if ("metadata" === r.kind && "id3" === r.label) return Object(i.sendAddTrackEvent)(r, this.media), r
												}
												return this.media.addTextTrack("metadata", "id3")
											}
										}, t.onFragParsingMetadata = function(e, t) {
											if (this.media) {
												var r = t.frag,
													n = t.samples;
												this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = "hidden");
												for (var i = self.WebKitDataCue || self.VTTCue || self.TextTrackCue, a = 0; a < n.length; a++) {
													var o = s.getID3Frames(n[a].data);
													if (o) {
														var l = n[a].pts,
															u = a < n.length - 1 ? n[a + 1].pts : r.end;
														u - l <= 0 && (u = l + .25);
														for (var c = 0; c < o.length; c++) {
															var d = o[c];
															if (!s.isTimeStampFrame(d)) {
																var f = new i(l, u, "");
																f.value = d, this.id3Track.addCue(f)
															}
														}
													}
												}
											}
										}, t.onBufferFlushing = function(e, t) {
											var r = t.startOffset,
												n = t.endOffset,
												s = t.type;
											if (!s || "audio" === s) {
												var a = this.id3Track;
												a && Object(i.removeCuesInRange)(a, r, n)
											}
										}, e
									}();
								t.default = a
							},
							"./src/controller/latency-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return o
								}));
								var n = r("./src/errors.ts"),
									i = r("./src/events.ts"),
									s = r("./src/utils/logger.ts");

								function a(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var o = function() {
									function e(e) {
										var t = this;
										this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function() {
											return t.timeupdate()
										}, this.hls = e, this.config = e.config, this.registerListeners()
									}
									var t, r, o, l = e.prototype;
									return l.destroy = function() {
										this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
									}, l.registerListeners = function() {
										this.hls.on(i.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(i.Events.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(i.Events.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(i.Events.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(i.Events.ERROR, this.onError, this)
									}, l.unregisterListeners = function() {
										this.hls.off(i.Events.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(i.Events.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(i.Events.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(i.Events.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(i.Events.ERROR, this.onError)
									}, l.onMediaAttached = function(e, t) {
										this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
									}, l.onMediaDetaching = function() {
										this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
									}, l.onManifestLoading = function() {
										this.levelDetails = null, this._latency = null, this.stallCount = 0
									}, l.onLevelUpdated = function(e, t) {
										var r = t.details;
										this.levelDetails = r, r.advanced && this.timeupdate(), !r.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
									}, l.onError = function(e, t) {
										t.details === n.ErrorDetails.BUFFER_STALLED_ERROR && (this.stallCount++, s.logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
									}, l.timeupdate = function() {
										var e = this.media,
											t = this.levelDetails;
										if (e && t) {
											this.currentTime = e.currentTime;
											var r = this.computeLatency();
											if (null !== r) {
												this._latency = r;
												var n = this.config,
													i = n.lowLatencyMode,
													s = n.maxLiveSyncPlaybackRate;
												if (i && 1 !== s) {
													var a = this.targetLatency;
													if (null !== a) {
														var o = r - a,
															l = o < Math.min(this.maxLatency, a + t.targetduration);
														if (t.live && l && o > .05 && this.forwardBufferLength > 1) {
															var u = Math.min(2, Math.max(1, s)),
																c = Math.round(2 / (1 + Math.exp(-.75 * o - this.edgeStalled)) * 20) / 20;
															e.playbackRate = Math.min(u, Math.max(1, c))
														} else 1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1)
													}
												}
											}
										}
									}, l.estimateLiveEdge = function() {
										var e = this.levelDetails;
										return null === e ? null : e.edge + e.age
									}, l.computeLatency = function() {
										var e = this.estimateLiveEdge();
										return null === e ? null : e - this.currentTime
									}, t = e, (r = [{
										key: "latency",
										get: function() {
											return this._latency || 0
										}
									}, {
										key: "maxLatency",
										get: function() {
											var e = this.config,
												t = this.levelDetails;
											return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
										}
									}, {
										key: "targetLatency",
										get: function() {
											var e = this.levelDetails;
											if (null === e) return null;
											var t = e.holdBack,
												r = e.partHoldBack,
												n = e.targetduration,
												i = this.config,
												s = i.liveSyncDuration,
												a = i.liveSyncDurationCount,
												o = i.lowLatencyMode,
												l = this.hls.userConfig,
												u = o && r || t;
											(l.liveSyncDuration || l.liveSyncDurationCount || 0 === u) && (u = void 0 !== s ? s : a * n);
											var c = n;
											return u + Math.min(1 * this.stallCount, c)
										}
									}, {
										key: "liveSyncPosition",
										get: function() {
											var e = this.estimateLiveEdge(),
												t = this.targetLatency,
												r = this.levelDetails;
											if (null === e || null === t || null === r) return null;
											var n = r.edge,
												i = e - t - this.edgeStalled,
												s = n - r.totalduration,
												a = n - (this.config.lowLatencyMode && r.partTarget || r.targetduration);
											return Math.min(Math.max(s, i), a)
										}
									}, {
										key: "drift",
										get: function() {
											var e = this.levelDetails;
											return null === e ? 1 : e.drift
										}
									}, {
										key: "edgeStalled",
										get: function() {
											var e = this.levelDetails;
											if (null === e) return 0;
											var t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);
											return Math.max(e.age - t, 0)
										}
									}, {
										key: "forwardBufferLength",
										get: function() {
											var e = this.media,
												t = this.levelDetails;
											if (!e || !t) return 0;
											var r = e.buffered.length;
											return r ? e.buffered.end(r - 1) : t.edge - this.currentTime
										}
									}]) && a(t.prototype, r), o && a(t, o), e
								}()
							},
							"./src/controller/level-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return g
								}));
								var n = r("./src/types/level.ts"),
									i = r("./src/events.ts"),
									s = r("./src/errors.ts"),
									a = r("./src/utils/codecs.ts"),
									o = r("./src/controller/level-helper.ts"),
									l = r("./src/controller/base-playlist-controller.ts"),
									u = r("./src/types/loader.ts");

								function c() {
									return c = Object.assign || function(e) {
										for (var t = 1; t < arguments.length; t++) {
											var r = arguments[t];
											for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
										}
										return e
									}, c.apply(this, arguments)
								}

								function d(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function f(e, t) {
									return f = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, f(e, t)
								}
								var h = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
									g = function(e) {
										var t, r;

										function l(t) {
											var r;
											return (r = e.call(this, t, "[level-controller]") || this)
												._levels = [], r._firstLevel = -1, r._startLevel = void 0, r.currentLevelIndex = -1, r.manualLevelIndex = -1, r.onParsedComplete = void 0, r._registerListeners(), r
										}
										r = e, (t = l)
											.prototype = Object.create(r.prototype), t.prototype.constructor = t, f(t, r);
										var g, v, p, m = l.prototype;
										return m._registerListeners = function() {
											var e = this.hls;
											e.on(i.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(i.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(i.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(i.Events.FRAG_LOADED, this.onFragLoaded, this), e.on(i.Events.ERROR, this.onError, this)
										}, m._unregisterListeners = function() {
											var e = this.hls;
											e.off(i.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(i.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(i.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(i.Events.FRAG_LOADED, this.onFragLoaded, this), e.off(i.Events.ERROR, this.onError, this)
										}, m.destroy = function() {
											this._unregisterListeners(), this.manualLevelIndex = -1, this._levels.length = 0, e.prototype.destroy.call(this)
										}, m.startLoad = function() {
											this._levels.forEach((function(e) {
												e.loadError = 0
											})), e.prototype.startLoad.call(this)
										}, m.onManifestLoaded = function(e, t) {
											var r, l, u = [],
												c = [],
												d = [],
												f = {},
												g = !1,
												v = !1,
												p = !1;
											if (t.levels.forEach((function(e) {
												var t = e.attrs;
												g = g || !(!e.width || !e.height), v = v || !!e.videoCodec, p = p || !!e.audioCodec, h && e.audioCodec && -1 !== e.audioCodec.indexOf("mp4a.40.34") && (e.audioCodec = void 0);
												var r = e.bitrate + "-" + e.attrs.RESOLUTION + "-" + e.attrs.CODECS;
												(l = f[r]) ? l.url.push(e.url): (l = new n.Level(e), f[r] = l, u.push(l)), t && (t.AUDIO && Object(o.addGroupId)(l, "audio", t.AUDIO), t.SUBTITLES && Object(o.addGroupId)(l, "text", t.SUBTITLES))
											})), (g || v) && p && (u = u.filter((function(e) {
												var t = e.videoCodec,
													r = e.width,
													n = e.height;
												return !!t || !(!r || !n)
											}))), u = u.filter((function(e) {
												var t = e.audioCodec,
													r = e.videoCodec;
												return (!t || Object(a.isCodecSupportedInMp4)(t, "audio")) && (!r || Object(a.isCodecSupportedInMp4)(r, "video"))
											})), t.audioTracks && (c = t.audioTracks.filter((function(e) {
												return !e.audioCodec || Object(a.isCodecSupportedInMp4)(e.audioCodec, "audio")
											})), Object(o.assignTrackIdsByGroup)(c)), t.subtitles && (d = t.subtitles, Object(o.assignTrackIdsByGroup)(d)), u.length > 0) {
												r = u[0].bitrate, u.sort((function(e, t) {
													return e.bitrate - t.bitrate
												})), this._levels = u;
												for (var m = 0; m < u.length; m++)
													if (u[m].bitrate === r) {
														this._firstLevel = m, this.log("manifest loaded, " + u.length + " level(s) found, first bitrate: " + r);
														break
													} var y = p && !v,
													b = {
														levels: u,
														audioTracks: c,
														subtitleTracks: d,
														firstLevel: this._firstLevel,
														stats: t.stats,
														audio: p,
														video: v,
														altAudio: !y && c.some((function(e) {
															return !!e.url
														}))
													};
												this.hls.trigger(i.Events.MANIFEST_PARSED, b), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
											} else this.hls.trigger(i.Events.ERROR, {
												type: s.ErrorTypes.MEDIA_ERROR,
												details: s.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
												fatal: !0,
												url: t.url,
												reason: "no level with compatible codecs found in manifest"
											})
										}, m.onError = function(t, r) {
											if (e.prototype.onError.call(this, t, r), !r.fatal) {
												var n = r.context,
													i = this._levels[this.currentLevelIndex];
												if (n && (n.type === u.PlaylistContextType.AUDIO_TRACK && i.audioGroupIds && n.groupId === i.audioGroupIds[i.urlId] || n.type === u.PlaylistContextType.SUBTITLE_TRACK && i.textGroupIds && n.groupId === i.textGroupIds[i.urlId])) this.redundantFailover(this.currentLevelIndex);
												else {
													var a, o = !1,
														l = !0;
													switch (r.details) {
														case s.ErrorDetails.FRAG_LOAD_ERROR:
														case s.ErrorDetails.FRAG_LOAD_TIMEOUT:
														case s.ErrorDetails.KEY_LOAD_ERROR:
														case s.ErrorDetails.KEY_LOAD_TIMEOUT:
															if (r.frag) {
																var c = this._levels[r.frag.level];
																c ? (c.fragmentError++, c.fragmentError > this.hls.config.fragLoadingMaxRetry && (a = r.frag.level)) : a = r.frag.level
															}
															break;
														case s.ErrorDetails.LEVEL_LOAD_ERROR:
														case s.ErrorDetails.LEVEL_LOAD_TIMEOUT:
															n && (n.deliveryDirectives && (l = !1), a = n.level), o = !0;
															break;
														case s.ErrorDetails.REMUX_ALLOC_ERROR:
															a = r.level, o = !0
													}
													void 0 !== a && this.recoverLevel(r, a, o, l)
												}
											}
										}, m.recoverLevel = function(e, t, r, n) {
											var i = e.details,
												s = this._levels[t];
											if (s.loadError++, r) {
												if (!this.retryLoadingOrFail(e)) return void(this.currentLevelIndex = -1);
												e.levelRetry = !0
											}
											if (n) {
												var a = s.url.length;
												if (a > 1 && s.loadError < a) e.levelRetry = !0, this.redundantFailover(t);
												else if (-1 === this.manualLevelIndex) {
													var o = 0 === t ? this._levels.length - 1 : t - 1;
													this.currentLevelIndex !== o && 0 === this._levels[o].loadError && (this.warn(i + ": switch to " + o), e.levelRetry = !0, this.hls.nextAutoLevel = o)
												}
											}
										}, m.redundantFailover = function(e) {
											var t = this._levels[e],
												r = t.url.length;
											if (r > 1) {
												var n = (t.urlId + 1) % r;
												this.warn("Switching to redundant URL-id " + n), this._levels.forEach((function(e) {
													e.urlId = n
												})), this.level = e
											}
										}, m.onFragLoaded = function(e, t) {
											var r = t.frag;
											if (void 0 !== r && r.type === u.PlaylistLevelType.MAIN) {
												var n = this._levels[r.level];
												void 0 !== n && (n.fragmentError = 0, n.loadError = 0)
											}
										}, m.onLevelLoaded = function(e, t) {
											var r, n, i = t.level,
												s = t.details,
												a = this._levels[i];
											if (!a) return this.warn("Invalid level index " + i), void(null !== (n = t.deliveryDirectives) && void 0 !== n && n.skip && (s.deltaUpdateFailed = !0));
											i === this.currentLevelIndex ? (0 === a.fragmentError && (a.loadError = 0, this.retryCount = 0), this.playlistLoaded(i, t, a.details)) : null !== (r = t.deliveryDirectives) && void 0 !== r && r.skip && (s.deltaUpdateFailed = !0)
										}, m.onAudioTrackSwitched = function(e, t) {
											var r = this.hls.levels[this.currentLevelIndex];
											if (r && r.audioGroupIds) {
												for (var n = -1, i = this.hls.audioTracks[t.id].groupId, s = 0; s < r.audioGroupIds.length; s++)
													if (r.audioGroupIds[s] === i) {
														n = s;
														break
													} n !== r.urlId && (r.urlId = n, this.startLoad())
											}
										}, m.loadPlaylist = function(e) {
											var t = this.currentLevelIndex,
												r = this._levels[t];
											if (this.canLoad && r && r.url.length > 0) {
												var n = r.urlId,
													s = r.url[n];
												if (e) try {
													s = e.addDirectives(s)
												} catch (e) {
													this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
												}
												this.log("Attempt loading level index " + t + (e ? " at sn " + e.msn + " part " + e.part : "") + " with URL-id " + n + " " + s), this.clearTimer(), this.hls.trigger(i.Events.LEVEL_LOADING, {
													url: s,
													level: t,
													id: n,
													deliveryDirectives: e || null
												})
											}
										}, m.removeLevel = function(e, t) {
											var r = function(e, r) {
													return r !== t
												},
												n = this._levels.filter((function(n, i) {
													return i !== e || n.url.length > 1 && void 0 !== t && (n.url = n.url.filter(r), n.audioGroupIds && (n.audioGroupIds = n.audioGroupIds.filter(r)), n.textGroupIds && (n.textGroupIds = n.textGroupIds.filter(r)), n.urlId = 0, !0)
												}))
												.map((function(e, t) {
													var r = e.details;
													return null != r && r.fragments && r.fragments.forEach((function(e) {
														e.level = t
													})), e
												}));
											this._levels = n, this.hls.trigger(i.Events.LEVELS_UPDATED, {
												levels: n
											})
										}, g = l, (v = [{
											key: "levels",
											get: function() {
												return 0 === this._levels.length ? null : this._levels
											}
										}, {
											key: "level",
											get: function() {
												return this.currentLevelIndex
											},
											set: function(e) {
												var t, r = this._levels;
												if (0 !== r.length && (this.currentLevelIndex !== e || null === (t = r[e]) || void 0 === t || !t.details)) {
													if (e < 0 || e >= r.length) {
														var n = e < 0;
														if (this.hls.trigger(i.Events.ERROR, {
															type: s.ErrorTypes.OTHER_ERROR,
															details: s.ErrorDetails.LEVEL_SWITCH_ERROR,
															level: e,
															fatal: n,
															reason: "invalid level idx"
														}), n) return;
														e = Math.min(e, r.length - 1)
													}
													this.clearTimer();
													var a = this.currentLevelIndex,
														o = r[a],
														l = r[e];
													this.log("switching to level " + e + " from " + a), this.currentLevelIndex = e;
													var u = c({}, l, {
														level: e,
														maxBitrate: l.maxBitrate,
														uri: l.uri,
														urlId: l.urlId
													});
													delete u._urlId, this.hls.trigger(i.Events.LEVEL_SWITCHING, u);
													var d = l.details;
													if (!d || d.live) {
														var f = this.switchParams(l.uri, null == o ? void 0 : o.details);
														this.loadPlaylist(f)
													}
												}
											}
										}, {
											key: "manualLevel",
											get: function() {
												return this.manualLevelIndex
											},
											set: function(e) {
												this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e)
											}
										}, {
											key: "firstLevel",
											get: function() {
												return this._firstLevel
											},
											set: function(e) {
												this._firstLevel = e
											}
										}, {
											key: "startLevel",
											get: function() {
												if (void 0 === this._startLevel) {
													var e = this.hls.config.startLevel;
													return void 0 !== e ? e : this._firstLevel
												}
												return this._startLevel
											},
											set: function(e) {
												this._startLevel = e
											}
										}, {
											key: "nextLoadLevel",
											get: function() {
												return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
											},
											set: function(e) {
												this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
											}
										}]) && d(g.prototype, v), p && d(g, p), l
									}(l.default)
							},
							"./src/controller/level-helper.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "addGroupId", (function() {
									return s
								})), r.d(t, "assignTrackIdsByGroup", (function() {
									return a
								})), r.d(t, "updatePTS", (function() {
									return o
								})), r.d(t, "updateFragPTSDTS", (function() {
									return u
								})), r.d(t, "mergeDetails", (function() {
									return c
								})), r.d(t, "mapPartIntersection", (function() {
									return d
								})), r.d(t, "mapFragmentIntersection", (function() {
									return f
								})), r.d(t, "adjustSliding", (function() {
									return h
								})), r.d(t, "addSliding", (function() {
									return g
								})), r.d(t, "computeReloadInterval", (function() {
									return v
								})), r.d(t, "getFragmentWithSN", (function() {
									return p
								})), r.d(t, "getPartWith", (function() {
									return m
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/utils/logger.ts");

								function s(e, t, r) {
									switch (t) {
										case "audio":
											e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds.push(r);
											break;
										case "text":
											e.textGroupIds || (e.textGroupIds = []), e.textGroupIds.push(r)
									}
								}

								function a(e) {
									var t = {};
									e.forEach((function(e) {
										var r = e.groupId || "";
										e.id = t[r] = t[r] || 0, t[r]++
									}))
								}

								function o(e, t, r) {
									l(e[t], e[r])
								}

								function l(e, t) {
									var r = t.startPTS;
									if (Object(n.isFiniteNumber)(r)) {
										var i, s = 0;
										t.sn > e.sn ? (s = r - e.start, i = e) : (s = e.start - r, i = t), i.duration !== s && (i.duration = s)
									} else t.sn > e.sn ? e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration : t.start = Math.max(e.start - t.duration, 0)
								}

								function u(e, t, r, s, a, o) {
									s - r <= 0 && (i.logger.warn("Fragment should have a positive duration", t), s = r + t.duration, o = a + t.duration);
									var u = r,
										c = s,
										d = t.startPTS,
										f = t.endPTS;
									if (Object(n.isFiniteNumber)(d)) {
										var h = Math.abs(d - r);
										Object(n.isFiniteNumber)(t.deltaPTS) ? t.deltaPTS = Math.max(h, t.deltaPTS) : t.deltaPTS = h, u = Math.max(r, d), r = Math.min(r, d), a = Math.min(a, t.startDTS), c = Math.min(s, f), s = Math.max(s, f), o = Math.max(o, t.endDTS)
									}
									t.duration = s - r;
									var g = r - t.start;
									t.appendedPTS = s, t.start = t.startPTS = r, t.maxStartPTS = u, t.startDTS = a, t.endPTS = s, t.minEndPTS = c, t.endDTS = o;
									var v, p = t.sn;
									if (!e || p < e.startSN || p > e.endSN) return 0;
									var m = p - e.startSN,
										y = e.fragments;
									for (y[m] = t, v = m; v > 0; v--) l(y[v], y[v - 1]);
									for (v = m; v < y.length - 1; v++) l(y[v], y[v + 1]);
									return e.fragmentHint && l(y[y.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, g
								}

								function c(e, t) {
									for (var r = null, s = e.fragments, a = s.length - 1; a >= 0; a--) {
										var o = s[a].initSegment;
										if (o) {
											r = o;
											break
										}
									}
									e.fragmentHint && delete e.fragmentHint.endPTS;
									var l, c = 0;
									if (f(e, t, (function(e, i) {
											e.relurl && (c = e.cc - i.cc), Object(n.isFiniteNumber)(e.startPTS) && Object(n.isFiniteNumber)(e.endPTS) && (i.start = i.startPTS = e.startPTS, i.startDTS = e.startDTS, i.appendedPTS = e.appendedPTS, i.maxStartPTS = e.maxStartPTS, i.endPTS = e.endPTS, i.endDTS = e.endDTS, i.minEndPTS = e.minEndPTS, i.duration = e.endPTS - e.startPTS, i.duration && (l = i), t.PTSKnown = t.alignedSliding = !0), i.elementaryStreams = e.elementaryStreams, i.loader = e.loader, i.stats = e.stats, i.urlId = e.urlId, e.initSegment && (i.initSegment = e.initSegment, r = e.initSegment)
										})), r && (t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments)
										.forEach((function(e) {
											var t;
											e.initSegment && e.initSegment.relurl !== (null === (t = r) || void 0 === t ? void 0 : t.relurl) || (e.initSegment = r)
										})), t.skippedSegments && (t.deltaUpdateFailed = t.fragments.some((function(e) {
											return !e
										})), t.deltaUpdateFailed)) {
										i.logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
										for (var g = t.skippedSegments; g--;) t.fragments.shift();
										t.startSN = t.fragments[0].sn, t.startCC = t.fragments[0].cc
									}
									var v = t.fragments;
									if (c) {
										i.logger.warn("discontinuity sliding from playlist, take drift into account");
										for (var p = 0; p < v.length; p++) v[p].cc += c
									}
									t.skippedSegments && (t.startCC = t.fragments[0].cc), d(e.partList, t.partList, (function(e, t) {
										t.elementaryStreams = e.elementaryStreams, t.stats = e.stats
									})), l ? u(t, l, l.startPTS, l.endPTS, l.startDTS, l.endDTS) : h(e, t), v.length && (t.totalduration = t.edge - v[0].start), t.driftStartTime = e.driftStartTime, t.driftStart = e.driftStart;
									var m = t.advancedDateTime;
									if (t.advanced && m) {
										var y = t.edge;
										t.driftStart || (t.driftStartTime = m, t.driftStart = y), t.driftEndTime = m, t.driftEnd = y
									} else t.driftEndTime = e.driftEndTime, t.driftEnd = e.driftEnd, t.advancedDateTime = e.advancedDateTime
								}

								function d(e, t, r) {
									if (e && t)
										for (var n = 0, i = 0, s = e.length; i <= s; i++) {
											var a = e[i],
												o = t[i + n];
											a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? r(a, o) : n--
										}
								}

								function f(e, t, r) {
									for (var n = t.skippedSegments, i = Math.max(e.startSN, t.startSN) - t.startSN, s = (e.fragmentHint ? 1 : 0) + (n ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN, a = t.startSN - e.startSN, o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, u = i; u <= s; u++) {
										var c = l[a + u],
											d = o[u];
										n && !d && u < n && (d = t.fragments[u] = c), c && d && r(c, d)
									}
								}

								function h(e, t) {
									var r = t.startSN + t.skippedSegments - e.startSN,
										n = e.fragments;
									r < 0 || r >= n.length || g(t, n[r].start)
								}

								function g(e, t) {
									if (t) {
										for (var r = e.fragments, n = e.skippedSegments; n < r.length; n++) r[n].start += t;
										e.fragmentHint && (e.fragmentHint.start += t)
									}
								}

								function v(e, t) {
									var r, n = 1e3 * e.levelTargetDuration,
										i = n / 2,
										s = e.age,
										a = s > 0 && s < 3 * n,
										o = t.loading.end - t.loading.start,
										l = e.availabilityDelay;
									if (!1 === e.updated)
										if (a) {
											var u = 333 * e.misses;
											r = Math.max(Math.min(i, 2 * o), u), e.availabilityDelay = (e.availabilityDelay || 0) + r
										} else r = i;
									else a ? (l = Math.min(l || n / 2, s), e.availabilityDelay = l, r = l + n - s) : r = n - o;
									return Math.round(r)
								}

								function p(e, t, r) {
									if (!e || !e.details) return null;
									var n = e.details,
										i = n.fragments[t - n.startSN];
									return i || ((i = n.fragmentHint) && i.sn === t ? i : t < n.startSN && r && r.sn === t ? r : null)
								}

								function m(e, t, r) {
									if (!e || !e.details) return null;
									var n = e.details.partList;
									if (n)
										for (var i = n.length; i--;) {
											var s = n[i];
											if (s.index === r && s.fragment.sn === t) return s
										}
									return null
								}
							},
							"./src/controller/stream-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return y
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/controller/base-stream-controller.ts"),
									s = r("./src/is-supported.ts"),
									a = r("./src/events.ts"),
									o = r("./src/utils/buffer-helper.ts"),
									l = r("./src/controller/fragment-tracker.ts"),
									u = r("./src/types/loader.ts"),
									c = r("./src/loader/fragment.ts"),
									d = r("./src/demux/transmuxer-interface.ts"),
									f = r("./src/types/transmuxer.ts"),
									h = r("./src/controller/gap-controller.ts"),
									g = r("./src/errors.ts"),
									v = r("./src/utils/logger.ts");

								function p(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function m(e, t) {
									return m = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, m(e, t)
								}
								var y = function(e) {
									var t, r;

									function y(t, r) {
										var n;
										return (n = e.call(this, t, r, "[stream-controller]") || this)
											.audioCodecSwap = !1, n.gapController = null, n.level = -1, n._forceStartLoad = !1, n.altAudio = !1, n.audioOnly = !1, n.fragPlaying = null, n.onvplaying = null, n.onvseeked = null, n.fragLastKbps = 0, n.stalled = !1, n.couldBacktrack = !1, n.audioCodecSwitch = !1, n.videoBuffer = null, n._registerListeners(), n
									}
									r = e, (t = y)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, m(t, r);
									var b, E, _, T = y.prototype;
									return T._registerListeners = function() {
										var e = this.hls;
										e.on(a.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(a.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(a.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(a.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(a.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(a.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(a.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(a.Events.ERROR, this.onError, this), e.on(a.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(a.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(a.Events.BUFFER_CREATED, this.onBufferCreated, this), e.on(a.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(a.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(a.Events.FRAG_BUFFERED, this.onFragBuffered, this)
									}, T._unregisterListeners = function() {
										var e = this.hls;
										e.off(a.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(a.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(a.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(a.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(a.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(a.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(a.Events.ERROR, this.onError, this), e.off(a.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(a.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(a.Events.BUFFER_CREATED, this.onBufferCreated, this), e.off(a.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(a.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(a.Events.FRAG_BUFFERED, this.onFragBuffered, this)
									}, T.onHandlerDestroying = function() {
										this._unregisterListeners(), this.onMediaDetaching()
									}, T.startLoad = function(e) {
										if (this.levels) {
											var t = this.lastCurrentTime,
												r = this.hls;
											if (this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
												var n = r.startLevel; - 1 === n && (r.config.testBandwidth ? (n = 0, this.bitrateTest = !0) : n = r.nextAutoLevel), this.level = r.nextLoadLevel = n, this.loadedmetadata = !1
											}
											t > 0 && -1 === e && (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)), e = t), this.state = i.State.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
										} else this._forceStartLoad = !0, this.state = i.State.STOPPED
									}, T.stopLoad = function() {
										this._forceStartLoad = !1, e.prototype.stopLoad.call(this)
									}, T.doTick = function() {
										switch (this.state) {
											case i.State.IDLE:
												this.doTickIdle();
												break;
											case i.State.WAITING_LEVEL:
												var e, t = this.levels,
													r = this.level,
													n = null == t || null === (e = t[r]) || void 0 === e ? void 0 : e.details;
												if (n && (!n.live || this.levelLastLoaded === this.level)) {
													if (this.waitForCdnTuneIn(n)) break;
													this.state = i.State.IDLE;
													break
												}
												break;
											case i.State.FRAG_LOADING_WAITING_RETRY:
												var s, a = self.performance.now(),
													o = this.retryDate;
												(!o || a >= o || null !== (s = this.media) && void 0 !== s && s.seeking) && (this.log("retryDate reached, switch back to IDLE state"), this.state = i.State.IDLE)
										}
										this.onTickEnd()
									}, T.onTickEnd = function() {
										e.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged()
									}, T.doTickIdle = function() {
										var e, t, r = this.hls,
											n = this.levelLastLoaded,
											s = this.levels,
											o = this.media,
											d = r.config,
											f = r.nextLoadLevel;
										if (null !== n && (o || !this.startFragRequested && d.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && s && s[f]) {
											var h = s[f];
											this.level = r.nextLoadLevel = f;
											var g = h.details;
											if (!g || this.state === i.State.WAITING_LEVEL || g.live && this.levelLastLoaded !== f) this.state = i.State.WAITING_LEVEL;
											else {
												var v = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : o, u.PlaylistLevelType.MAIN);
												if (null !== v && !(v.len >= this.getMaxBufferLength(h.maxBitrate))) {
													if (this._streamEnded(v, g)) {
														var p = {};
														return this.altAudio && (p.type = "video"), this.hls.trigger(a.Events.BUFFER_EOS, p), void(this.state = i.State.ENDED)
													}
													var m = v.end,
														y = this.getNextFragment(m, g);
													if (this.couldBacktrack && !this.fragPrevious && y && "initSegment" !== y.sn) {
														var b = y.sn - g.startSN;
														b > 1 && (y = g.fragments[b - 1], this.fragmentTracker.removeFragment(y))
													}
													if (y && this.fragmentTracker.getState(y) === l.FragmentState.OK && this.nextLoadPosition > m) {
														var E = this.audioOnly && !this.altAudio ? c.ElementaryStreamTypes.AUDIO : c.ElementaryStreamTypes.VIDEO;
														this.afterBufferFlushed(o, E, u.PlaylistLevelType.MAIN), y = this.getNextFragment(this.nextLoadPosition, g)
													}
													y && (!y.initSegment || y.initSegment.data || this.bitrateTest || (y = y.initSegment), "identity" !== (null === (e = y.decryptdata) || void 0 === e ? void 0 : e.keyFormat) || null !== (t = y.decryptdata) && void 0 !== t && t.key ? this.loadFragment(y, g, m) : this.loadKey(y, g))
												}
											}
										}
									}, T.loadFragment = function(t, r, n) {
										var i, s = this.fragmentTracker.getState(t);
										if (this.fragCurrent = t, s === l.FragmentState.BACKTRACKED) {
											var a = this.fragmentTracker.getBacktrackData(t);
											if (a) return this._handleFragmentLoadProgress(a), void this._handleFragmentLoadComplete(a);
											s = l.FragmentState.NOT_LOADED
										}
										s === l.FragmentState.NOT_LOADED || s === l.FragmentState.PARTIAL ? "initSegment" === t.sn ? this._loadInitSegment(t) : this.bitrateTest ? (t.bitrateTest = !0, this.log("Fragment " + t.sn + " of level " + t.level + " is being downloaded to test bitrate and will not be buffered"), this._loadBitrateTestFrag(t)) : (this.startFragRequested = !0, e.prototype.loadFragment.call(this, t, r, n)) : s === l.FragmentState.APPENDING ? this.reduceMaxBufferLength(t.duration) && this.fragmentTracker.removeFragment(t) : 0 === (null === (i = this.media) || void 0 === i ? void 0 : i.buffered.length) && this.fragmentTracker.removeAllFragments()
									}, T.getAppendedFrag = function(e) {
										var t = this.fragmentTracker.getAppendedFrag(e, u.PlaylistLevelType.MAIN);
										return t && "fragment" in t ? t.fragment : t
									}, T.getBufferedFrag = function(e) {
										return this.fragmentTracker.getBufferedFrag(e, u.PlaylistLevelType.MAIN)
									}, T.followingBufferedFrag = function(e) {
										return e ? this.getBufferedFrag(e.end + .5) : null
									}, T.immediateLevelSwitch = function() {
										this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
									}, T.nextLevelSwitch = function() {
										var e = this.levels,
											t = this.media;
										if (null != t && t.readyState) {
											var r, n = this.getAppendedFrag(t.currentTime);
											if (n && n.start > 1 && this.flushMainBuffer(0, n.start - 1), !t.paused && e) {
												var i = e[this.hls.nextLoadLevel],
													s = this.fragLastKbps;
												r = s && this.fragCurrent ? this.fragCurrent.duration * i.maxBitrate / (1e3 * s) + 1 : 0
											} else r = 0;
											var a = this.getBufferedFrag(t.currentTime + r);
											if (a) {
												var o = this.followingBufferedFrag(a);
												if (o) {
													this.abortCurrentFrag();
													var l = o.maxStartPTS ? o.maxStartPTS : o.start,
														u = o.duration,
														c = Math.max(a.end, l + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, .5 * u), .75 * u));
													this.flushMainBuffer(c, Number.POSITIVE_INFINITY)
												}
											}
										}
									}, T.abortCurrentFrag = function() {
										var e = this.fragCurrent;
										this.fragCurrent = null, null != e && e.loader && e.loader.abort(), this.state === i.State.KEY_LOADING && (this.state = i.State.IDLE), this.nextLoadPosition = this.getLoadPosition()
									}, T.flushMainBuffer = function(t, r) {
										e.prototype.flushMainBuffer.call(this, t, r, this.altAudio ? "video" : null)
									}, T.onMediaAttached = function(t, r) {
										e.prototype.onMediaAttached.call(this, t, r);
										var n = r.media;
										this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), n.addEventListener("playing", this.onvplaying), n.addEventListener("seeked", this.onvseeked), this.gapController = new h.default(this.config, n, this.fragmentTracker, this.hls)
									}, T.onMediaDetaching = function() {
										var t = this.media;
										t && (t.removeEventListener("playing", this.onvplaying), t.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), e.prototype.onMediaDetaching.call(this)
									}, T.onMediaPlaying = function() {
										this.tick()
									}, T.onMediaSeeked = function() {
										var e = this.media,
											t = e ? e.currentTime : null;
										Object(n.isFiniteNumber)(t) && this.log("Media seeked to " + t.toFixed(3)), this.tick()
									}, T.onManifestLoading = function() {
										this.log("Trigger BUFFER_RESET"), this.hls.trigger(a.Events.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = this.stalled = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null
									}, T.onManifestParsed = function(e, t) {
										var r, n = !1,
											i = !1;
										t.levels.forEach((function(e) {
											(r = e.audioCodec) && (-1 !== r.indexOf("mp4a.40.2") && (n = !0), -1 !== r.indexOf("mp4a.40.5") && (i = !0))
										})), this.audioCodecSwitch = n && i && !Object(s.changeTypeSupported)(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1
									}, T.onLevelLoading = function(e, t) {
										var r = this.levels;
										if (r && this.state === i.State.IDLE) {
											var n = r[t.level];
											(!n.details || n.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(n.details)) && (this.state = i.State.WAITING_LEVEL)
										}
									}, T.onLevelLoaded = function(e, t) {
										var r, n = this.levels,
											s = t.level,
											o = t.details,
											l = o.totalduration;
										if (n) {
											this.log("Level " + s + " loaded [" + o.startSN + "," + o.endSN + "], cc [" + o.startCC + ", " + o.endCC + "] duration:" + l);
											var u = this.fragCurrent;
											!u || this.state !== i.State.FRAG_LOADING && this.state !== i.State.FRAG_LOADING_WAITING_RETRY || u.level !== t.level && u.loader && (this.state = i.State.IDLE, u.loader.abort());
											var c = n[s],
												d = 0;
											if (o.live || null !== (r = c.details) && void 0 !== r && r.live) {
												if (o.fragments[0] || (o.deltaUpdateFailed = !0), o.deltaUpdateFailed) return;
												d = this.alignPlaylists(o, c.details)
											}
											if (c.details = o, this.levelLastLoaded = s, this.hls.trigger(a.Events.LEVEL_UPDATED, {
												details: o,
												level: s
											}), this.state === i.State.WAITING_LEVEL) {
												if (this.waitForCdnTuneIn(o)) return;
												this.state = i.State.IDLE
											}
											this.startFragRequested ? o.live && this.synchronizeToLiveEdge(o) : this.setStartPosition(o, d), this.tick()
										} else this.warn("Levels were reset while loading level " + s)
									}, T._handleFragmentLoadProgress = function(e) {
										var t, r = e.frag,
											n = e.part,
											i = e.payload,
											s = this.levels;
										if (s) {
											var a = s[r.level],
												o = a.details;
											if (o) {
												var l = a.videoCodec,
													c = o.PTSKnown || !o.live,
													h = null === (t = r.initSegment) || void 0 === t ? void 0 : t.data,
													g = this._getAudioCodec(a),
													v = this.transmuxer = this.transmuxer || new d.default(this.hls, u.PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
													p = n ? n.index : -1,
													m = -1 !== p,
													y = new f.ChunkMetadata(r.level, r.sn, r.stats.chunkCount, i.byteLength, p, m),
													b = this.initPTS[r.cc];
												v.push(i, h, g, l, r, n, o.totalduration, c, y, b)
											} else this.warn("Dropping fragment " + r.sn + " of level " + r.level + " after level details were reset")
										} else this.warn("Levels were reset while fragment load was in progress. Fragment " + r.sn + " of level " + r.level + " will not be buffered")
									}, T.onAudioTrackSwitching = function(e, t) {
										var r = this.altAudio,
											n = !!t.url,
											i = t.id;
										if (!n) {
											if (this.mediaBuffer !== this.media) {
												this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
												var s = this.fragCurrent;
												null != s && s.loader && (this.log("Switching to main audio track, cancel main fragment load"), s.loader.abort()), this.resetTransmuxer(), this.resetLoadingState()
											} else this.audioOnly && this.resetTransmuxer();
											var o = this.hls;
											r && o.trigger(a.Events.BUFFER_FLUSHING, {
												startOffset: 0,
												endOffset: Number.POSITIVE_INFINITY,
												type: "audio"
											}), o.trigger(a.Events.AUDIO_TRACK_SWITCHED, {
												id: i
											})
										}
									}, T.onAudioTrackSwitched = function(e, t) {
										var r = t.id,
											n = !!this.hls.audioTracks[r].url;
										if (n) {
											var i = this.videoBuffer;
											i && this.mediaBuffer !== i && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = i)
										}
										this.altAudio = n, this.tick()
									}, T.onBufferCreated = function(e, t) {
										var r, n, i = t.tracks,
											s = !1;
										for (var a in i) {
											var o = i[a];
											if ("main" === o.id) {
												if (n = a, r = o, "video" === a) {
													var l = i[a];
													l && (this.videoBuffer = l.buffer)
												}
											} else s = !0
										}
										s && r ? (this.log("Alternate track found, use " + n + ".buffered to schedule main fragment loading"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
									}, T.onFragBuffered = function(e, t) {
										var r = t.frag,
											n = t.part;
										if (!r || r.type === u.PlaylistLevelType.MAIN) {
											if (this.fragContextChanged(r)) return this.warn("Fragment " + r.sn + (n ? " p: " + n.index : "") + " of level " + r.level + " finished buffering, but was aborted. state: " + this.state), void(this.state === i.State.PARSED && (this.state = i.State.IDLE));
											var s = n ? n.stats : r.stats;
											this.fragLastKbps = Math.round(8 * s.total / (s.buffering.end - s.loading.first)), "initSegment" !== r.sn && (this.fragPrevious = r), this.fragBufferedComplete(r, n)
										}
									}, T.onError = function(e, t) {
										switch (t.details) {
											case g.ErrorDetails.FRAG_LOAD_ERROR:
											case g.ErrorDetails.FRAG_LOAD_TIMEOUT:
											case g.ErrorDetails.KEY_LOAD_ERROR:
											case g.ErrorDetails.KEY_LOAD_TIMEOUT:
												this.onFragmentOrKeyLoadError(u.PlaylistLevelType.MAIN, t);
												break;
											case g.ErrorDetails.LEVEL_LOAD_ERROR:
											case g.ErrorDetails.LEVEL_LOAD_TIMEOUT:
												this.state !== i.State.ERROR && (t.fatal ? (this.warn("" + t.details), this.state = i.State.ERROR) : t.levelRetry || this.state !== i.State.WAITING_LEVEL || (this.state = i.State.IDLE));
												break;
											case g.ErrorDetails.BUFFER_FULL_ERROR:
												if ("main" === t.parent && (this.state === i.State.PARSING || this.state === i.State.PARSED)) {
													var r = !0,
														n = this.getFwdBufferInfo(this.media, u.PlaylistLevelType.MAIN);
													n && n.len > .5 && (r = !this.reduceMaxBufferLength(n.len)), r && (this.warn("buffer full error also media.currentTime is not buffered, flush main"), this.immediateLevelSwitch()), this.resetLoadingState()
												}
										}
									}, T.checkBuffer = function() {
										var e = this.media,
											t = this.gapController;
										if (e && t && e.readyState) {
											var r = o.BufferHelper.getBuffered(e);
											!this.loadedmetadata && r.length ? (this.loadedmetadata = !0, this.seekToStartPos()) : t.poll(this.lastCurrentTime), this.lastCurrentTime = e.currentTime
										}
									}, T.onFragLoadEmergencyAborted = function() {
										this.state = i.State.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
									}, T.onBufferFlushed = function(e, t) {
										var r = t.type;
										if (r !== c.ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
											var n = (r === c.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
											this.afterBufferFlushed(n, r, u.PlaylistLevelType.MAIN)
										}
									}, T.onLevelsUpdated = function(e, t) {
										this.levels = t.levels
									}, T.swapAudioCodec = function() {
										this.audioCodecSwap = !this.audioCodecSwap
									}, T.seekToStartPos = function() {
										var e = this.media,
											t = e.currentTime,
											r = this.startPosition;
										if (r >= 0 && t < r) {
											if (e.seeking) return void v.logger.log("could not seek to " + r + ", already seeking at " + t);
											var n = o.BufferHelper.getBuffered(e),
												i = (n.length ? n.start(0) : 0) - r;
											i > 0 && (i < this.config.maxBufferHole || i < this.config.maxFragLookUpTolerance) && (v.logger.log("adjusting start position by " + i + " to match buffer start"), r += i, this.startPosition = r), this.log("seek to target start position " + r + " from current time " + t), e.currentTime = r
										}
									}, T._getAudioCodec = function(e) {
										var t = this.config.defaultAudioCodec || e.audioCodec;
										return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t
									}, T._loadBitrateTestFrag = function(e) {
										var t = this;
										this._doFragLoad(e)
											.then((function(r) {
												var n = t.hls;
												if (r && !n.nextLoadLevel && !t.fragContextChanged(e)) {
													t.fragLoadError = 0, t.state = i.State.IDLE, t.startFragRequested = !1, t.bitrateTest = !1;
													var s = e.stats;
													s.parsing.start = s.parsing.end = s.buffering.start = s.buffering.end = self.performance.now(), n.trigger(a.Events.FRAG_LOADED, r)
												}
											}))
									}, T._handleTransmuxComplete = function(e) {
										var t, r = "main",
											s = this.hls,
											o = e.remuxResult,
											l = e.chunkMeta,
											u = this.getCurrentContext(l);
										if (!u) return this.warn("The loading context changed while buffering fragment " + l.sn + " of level " + l.level + ". This chunk will not be buffered."), void this.resetLiveStartWhenNotLoaded(l.level);
										var d = u.frag,
											f = u.part,
											h = u.level,
											g = o.video,
											v = o.text,
											p = o.id3,
											m = o.initSegment,
											y = this.altAudio ? void 0 : o.audio;
										if (!this.fragContextChanged(d)) {
											if (this.state = i.State.PARSING, m) {
												m.tracks && (this._bufferInitSegment(h, m.tracks, d, l), s.trigger(a.Events.FRAG_PARSING_INIT_SEGMENT, {
													frag: d,
													id: r,
													tracks: m.tracks
												}));
												var b = m.initPTS,
													E = m.timescale;
												Object(n.isFiniteNumber)(b) && (this.initPTS[d.cc] = b, s.trigger(a.Events.INIT_PTS_FOUND, {
													frag: d,
													id: r,
													initPTS: b,
													timescale: E
												}))
											}
											if (g && !1 !== o.independent) {
												if (h.details) {
													var _ = g.startPTS,
														T = g.endPTS,
														S = g.startDTS,
														A = g.endDTS;
													if (f) f.elementaryStreams[g.type] = {
														startPTS: _,
														endPTS: T,
														startDTS: S,
														endDTS: A
													};
													else if (g.firstKeyFrame && g.independent && (this.couldBacktrack = !0), g.dropped && g.independent) {
														if (this.getLoadPosition() + this.config.maxBufferHole < _) return void this.backtrack(d);
														d.setElementaryStreamInfo(g.type, d.start, T, d.start, A, !0)
													}
													d.setElementaryStreamInfo(g.type, _, T, S, A), this.bufferFragmentData(g, d, f, l)
												}
											} else if (!1 === o.independent) return void this.backtrack(d);
											if (y) {
												var L = y.startPTS,
													w = y.endPTS,
													k = y.startDTS,
													C = y.endDTS;
												f && (f.elementaryStreams[c.ElementaryStreamTypes.AUDIO] = {
													startPTS: L,
													endPTS: w,
													startDTS: k,
													endDTS: C
												}), d.setElementaryStreamInfo(c.ElementaryStreamTypes.AUDIO, L, w, k, C), this.bufferFragmentData(y, d, f, l)
											}
											if (null != p && null !== (t = p.samples) && void 0 !== t && t.length) {
												var P = {
													frag: d,
													id: r,
													samples: p.samples
												};
												s.trigger(a.Events.FRAG_PARSING_METADATA, P)
											}
											if (v) {
												var D = {
													frag: d,
													id: r,
													samples: v.samples
												};
												s.trigger(a.Events.FRAG_PARSING_USERDATA, D)
											}
										}
									}, T._bufferInitSegment = function(e, t, r, n) {
										var s = this;
										if (this.state === i.State.PARSING) {
											this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio;
											var o = t.audio,
												l = t.video,
												u = t.audiovideo;
											if (o) {
												var c = e.audioCodec,
													d = navigator.userAgent.toLowerCase();
												this.audioCodecSwitch && (c && (c = -1 !== c.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== o.metadata.channelCount && -1 === d.indexOf("firefox") && (c = "mp4a.40.5")), -1 !== d.indexOf("android") && "audio/mpeg" !== o.container && (c = "mp4a.40.2", this.log("Android: force audio codec to " + c)), e.audioCodec && e.audioCodec !== c && this.log('Swapping manifest audio codec "' + e.audioCodec + '" for "' + c + '"'), o.levelCodec = c, o.id = "main", this.log("Init audio buffer, container:" + o.container + ", codecs[selected/level/parsed]=[" + (c || "") + "/" + (e.audioCodec || "") + "/" + o.codec + "]")
											}
											l && (l.levelCodec = e.videoCodec, l.id = "main", this.log("Init video buffer, container:" + l.container + ", codecs[level/parsed]=[" + (e.videoCodec || "") + "/" + l.codec + "]")), u && this.log("Init audiovideo buffer, container:" + u.container + ", codecs[level/parsed]=[" + (e.attrs.CODECS || "") + "/" + u.codec + "]"), this.hls.trigger(a.Events.BUFFER_CODECS, t), Object.keys(t)
												.forEach((function(e) {
													var i = t[e].initSegment;
													null != i && i.byteLength && s.hls.trigger(a.Events.BUFFER_APPENDING, {
														type: e,
														data: i,
														frag: r,
														part: null,
														chunkMeta: n,
														parent: r.type
													})
												})), this.tick()
										}
									}, T.backtrack = function(e) {
										this.couldBacktrack = !0, this.resetTransmuxer(), this.flushBufferGap(e);
										var t = this.fragmentTracker.backtrack(e);
										this.fragPrevious = null, this.nextLoadPosition = e.start, t ? this.resetFragmentLoading(e) : this.state = i.State.BACKTRACKING
									}, T.checkFragmentChanged = function() {
										var e = this.media,
											t = null;
										if (e && e.readyState > 1 && !1 === e.seeking) {
											var r = e.currentTime;
											if (o.BufferHelper.isBuffered(e, r) ? t = this.getAppendedFrag(r) : o.BufferHelper.isBuffered(e, r + .1) && (t = this.getAppendedFrag(r + .1)), t) {
												var n = this.fragPlaying,
													i = t.level;
												n && t.sn === n.sn && n.level === i && t.urlId === n.urlId || (this.hls.trigger(a.Events.FRAG_CHANGED, {
													frag: t
												}), n && n.level === i || this.hls.trigger(a.Events.LEVEL_SWITCHED, {
													level: i
												}), this.fragPlaying = t)
											}
										}
									}, b = y, (E = [{
										key: "nextLevel",
										get: function() {
											var e = this.nextBufferedFrag;
											return e ? e.level : -1
										}
									}, {
										key: "currentLevel",
										get: function() {
											var e = this.media;
											if (e) {
												var t = this.getAppendedFrag(e.currentTime);
												if (t) return t.level
											}
											return -1
										}
									}, {
										key: "nextBufferedFrag",
										get: function() {
											var e = this.media;
											if (e) {
												var t = this.getAppendedFrag(e.currentTime);
												return this.followingBufferedFrag(t)
											}
											return null
										}
									}, {
										key: "forceStartLoad",
										get: function() {
											return this._forceStartLoad
										}
									}]) && p(b.prototype, E), _ && p(b, _), y
								}(i.default)
							},
							"./src/controller/subtitle-stream-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "SubtitleStreamController", (function() {
									return g
								}));
								var n = r("./src/events.ts"),
									i = r("./src/utils/buffer-helper.ts"),
									s = r("./src/controller/fragment-finders.ts"),
									a = r("./src/utils/discontinuities.ts"),
									o = r("./src/controller/level-helper.ts"),
									l = r("./src/controller/fragment-tracker.ts"),
									u = r("./src/controller/base-stream-controller.ts"),
									c = r("./src/types/loader.ts"),
									d = r("./src/types/level.ts");

								function f(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function h(e, t) {
									return h = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, h(e, t)
								}
								var g = function(e) {
									var t, r;

									function g(t, r) {
										var n;
										return (n = e.call(this, t, r, "[subtitle-stream-controller]") || this)
											.levels = [], n.currentTrackId = -1, n.tracksBuffered = [], n.mainDetails = null, n._registerListeners(), n
									}
									r = e, (t = g)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, h(t, r);
									var v, p, m, y = g.prototype;
									return y.onHandlerDestroying = function() {
										this._unregisterListeners(), this.mainDetails = null
									}, y._registerListeners = function() {
										var e = this.hls;
										e.on(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(n.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(n.Events.ERROR, this.onError, this), e.on(n.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(n.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(n.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(n.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(n.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
									}, y._unregisterListeners = function() {
										var e = this.hls;
										e.off(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(n.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(n.Events.ERROR, this.onError, this), e.off(n.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(n.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(n.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(n.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(n.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
									}, y.startLoad = function() {
										this.stopLoad(), this.state = u.State.IDLE, this.setInterval(500), this.tick()
									}, y.onManifestLoading = function() {
										this.mainDetails = null, this.fragmentTracker.removeAllFragments()
									}, y.onLevelLoaded = function(e, t) {
										this.mainDetails = t.details
									}, y.onSubtitleFragProcessed = function(e, t) {
										var r = t.frag,
											n = t.success;
										if (this.fragPrevious = r, this.state = u.State.IDLE, n) {
											var i = this.tracksBuffered[this.currentTrackId];
											if (i) {
												for (var s, a = r.start, o = 0; o < i.length; o++)
													if (a >= i[o].start && a <= i[o].end) {
														s = i[o];
														break
													} var l = r.start + r.duration;
												s ? s.end = l : (s = {
													start: a,
													end: l
												}, i.push(s)), this.fragmentTracker.fragBuffered(r)
											}
										}
									}, y.onBufferFlushing = function(e, t) {
										var r = t.startOffset,
											n = t.endOffset;
										if (0 === r && n !== Number.POSITIVE_INFINITY) {
											var i = this.currentTrackId,
												s = this.levels;
											if (!s.length || !s[i] || !s[i].details) return;
											var a = n - s[i].details.targetduration;
											if (a <= 0) return;
											t.endOffsetSubtitles = Math.max(0, a), this.tracksBuffered.forEach((function(e) {
												for (var t = 0; t < e.length;)
													if (e[t].end <= a) e.shift();
													else {
														if (!(e[t].start < a)) break;
														e[t].start = a, t++
													}
											})), this.fragmentTracker.removeFragmentsInRange(r, a, c.PlaylistLevelType.SUBTITLE)
										}
									}, y.onError = function(e, t) {
										var r, n = t.frag;
										n && n.type === c.PlaylistLevelType.SUBTITLE && (null !== (r = this.fragCurrent) && void 0 !== r && r.loader && this.fragCurrent.loader.abort(), this.state = u.State.IDLE)
									}, y.onSubtitleTracksUpdated = function(e, t) {
										var r = this,
											n = t.subtitleTracks;
										this.tracksBuffered = [], this.levels = n.map((function(e) {
											return new d.Level(e)
										})), this.fragmentTracker.removeAllFragments(), this.fragPrevious = null, this.levels.forEach((function(e) {
											r.tracksBuffered[e.id] = []
										})), this.mediaBuffer = null
									}, y.onSubtitleTrackSwitch = function(e, t) {
										if (this.currentTrackId = t.id, this.levels.length && -1 !== this.currentTrackId) {
											var r = this.levels[this.currentTrackId];
											null != r && r.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, r && this.setInterval(500)
										} else this.clearInterval()
									}, y.onSubtitleTrackLoaded = function(e, t) {
										var r, n = t.details,
											i = t.id,
											l = this.currentTrackId,
											c = this.levels;
										if (c.length) {
											var d = c[l];
											if (!(i >= c.length || i !== l) && d) {
												if (this.mediaBuffer = this.mediaBufferTimeRanges, n.live || null !== (r = d.details) && void 0 !== r && r.live) {
													var f = this.mainDetails;
													if (n.deltaUpdateFailed || !f) return;
													var h = f.fragments[0];
													d.details ? 0 === this.alignPlaylists(n, d.details) && h && Object(o.addSliding)(n, h.start) : n.hasProgramDateTime && f.hasProgramDateTime ? Object(a.alignMediaPlaylistByPDT)(n, f) : h && Object(o.addSliding)(n, h.start)
												}
												d.details = n, this.levelLastLoaded = i, this.tick(), n.live && !this.fragCurrent && this.media && this.state === u.State.IDLE && (Object(s.findFragmentByPTS)(null, n.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), d.details = void 0))
											}
										}
									}, y._handleFragmentLoadComplete = function(e) {
										var t = e.frag,
											r = e.payload,
											i = t.decryptdata,
											s = this.hls;
										if (!this.fragContextChanged(t) && r && r.byteLength > 0 && i && i.key && i.iv && "AES-128" === i.method) {
											var a = performance.now();
											this.decrypter.webCryptoDecrypt(new Uint8Array(r), i.key.buffer, i.iv.buffer)
												.then((function(e) {
													var r = performance.now();
													s.trigger(n.Events.FRAG_DECRYPTED, {
														frag: t,
														payload: e,
														stats: {
															tstart: a,
															tdecrypt: r
														}
													})
												}))
										}
									}, y.doTick = function() {
										if (this.media) {
											if (this.state === u.State.IDLE) {
												var e, t = this.currentTrackId,
													r = this.levels;
												if (!r.length || !r[t] || !r[t].details) return;
												var n = r[t].details,
													a = n.targetduration,
													o = this.config,
													c = this.media,
													d = i.BufferHelper.bufferedInfo(this.mediaBufferTimeRanges, c.currentTime - a, o.maxBufferHole),
													f = d.end;
												if (d.len > this.getMaxBufferLength() + a) return;
												console.assert(n, "Subtitle track details are defined on idle subtitle stream controller tick");
												var h, g = n.fragments,
													v = g.length,
													p = n.edge,
													m = this.fragPrevious;
												if (f < p) {
													var y = o.maxFragLookUpTolerance;
													!(h = Object(s.findFragmentByPTS)(m, g, f, y)) && m && m.start < g[0].start && (h = g[0])
												} else h = g[v - 1];
												null !== (e = h) && void 0 !== e && e.encrypted ? this.loadKey(h, n) : h && this.fragmentTracker.getState(h) === l.FragmentState.NOT_LOADED && this.loadFragment(h, n, f)
											}
										} else this.state = u.State.IDLE
									}, y.loadFragment = function(t, r, n) {
										this.fragCurrent = t, e.prototype.loadFragment.call(this, t, r, n)
									}, v = g, (p = [{
										key: "mediaBufferTimeRanges",
										get: function() {
											return this.tracksBuffered[this.currentTrackId] || []
										}
									}]) && f(v.prototype, p), m && f(v, m), g
								}(u.default)
							},
							"./src/controller/subtitle-track-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/events.ts"),
									i = r("./src/utils/texttrack-utils.ts"),
									s = r("./src/controller/base-playlist-controller.ts"),
									a = r("./src/types/loader.ts");

								function o(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function l(e, t) {
									return l = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, l(e, t)
								}
								var u = function(e) {
									var t, r;

									function s(t) {
										var r;
										return (r = e.call(this, t, "[subtitle-track-controller]") || this)
											.media = null, r.tracks = [], r.groupId = null, r.tracksInGroup = [], r.trackId = -1, r.selectDefaultTrack = !0, r.queuedDefaultTrack = -1, r.trackChangeListener = function() {
												return r.onTextTracksChanged()
											}, r.asyncPollTrackChange = function() {
												return r.pollTrackChange(0)
											}, r.useTextTrackPolling = !1, r.subtitlePollingInterval = -1, r.subtitleDisplay = !0, r.registerListeners(), r
									}
									r = e, (t = s)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, l(t, r);
									var u, d, f, h = s.prototype;
									return h.destroy = function() {
										this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, e.prototype.destroy.call(this)
									}, h.registerListeners = function() {
										var e = this.hls;
										e.on(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(n.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(n.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(n.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(n.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(n.Events.ERROR, this.onError, this)
									}, h.unregisterListeners = function() {
										var e = this.hls;
										e.off(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(n.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(n.Events.LEVEL_LOADING, this.onLevelLoading, this), e.off(n.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(n.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(n.Events.ERROR, this.onError, this)
									}, h.onMediaAttached = function(e, t) {
										this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
									}, h.pollTrackChange = function(e) {
										self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e)
									}, h.onMediaDetaching = function() {
										this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), c(this.media.textTracks)
											.forEach((function(e) {
												Object(i.clearCurrentCues)(e)
											})), this.subtitleTrack = -1, this.media = null)
									}, h.onManifestLoading = function() {
										this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0
									}, h.onManifestParsed = function(e, t) {
										this.tracks = t.subtitleTracks
									}, h.onSubtitleTrackLoaded = function(e, t) {
										var r = t.id,
											n = t.details,
											i = this.trackId,
											s = this.tracksInGroup[i];
										if (s) {
											var a = s.details;
											s.details = t.details, this.log("subtitle track " + r + " loaded [" + n.startSN + "-" + n.endSN + "]"), r === this.trackId && (this.retryCount = 0, this.playlistLoaded(r, t, a))
										} else this.warn("Invalid subtitle track id " + r)
									}, h.onLevelLoading = function(e, t) {
										this.switchLevel(t.level)
									}, h.onLevelSwitching = function(e, t) {
										this.switchLevel(t.level)
									}, h.switchLevel = function(e) {
										var t = this.hls.levels[e];
										if (null != t && t.textGroupIds) {
											var r = t.textGroupIds[t.urlId];
											if (this.groupId !== r) {
												var i = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0,
													s = this.tracks.filter((function(e) {
														return !r || e.groupId === r
													}));
												this.tracksInGroup = s;
												var a = this.findTrackId(null == i ? void 0 : i.name) || this.findTrackId();
												this.groupId = r;
												var o = {
													subtitleTracks: s
												};
												this.log("Updating subtitle tracks, " + s.length + ' track(s) found in "' + r + '" group-id'), this.hls.trigger(n.Events.SUBTITLE_TRACKS_UPDATED, o), -1 !== a && this.setSubtitleTrack(a, i)
											}
										}
									}, h.findTrackId = function(e) {
										for (var t = this.tracksInGroup, r = 0; r < t.length; r++) {
											var n = t[r];
											if ((!this.selectDefaultTrack || n.default) && (!e || e === n.name)) return n.id
										}
										return -1
									}, h.onError = function(t, r) {
										e.prototype.onError.call(this, t, r), !r.fatal && r.context && r.context.type === a.PlaylistContextType.SUBTITLE_TRACK && r.context.id === this.trackId && r.context.groupId === this.groupId && this.retryLoadingOrFail(r)
									}, h.loadPlaylist = function(e) {
										var t = this.tracksInGroup[this.trackId];
										if (this.shouldLoadTrack(t)) {
											var r = t.id,
												i = t.groupId,
												s = t.url;
											if (e) try {
												s = e.addDirectives(s)
											} catch (e) {
												this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
											}
											this.log("Loading subtitle playlist for id " + r), this.hls.trigger(n.Events.SUBTITLE_TRACK_LOADING, {
												url: s,
												id: r,
												groupId: i,
												deliveryDirectives: e || null
											})
										}
									}, h.toggleTrackModes = function(e) {
										var t = this,
											r = this.media,
											n = this.subtitleDisplay,
											i = this.trackId;
										if (r) {
											var s = c(r.textTracks),
												a = s.filter((function(e) {
													return e.groupId === t.groupId
												}));
											if (-1 === e)[].slice.call(s)
												.forEach((function(e) {
													e.mode = "disabled"
												}));
											else {
												var o = a[i];
												o && (o.mode = "disabled")
											}
											var l = a[e];
											l && (l.mode = n ? "showing" : "hidden")
										}
									}, h.setSubtitleTrack = function(e, t) {
										var r, i = this.tracksInGroup;
										if (this.media) {
											if (this.trackId !== e && this.toggleTrackModes(e), !(this.trackId === e && (-1 === e || null !== (r = i[e]) && void 0 !== r && r.details) || e < -1 || e >= i.length)) {
												this.clearTimer();
												var s = i[e];
												if (this.log("Switching to subtitle track " + e), this.trackId = e, s) {
													var a = s.id,
														o = s.groupId,
														l = void 0 === o ? "" : o,
														u = s.name,
														c = s.type,
														d = s.url;
													this.hls.trigger(n.Events.SUBTITLE_TRACK_SWITCH, {
														id: a,
														groupId: l,
														name: u,
														type: c,
														url: d
													});
													var f = this.switchParams(s.url, null == t ? void 0 : t.details);
													this.loadPlaylist(f)
												} else this.hls.trigger(n.Events.SUBTITLE_TRACK_SWITCH, {
													id: e
												})
											}
										} else this.queuedDefaultTrack = e
									}, h.onTextTracksChanged = function() {
										if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), this.media && this.hls.config.renderTextTracksNatively) {
											for (var e = -1, t = c(this.media.textTracks), r = 0; r < t.length; r++)
												if ("hidden" === t[r].mode) e = r;
												else if ("showing" === t[r].mode) {
												e = r;
												break
											}
											this.subtitleTrack !== e && (this.subtitleTrack = e)
										}
									}, u = s, (d = [{
										key: "subtitleTracks",
										get: function() {
											return this.tracksInGroup
										}
									}, {
										key: "subtitleTrack",
										get: function() {
											return this.trackId
										},
										set: function(e) {
											this.selectDefaultTrack = !1;
											var t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
											this.setSubtitleTrack(e, t)
										}
									}]) && o(u.prototype, d), f && o(u, f), s
								}(s.default);

								function c(e) {
									for (var t = [], r = 0; r < e.length; r++) {
										var n = e[r];
										"subtitles" === n.kind && n.label && t.push(e[r])
									}
									return t
								}
								t.default = u
							},
							"./src/controller/timeline-controller.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "TimelineController", (function() {
									return f
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/events.ts"),
									s = r("./src/utils/cea-608-parser.ts"),
									a = r("./src/utils/output-filter.ts"),
									o = r("./src/utils/webvtt-parser.ts"),
									l = r("./src/utils/texttrack-utils.ts"),
									u = r("./src/utils/imsc1-ttml-parser.ts"),
									c = r("./src/types/loader.ts"),
									d = r("./src/utils/logger.ts"),
									f = function() {
										function e(e) {
											if (this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.timescale = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
												ccOffset: 0,
												presentationOffset: 0,
												0: {
													start: 0,
													prevCC: -1,
													new: !1
												}
											}, this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
												textTrack1: {
													label: this.config.captionsTextTrack1Label,
													languageCode: this.config.captionsTextTrack1LanguageCode
												},
												textTrack2: {
													label: this.config.captionsTextTrack2Label,
													languageCode: this.config.captionsTextTrack2LanguageCode
												},
												textTrack3: {
													label: this.config.captionsTextTrack3Label,
													languageCode: this.config.captionsTextTrack3LanguageCode
												},
												textTrack4: {
													label: this.config.captionsTextTrack4Label,
													languageCode: this.config.captionsTextTrack4LanguageCode
												}
											}, this.config.enableCEA708Captions) {
												var t = new a.default(this, "textTrack1"),
													r = new a.default(this, "textTrack2"),
													n = new a.default(this, "textTrack3"),
													o = new a.default(this, "textTrack4");
												this.cea608Parser1 = new s.default(1, t, r), this.cea608Parser2 = new s.default(3, n, o)
											}
											e.on(i.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(i.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(i.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(i.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(i.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(i.Events.FRAG_LOADING, this.onFragLoading, this), e.on(i.Events.FRAG_LOADED, this.onFragLoaded, this), e.on(i.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(i.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(i.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(i.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(i.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
										}
										var t = e.prototype;
										return t.destroy = function() {
											var e = this.hls;
											e.off(i.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(i.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(i.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(i.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(i.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(i.Events.FRAG_LOADING, this.onFragLoading, this), e.off(i.Events.FRAG_LOADED, this.onFragLoaded, this), e.off(i.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(i.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(i.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(i.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(i.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
										}, t.addCues = function(e, t, r, n, s) {
											for (var a, o, l, u, c = !1, d = s.length; d--;) {
												var f = s[d],
													h = (a = f[0], o = f[1], l = t, u = r, Math.min(o, u) - Math.max(a, l));
												if (h >= 0 && (f[0] = Math.min(f[0], t), f[1] = Math.max(f[1], r), c = !0, h / (r - t) > .5)) return
											}
											if (c || s.push([t, r]), this.config.renderTextTracksNatively) {
												var g = this.captionsTracks[e];
												this.Cues.newCue(g, t, r, n)
											} else {
												var v = this.Cues.newCue(null, t, r, n);
												this.hls.trigger(i.Events.CUES_PARSED, {
													type: "captions",
													cues: v,
													track: e
												})
											}
										}, t.onInitPtsFound = function(e, t) {
											var r = this,
												n = t.frag,
												s = t.id,
												a = t.initPTS,
												o = t.timescale,
												l = this.unparsedVttFrags;
											"main" === s && (this.initPTS[n.cc] = a, this.timescale[n.cc] = o), l.length && (this.unparsedVttFrags = [], l.forEach((function(e) {
												r.onFragLoaded(i.Events.FRAG_LOADED, e)
											})))
										}, t.getExistingTrack = function(e) {
											var t = this.media;
											if (t)
												for (var r = 0; r < t.textTracks.length; r++) {
													var n = t.textTracks[r];
													if (n[e]) return n
												}
											return null
										}, t.createCaptionsTrack = function(e) {
											this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
										}, t.createNativeTrack = function(e) {
											if (!this.captionsTracks[e]) {
												var t = this.captionsProperties,
													r = this.captionsTracks,
													n = this.media,
													i = t[e],
													s = i.label,
													a = i.languageCode,
													o = this.getExistingTrack(e);
												if (o) r[e] = o, Object(l.clearCurrentCues)(r[e]), Object(l.sendAddTrackEvent)(r[e], n);
												else {
													var u = this.createTextTrack("captions", s, a);
													u && (u[e] = !0, r[e] = u)
												}
											}
										}, t.createNonNativeTrack = function(e) {
											if (!this.nonNativeCaptionsTracks[e]) {
												var t = this.captionsProperties[e];
												if (t) {
													var r = {
														_id: e,
														label: t.label,
														kind: "captions",
														default: !!t.media && !!t.media.default,
														closedCaptions: t.media
													};
													this.nonNativeCaptionsTracks[e] = r, this.hls.trigger(i.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
														tracks: [r]
													})
												}
											}
										}, t.createTextTrack = function(e, t, r) {
											var n = this.media;
											if (n) return n.addTextTrack(e, t, r)
										}, t.onMediaAttaching = function(e, t) {
											this.media = t.media, this._cleanTracks()
										}, t.onMediaDetaching = function() {
											var e = this.captionsTracks;
											Object.keys(e)
												.forEach((function(t) {
													Object(l.clearCurrentCues)(e[t]), delete e[t]
												})), this.nonNativeCaptionsTracks = {}
										}, t.onManifestLoading = function() {
											this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
												ccOffset: 0,
												presentationOffset: 0,
												0: {
													start: 0,
													prevCC: -1,
													new: !1
												}
											}, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.timescale = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
										}, t._cleanTracks = function() {
											var e = this.media;
											if (e) {
												var t = e.textTracks;
												if (t)
													for (var r = 0; r < t.length; r++) Object(l.clearCurrentCues)(t[r])
											}
										}, t.onSubtitleTracksUpdated = function(e, t) {
											var r = this;
											this.textTracks = [];
											var n = t.subtitleTracks || [],
												s = n.some((function(e) {
													return e.textCodec === u.IMSC1_CODEC
												}));
											if (this.config.enableWebVTT || s && this.config.enableIMSC1) {
												var a = this.tracks && n && this.tracks.length === n.length;
												if (this.tracks = n || [], this.config.renderTextTracksNatively) {
													var o = this.media ? this.media.textTracks : [];
													this.tracks.forEach((function(e, t) {
														var n;
														if (t < o.length) {
															for (var i = null, s = 0; s < o.length; s++)
																if (h(o[s], e)) {
																	i = o[s];
																	break
																} i && (n = i)
														}
														n ? Object(l.clearCurrentCues)(n) : (n = r.createTextTrack("subtitles", e.name, e.lang)) && (n.mode = "disabled"), n && (n.groupId = e.groupId, r.textTracks.push(n))
													}))
												} else if (!a && this.tracks && this.tracks.length) {
													var c = this.tracks.map((function(e) {
														return {
															label: e.name,
															kind: e.type.toLowerCase(),
															default: e.default,
															subtitleTrack: e
														}
													}));
													this.hls.trigger(i.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
														tracks: c
													})
												}
											}
										}, t.onManifestLoaded = function(e, t) {
											var r = this;
											this.config.enableCEA708Captions && t.captions && t.captions.forEach((function(e) {
												var t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId);
												if (t) {
													var n = "textTrack" + t[1],
														i = r.captionsProperties[n];
													i && (i.label = e.name, e.lang && (i.languageCode = e.lang), i.media = e)
												}
											}))
										}, t.onFragLoading = function(e, t) {
											var r = this.cea608Parser1,
												n = this.cea608Parser2,
												i = this.lastSn,
												s = this.lastPartIndex;
											if (this.enabled && r && n && t.frag.type === c.PlaylistLevelType.MAIN) {
												var a, o, l = t.frag.sn,
													u = null != (a = null == t || null === (o = t.part) || void 0 === o ? void 0 : o.index) ? a : -1;
												l === i + 1 || l === i && u === s + 1 || (r.reset(), n.reset()), this.lastSn = l, this.lastPartIndex = u
											}
										}, t.onFragLoaded = function(e, t) {
											var r = t.frag,
												s = t.payload,
												a = this.initPTS,
												o = this.unparsedVttFrags;
											if (r.type === c.PlaylistLevelType.SUBTITLE)
												if (s.byteLength) {
													if (!Object(n.isFiniteNumber)(a[r.cc])) return o.push(t), void(a.length && this.hls.trigger(i.Events.SUBTITLE_FRAG_PROCESSED, {
														success: !1,
														frag: r,
														error: new Error("Missing initial subtitle PTS")
													}));
													var l = r.decryptdata,
														d = "stats" in t;
													if (null == l || null == l.key || "AES-128" !== l.method || d) {
														var f = this.tracks[r.level],
															h = this.vttCCs;
														h[r.cc] || (h[r.cc] = {
															start: r.start,
															prevCC: this.prevCC,
															new: !0
														}, this.prevCC = r.cc), f && f.textCodec === u.IMSC1_CODEC ? this._parseIMSC1(r, s) : this._parseVTTs(r, s, h)
													}
												} else this.hls.trigger(i.Events.SUBTITLE_FRAG_PROCESSED, {
													success: !1,
													frag: r,
													error: new Error("Empty subtitle payload")
												})
										}, t._parseIMSC1 = function(e, t) {
											var r = this,
												n = this.hls;
											Object(u.parseIMSC1)(t, this.initPTS[e.cc], this.timescale[e.cc], (function(t) {
												r._appendCues(t, e.level), n.trigger(i.Events.SUBTITLE_FRAG_PROCESSED, {
													success: !0,
													frag: e
												})
											}), (function(t) {
												d.logger.log("Failed to parse IMSC1: " + t), n.trigger(i.Events.SUBTITLE_FRAG_PROCESSED, {
													success: !1,
													frag: e,
													error: t
												})
											}))
										}, t._parseVTTs = function(e, t, r) {
											var n = this,
												s = this.hls;
											Object(o.parseWebVTT)(t, this.initPTS[e.cc], this.timescale[e.cc], r, e.cc, e.start, (function(t) {
												n._appendCues(t, e.level), s.trigger(i.Events.SUBTITLE_FRAG_PROCESSED, {
													success: !0,
													frag: e
												})
											}), (function(r) {
												n._fallbackToIMSC1(e, t), d.logger.log("Failed to parse VTT cue: " + r), s.trigger(i.Events.SUBTITLE_FRAG_PROCESSED, {
													success: !1,
													frag: e,
													error: r
												})
											}))
										}, t._fallbackToIMSC1 = function(e, t) {
											var r = this,
												n = this.tracks[e.level];
											n.textCodec || Object(u.parseIMSC1)(t, this.initPTS[e.cc], this.timescale[e.cc], (function() {
												n.textCodec = u.IMSC1_CODEC, r._parseIMSC1(e, t)
											}), (function() {
												n.textCodec = "wvtt"
											}))
										}, t._appendCues = function(e, t) {
											var r = this.hls;
											if (this.config.renderTextTracksNatively) {
												var n = this.textTracks[t];
												if ("disabled" === n.mode) return;
												e.forEach((function(e) {
													return Object(l.addCueToTrack)(n, e)
												}))
											} else {
												var s = this.tracks[t].default ? "default" : "subtitles" + t;
												r.trigger(i.Events.CUES_PARSED, {
													type: "subtitles",
													cues: e,
													track: s
												})
											}
										}, t.onFragDecrypted = function(e, t) {
											var r = t.frag;
											if (r.type === c.PlaylistLevelType.SUBTITLE) {
												if (!Object(n.isFiniteNumber)(this.initPTS[r.cc])) return void this.unparsedVttFrags.push(t);
												this.onFragLoaded(i.Events.FRAG_LOADED, t)
											}
										}, t.onSubtitleTracksCleared = function() {
											this.tracks = [], this.captionsTracks = {}
										}, t.onFragParsingUserdata = function(e, t) {
											var r = this.cea608Parser1,
												n = this.cea608Parser2;
											if (this.enabled && r && n)
												for (var i = 0; i < t.samples.length; i++) {
													var s = t.samples[i].bytes;
													if (s) {
														var a = this.extractCea608Data(s);
														r.addData(t.samples[i].pts, a[0]), n.addData(t.samples[i].pts, a[1])
													}
												}
										}, t.onBufferFlushing = function(e, t) {
											var r = t.startOffset,
												n = t.endOffset,
												i = t.endOffsetSubtitles,
												s = t.type,
												a = this.media;
											if (a && !(a.currentTime < n)) {
												if (!s || "video" === s) {
													var o = this.captionsTracks;
													Object.keys(o)
														.forEach((function(e) {
															return Object(l.removeCuesInRange)(o[e], r, n)
														}))
												}
												if (this.config.renderTextTracksNatively && 0 === r && void 0 !== i) {
													var u = this.textTracks;
													Object.keys(u)
														.forEach((function(e) {
															return Object(l.removeCuesInRange)(u[e], r, i)
														}))
												}
											}
										}, t.extractCea608Data = function(e) {
											for (var t = 31 & e[0], r = 2, n = [
												[],
												[]
											], i = 0; i < t; i++) {
												var s = e[r++],
													a = 127 & e[r++],
													o = 127 & e[r++],
													l = 3 & s;
												0 === a && 0 === o || 0 != (4 & s) && (0 !== l && 1 !== l || (n[l].push(a), n[l].push(o)))
											}
											return n
										}, e
									}();

								function h(e, t) {
									return e && e.label === t.name && !(e.textTrack1 || e.textTrack2)
								}
							},
							"./src/crypt/aes-crypto.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return n
								}));
								var n = function() {
									function e(e, t) {
										this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t
									}
									return e.prototype.decrypt = function(e, t) {
										return this.subtle.decrypt({
											name: "AES-CBC",
											iv: this.aesIV
										}, t, e)
									}, e
								}()
							},
							"./src/crypt/aes-decryptor.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "removePadding", (function() {
									return i
								})), r.d(t, "default", (function() {
									return s
								}));
								var n = r("./src/utils/typed-array.ts");

								function i(e) {
									var t = e.byteLength,
										r = t && new DataView(e.buffer)
										.getUint8(t - 1);
									return r ? Object(n.sliceUint8)(e, 0, t - r) : e
								}
								var s = function() {
									function e() {
										this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
									}
									var t = e.prototype;
									return t.uint8ArrayToUint32Array_ = function(e) {
										for (var t = new DataView(e), r = new Uint32Array(4), n = 0; n < 4; n++) r[n] = t.getUint32(4 * n);
										return r
									}, t.initTable = function() {
										var e = this.sBox,
											t = this.invSBox,
											r = this.subMix,
											n = r[0],
											i = r[1],
											s = r[2],
											a = r[3],
											o = this.invSubMix,
											l = o[0],
											u = o[1],
											c = o[2],
											d = o[3],
											f = new Uint32Array(256),
											h = 0,
											g = 0,
											v = 0;
										for (v = 0; v < 256; v++) f[v] = v < 128 ? v << 1 : v << 1 ^ 283;
										for (v = 0; v < 256; v++) {
											var p = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
											p = p >>> 8 ^ 255 & p ^ 99, e[h] = p, t[p] = h;
											var m = f[h],
												y = f[m],
												b = f[y],
												E = 257 * f[p] ^ 16843008 * p;
											n[h] = E << 24 | E >>> 8, i[h] = E << 16 | E >>> 16, s[h] = E << 8 | E >>> 24, a[h] = E, E = 16843009 * b ^ 65537 * y ^ 257 * m ^ 16843008 * h, l[p] = E << 24 | E >>> 8, u[p] = E << 16 | E >>> 16, c[p] = E << 8 | E >>> 24, d[p] = E, h ? (h = m ^ f[f[f[b ^ m]]], g ^= f[f[g]]) : h = g = 1
										}
									}, t.expandKey = function(e) {
										for (var t = this.uint8ArrayToUint32Array_(e), r = !0, n = 0; n < t.length && r;) r = t[n] === this.key[n], n++;
										if (!r) {
											this.key = t;
											var i = this.keySize = t.length;
											if (4 !== i && 6 !== i && 8 !== i) throw new Error("Invalid aes key size=" + i);
											var s, a, o, l, u = this.ksRows = 4 * (i + 6 + 1),
												c = this.keySchedule = new Uint32Array(u),
												d = this.invKeySchedule = new Uint32Array(u),
												f = this.sBox,
												h = this.rcon,
												g = this.invSubMix,
												v = g[0],
												p = g[1],
												m = g[2],
												y = g[3];
											for (s = 0; s < u; s++) s < i ? o = c[s] = t[s] : (l = o, s % i == 0 ? (l = f[(l = l << 8 | l >>> 24) >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l], l ^= h[s / i | 0] << 24) : i > 6 && s % i == 4 && (l = f[l >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l]), c[s] = o = (c[s - i] ^ l) >>> 0);
											for (a = 0; a < u; a++) s = u - a, l = 3 & a ? c[s] : c[s - 4], d[a] = a < 4 || s <= 4 ? l : v[f[l >>> 24]] ^ p[f[l >>> 16 & 255]] ^ m[f[l >>> 8 & 255]] ^ y[f[255 & l]], d[a] = d[a] >>> 0
										}
									}, t.networkToHostOrderSwap = function(e) {
										return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
									}, t.decrypt = function(e, t, r) {
										for (var n, i, s, a, o, l, u, c, d, f, h, g, v, p, m = this.keySize + 6, y = this.invKeySchedule, b = this.invSBox, E = this.invSubMix, _ = E[0], T = E[1], S = E[2], A = E[3], L = this.uint8ArrayToUint32Array_(r), w = L[0], k = L[1], C = L[2], P = L[3], D = new Int32Array(e), R = new Int32Array(D.length), I = this.networkToHostOrderSwap; t < D.length;) {
											for (d = I(D[t]), f = I(D[t + 1]), h = I(D[t + 2]), g = I(D[t + 3]), o = d ^ y[0], l = g ^ y[1], u = h ^ y[2], c = f ^ y[3], v = 4, p = 1; p < m; p++) n = _[o >>> 24] ^ T[l >> 16 & 255] ^ S[u >> 8 & 255] ^ A[255 & c] ^ y[v], i = _[l >>> 24] ^ T[u >> 16 & 255] ^ S[c >> 8 & 255] ^ A[255 & o] ^ y[v + 1], s = _[u >>> 24] ^ T[c >> 16 & 255] ^ S[o >> 8 & 255] ^ A[255 & l] ^ y[v + 2], a = _[c >>> 24] ^ T[o >> 16 & 255] ^ S[l >> 8 & 255] ^ A[255 & u] ^ y[v + 3], o = n, l = i, u = s, c = a, v += 4;
											n = b[o >>> 24] << 24 ^ b[l >> 16 & 255] << 16 ^ b[u >> 8 & 255] << 8 ^ b[255 & c] ^ y[v], i = b[l >>> 24] << 24 ^ b[u >> 16 & 255] << 16 ^ b[c >> 8 & 255] << 8 ^ b[255 & o] ^ y[v + 1], s = b[u >>> 24] << 24 ^ b[c >> 16 & 255] << 16 ^ b[o >> 8 & 255] << 8 ^ b[255 & l] ^ y[v + 2], a = b[c >>> 24] << 24 ^ b[o >> 16 & 255] << 16 ^ b[l >> 8 & 255] << 8 ^ b[255 & u] ^ y[v + 3], R[t] = I(n ^ w), R[t + 1] = I(a ^ k), R[t + 2] = I(s ^ C), R[t + 3] = I(i ^ P), w = d, k = f, C = h, P = g, t += 4
										}
										return R.buffer
									}, e
								}()
							},
							"./src/crypt/decrypter.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return u
								}));
								var n = r("./src/crypt/aes-crypto.ts"),
									i = r("./src/crypt/fast-aes-key.ts"),
									s = r("./src/crypt/aes-decryptor.ts"),
									a = r("./src/utils/logger.ts"),
									o = r("./src/utils/mp4-tools.ts"),
									l = r("./src/utils/typed-array.ts"),
									u = function() {
										function e(e, t, r) {
											var n = (void 0 === r ? {} : r)
												.removePKCS7Padding,
												i = void 0 === n || n;
											if (this.logEnabled = !0, this.observer = void 0, this.config = void 0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.observer = e, this.config = t, this.removePKCS7Padding = i, i) try {
												var s = self.crypto;
												s && (this.subtle = s.subtle || s.webkitSubtle)
											} catch (e) {}
											null === this.subtle && (this.config.enableSoftwareAES = !0)
										}
										var t = e.prototype;
										return t.destroy = function() {
											this.observer = null
										}, t.isSync = function() {
											return this.config.enableSoftwareAES
										}, t.flush = function() {
											var e = this.currentResult;
											if (e) {
												var t = new Uint8Array(e);
												return this.reset(), this.removePKCS7Padding ? Object(s.removePadding)(t) : t
											}
											this.reset()
										}, t.reset = function() {
											this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
										}, t.decrypt = function(e, t, r, n) {
											if (this.config.enableSoftwareAES) {
												this.softwareDecrypt(new Uint8Array(e), t, r);
												var i = this.flush();
												i && n(i.buffer)
											} else this.webCryptoDecrypt(new Uint8Array(e), t, r)
												.then(n)
										}, t.softwareDecrypt = function(e, t, r) {
											var n = this.currentIV,
												i = this.currentResult,
												a = this.remainderData;
											this.logOnce("JS AES decrypt"), a && (e = Object(o.appendUint8Array)(a, e), this.remainderData = null);
											var u = this.getValidChunk(e);
											if (!u.length) return null;
											n && (r = n);
											var c = this.softwareDecrypter;
											c || (c = this.softwareDecrypter = new s.default), c.expandKey(t);
											var d = i;
											return this.currentResult = c.decrypt(u.buffer, 0, r), this.currentIV = Object(l.sliceUint8)(u, -16)
												.buffer, d || null
										}, t.webCryptoDecrypt = function(e, t, r) {
											var s = this,
												a = this.subtle;
											return this.key === t && this.fastAesKey || (this.key = t, this.fastAesKey = new i.default(a, t)), this.fastAesKey.expandKey()
												.then((function(t) {
													return a ? new n.default(a, r)
														.decrypt(e.buffer, t) : Promise.reject(new Error("web crypto not initialized"))
												}))
												.catch((function(n) {
													return s.onWebCryptoError(n, e, t, r)
												}))
										}, t.onWebCryptoError = function(e, t, r, n) {
											return a.logger.warn("[decrypter.ts]: WebCrypto Error, disable WebCrypto API:", e), this.config.enableSoftwareAES = !0, this.logEnabled = !0, this.softwareDecrypt(t, r, n)
										}, t.getValidChunk = function(e) {
											var t = e,
												r = e.length - e.length % 16;
											return r !== e.length && (t = Object(l.sliceUint8)(e, 0, r), this.remainderData = Object(l.sliceUint8)(e, r)), t
										}, t.logOnce = function(e) {
											this.logEnabled && (a.logger.log("[decrypter.ts]: " + e), this.logEnabled = !1)
										}, e
									}()
							},
							"./src/crypt/fast-aes-key.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return n
								}));
								var n = function() {
									function e(e, t) {
										this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t
									}
									return e.prototype.expandKey = function() {
										return this.subtle.importKey("raw", this.key, {
											name: "AES-CBC"
										}, !1, ["encrypt", "decrypt"])
									}, e
								}()
							},
							"./src/demux/aacdemuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/demux/base-audio-demuxer.ts"),
									i = r("./src/demux/adts.ts"),
									s = r("./src/utils/logger.ts"),
									a = r("./src/demux/id3.ts");

								function o(e, t) {
									return o = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, o(e, t)
								}
								var l = function(e) {
									var t, r;

									function n(t, r) {
										var n;
										return (n = e.call(this) || this)
											.observer = void 0, n.config = void 0, n.observer = t, n.config = r, n
									}
									r = e, (t = n)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, o(t, r);
									var l = n.prototype;
									return l.resetInitSegment = function(t, r, n) {
										e.prototype.resetInitSegment.call(this, t, r, n), this._audioTrack = {
											container: "audio/adts",
											type: "audio",
											id: 2,
											pid: -1,
											sequenceNumber: 0,
											isAAC: !0,
											samples: [],
											manifestCodec: t,
											duration: n,
											inputTimeScale: 9e4,
											dropped: 0
										}
									}, n.probe = function(e) {
										if (!e) return !1;
										for (var t = (a.getID3Data(e, 0) || [])
											.length, r = e.length; t < r; t++)
											if (i.probe(e, t)) return s.logger.log("ADTS sync word found !"), !0;
										return !1
									}, l.canParse = function(e, t) {
										return i.canParse(e, t)
									}, l.appendFrame = function(e, t, r) {
										i.initTrackConfig(e, this.observer, t, r, e.manifestCodec);
										var n = i.appendFrame(e, t, r, this.initPTS, this.frameIndex);
										if (n && 0 === n.missing) return n
									}, n
								}(n.default);
								l.minProbeByteLength = 9, t.default = l
							},
							"./src/demux/adts.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "getAudioConfig", (function() {
									return a
								})), r.d(t, "isHeaderPattern", (function() {
									return o
								})), r.d(t, "getHeaderLength", (function() {
									return l
								})), r.d(t, "getFullFrameLength", (function() {
									return u
								})), r.d(t, "canGetFrameLength", (function() {
									return c
								})), r.d(t, "isHeader", (function() {
									return d
								})), r.d(t, "canParse", (function() {
									return f
								})), r.d(t, "probe", (function() {
									return h
								})), r.d(t, "initTrackConfig", (function() {
									return g
								})), r.d(t, "getFrameDuration", (function() {
									return v
								})), r.d(t, "parseFrameHeader", (function() {
									return p
								})), r.d(t, "appendFrame", (function() {
									return m
								}));
								var n = r("./src/utils/logger.ts"),
									i = r("./src/errors.ts"),
									s = r("./src/events.ts");

								function a(e, t, r, a) {
									var o, l, u, c, d = navigator.userAgent.toLowerCase(),
										f = a,
										h = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
									o = 1 + ((192 & t[r + 2]) >>> 6);
									var g = (60 & t[r + 2]) >>> 2;
									if (!(g > h.length - 1)) return u = (1 & t[r + 2]) << 2, u |= (192 & t[r + 3]) >>> 6, n.logger.log("manifest codec:" + a + ", ADTS type:" + o + ", samplingIndex:" + g), /firefox/i.test(d) ? g >= 6 ? (o = 5, c = new Array(4), l = g - 3) : (o = 2, c = new Array(2), l = g) : -1 !== d.indexOf("android") ? (o = 2, c = new Array(2), l = g) : (o = 5, c = new Array(4), a && (-1 !== a.indexOf("mp4a.40.29") || -1 !== a.indexOf("mp4a.40.5")) || !a && g >= 6 ? l = g - 3 : ((a && -1 !== a.indexOf("mp4a.40.2") && (g >= 6 && 1 === u || /vivaldi/i.test(d)) || !a && 1 === u) && (o = 2, c = new Array(2)), l = g)), c[0] = o << 3, c[0] |= (14 & g) >> 1, c[1] |= (1 & g) << 7, c[1] |= u << 3, 5 === o && (c[1] |= (14 & l) >> 1, c[2] = (1 & l) << 7, c[2] |= 8, c[3] = 0), {
										config: c,
										samplerate: h[g],
										channelCount: u,
										codec: "mp4a.40." + o,
										manifestCodec: f
									};
									e.trigger(s.Events.ERROR, {
										type: i.ErrorTypes.MEDIA_ERROR,
										details: i.ErrorDetails.FRAG_PARSING_ERROR,
										fatal: !0,
										reason: "invalid ADTS sampling index:" + g
									})
								}

								function o(e, t) {
									return 255 === e[t] && 240 == (246 & e[t + 1])
								}

								function l(e, t) {
									return 1 & e[t + 1] ? 7 : 9
								}

								function u(e, t) {
									return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
								}

								function c(e, t) {
									return t + 5 < e.length
								}

								function d(e, t) {
									return t + 1 < e.length && o(e, t)
								}

								function f(e, t) {
									return c(e, t) && o(e, t) && u(e, t) <= e.length - t
								}

								function h(e, t) {
									if (d(e, t)) {
										var r = l(e, t);
										if (t + r >= e.length) return !1;
										var n = u(e, t);
										if (n <= r) return !1;
										var i = t + n;
										return i === e.length || d(e, i)
									}
									return !1
								}

								function g(e, t, r, i, s) {
									if (!e.samplerate) {
										var o = a(t, r, i, s);
										if (!o) return;
										e.config = o.config, e.samplerate = o.samplerate, e.channelCount = o.channelCount, e.codec = o.codec, e.manifestCodec = o.manifestCodec, n.logger.log("parsed codec:" + e.codec + ", rate:" + o.samplerate + ", channels:" + o.channelCount)
									}
								}

								function v(e) {
									return 9216e4 / e
								}

								function p(e, t, r, n, i) {
									var s = l(e, t),
										a = u(e, t);
									if ((a -= s) > 0) return {
										headerLength: s,
										frameLength: a,
										stamp: r + n * i
									}
								}

								function m(e, t, r, n, i) {
									var s = p(t, r, n, i, v(e.samplerate));
									if (s) {
										var a, o = s.frameLength,
											l = s.headerLength,
											u = s.stamp,
											c = l + o,
											d = Math.max(0, r + c - t.length);
										d ? (a = new Uint8Array(c - l))
											.set(t.subarray(r + l, t.length), 0) : a = t.subarray(r + l, r + c);
										var f = {
											unit: a,
											pts: u
										};
										return d || e.samples.push(f), {
											sample: f,
											length: c,
											missing: d
										}
									}
								}
							},
							"./src/demux/base-audio-demuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "initPTSFn", (function() {
									return u
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/demux/id3.ts"),
									s = r("./src/demux/dummy-demuxed-track.ts"),
									a = r("./src/utils/mp4-tools.ts"),
									o = r("./src/utils/typed-array.ts"),
									l = function() {
										function e() {
											this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.initPTS = null
										}
										var t = e.prototype;
										return t.resetInitSegment = function(e, t, r) {
											this._id3Track = {
												type: "id3",
												id: 3,
												pid: -1,
												inputTimeScale: 9e4,
												sequenceNumber: 0,
												samples: [],
												dropped: 0
											}
										}, t.resetTimeStamp = function() {}, t.resetContiguity = function() {}, t.canParse = function(e, t) {
											return !1
										}, t.appendFrame = function(e, t, r) {}, t.demux = function(e, t) {
											this.cachedData && (e = Object(a.appendUint8Array)(this.cachedData, e), this.cachedData = null);
											var r, n, l = i.getID3Data(e, 0),
												c = l ? l.length : 0,
												d = this._audioTrack,
												f = this._id3Track,
												h = l ? i.getTimeStamp(l) : void 0,
												g = e.length;
											for (0 !== this.frameIndex && null !== this.initPTS || (this.initPTS = u(h, t)), l && l.length > 0 && f.samples.push({
												pts: this.initPTS,
												dts: this.initPTS,
												data: l
											}), n = this.initPTS; c < g;) {
												if (this.canParse(e, c)) {
													var v = this.appendFrame(d, e, c);
													v ? (this.frameIndex++, n = v.sample.pts, r = c += v.length) : c = g
												} else i.canParse(e, c) ? (l = i.getID3Data(e, c), f.samples.push({
													pts: n,
													dts: n,
													data: l
												}), r = c += l.length) : c++;
												if (c === g && r !== g) {
													var p = Object(o.sliceUint8)(e, r);
													this.cachedData ? this.cachedData = Object(a.appendUint8Array)(this.cachedData, p) : this.cachedData = p
												}
											}
											return {
												audioTrack: d,
												avcTrack: Object(s.dummyTrack)(),
												id3Track: f,
												textTrack: Object(s.dummyTrack)()
											}
										}, t.demuxSampleAes = function(e, t, r) {
											return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"))
										}, t.flush = function(e) {
											var t = this.cachedData;
											return t && (this.cachedData = null, this.demux(t, 0)), this.frameIndex = 0, {
												audioTrack: this._audioTrack,
												avcTrack: Object(s.dummyTrack)(),
												id3Track: this._id3Track,
												textTrack: Object(s.dummyTrack)()
											}
										}, t.destroy = function() {}, e
									}(),
									u = function(e, t) {
										return Object(n.isFiniteNumber)(e) ? 90 * e : 9e4 * t
									};
								t.default = l
							},
							"./src/demux/chunk-cache.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return n
								}));
								var n = function() {
									function e() {
										this.chunks = [], this.dataLength = 0
									}
									var t = e.prototype;
									return t.push = function(e) {
										this.chunks.push(e), this.dataLength += e.length
									}, t.flush = function() {
										var e, t = this.chunks,
											r = this.dataLength;
										return t.length ? (e = 1 === t.length ? t[0] : function(e, t) {
											for (var r = new Uint8Array(t), n = 0, i = 0; i < e.length; i++) {
												var s = e[i];
												r.set(s, n), n += s.length
											}
											return r
										}(t, r), this.reset(), e) : new Uint8Array(0)
									}, t.reset = function() {
										this.chunks.length = 0, this.dataLength = 0
									}, e
								}()
							},
							"./src/demux/dummy-demuxed-track.ts": function(e, t, r) {
								"use strict";

								function n() {
									return {
										type: "",
										id: -1,
										pid: -1,
										inputTimeScale: 9e4,
										sequenceNumber: -1,
										samples: [],
										dropped: 0
									}
								}
								r.r(t), r.d(t, "dummyTrack", (function() {
									return n
								}))
							},
							"./src/demux/exp-golomb.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/utils/logger.ts"),
									i = function() {
										function e(e) {
											this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
										}
										var t = e.prototype;
										return t.loadWord = function() {
											var e = this.data,
												t = this.bytesAvailable,
												r = e.byteLength - t,
												n = new Uint8Array(4),
												i = Math.min(4, t);
											if (0 === i) throw new Error("no bytes available");
											n.set(e.subarray(r, r + i)), this.word = new DataView(n.buffer)
												.getUint32(0), this.bitsAvailable = 8 * i, this.bytesAvailable -= i
										}, t.skipBits = function(e) {
											var t;
											this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, e -= (t = e >> 3) >> 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
										}, t.readBits = function(e) {
											var t = Math.min(this.bitsAvailable, e),
												r = this.word >>> 32 - t;
											return e > 32 && n.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(), (t = e - t) > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r
										}, t.skipLZ = function() {
											var e;
											for (e = 0; e < this.bitsAvailable; ++e)
												if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;
											return this.loadWord(), e + this.skipLZ()
										}, t.skipUEG = function() {
											this.skipBits(1 + this.skipLZ())
										}, t.skipEG = function() {
											this.skipBits(1 + this.skipLZ())
										}, t.readUEG = function() {
											var e = this.skipLZ();
											return this.readBits(e + 1) - 1
										}, t.readEG = function() {
											var e = this.readUEG();
											return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
										}, t.readBoolean = function() {
											return 1 === this.readBits(1)
										}, t.readUByte = function() {
											return this.readBits(8)
										}, t.readUShort = function() {
											return this.readBits(16)
										}, t.readUInt = function() {
											return this.readBits(32)
										}, t.skipScalingList = function(e) {
											for (var t = 8, r = 8, n = 0; n < e; n++) 0 !== r && (r = (t + this.readEG() + 256) % 256), t = 0 === r ? t : r
										}, t.readSPS = function() {
											var e, t, r, n = 0,
												i = 0,
												s = 0,
												a = 0,
												o = this.readUByte.bind(this),
												l = this.readBits.bind(this),
												u = this.readUEG.bind(this),
												c = this.readBoolean.bind(this),
												d = this.skipBits.bind(this),
												f = this.skipEG.bind(this),
												h = this.skipUEG.bind(this),
												g = this.skipScalingList.bind(this);
											o();
											var v = o();
											if (l(5), d(3), o(), h(), 100 === v || 110 === v || 122 === v || 244 === v || 44 === v || 83 === v || 86 === v || 118 === v || 128 === v) {
												var p = u();
												if (3 === p && d(1), h(), h(), d(1), c())
													for (t = 3 !== p ? 8 : 12, r = 0; r < t; r++) c() && g(r < 6 ? 16 : 64)
											}
											h();
											var m = u();
											if (0 === m) u();
											else if (1 === m)
												for (d(1), f(), f(), e = u(), r = 0; r < e; r++) f();
											h(), d(1);
											var y = u(),
												b = u(),
												E = l(1);
											0 === E && d(1), d(1), c() && (n = u(), i = u(), s = u(), a = u());
											var _ = [1, 1];
											if (c() && c()) switch (o()) {
												case 1:
													_ = [1, 1];
													break;
												case 2:
													_ = [12, 11];
													break;
												case 3:
													_ = [10, 11];
													break;
												case 4:
													_ = [16, 11];
													break;
												case 5:
													_ = [40, 33];
													break;
												case 6:
													_ = [24, 11];
													break;
												case 7:
													_ = [20, 11];
													break;
												case 8:
													_ = [32, 11];
													break;
												case 9:
													_ = [80, 33];
													break;
												case 10:
													_ = [18, 11];
													break;
												case 11:
													_ = [15, 11];
													break;
												case 12:
													_ = [64, 33];
													break;
												case 13:
													_ = [160, 99];
													break;
												case 14:
													_ = [4, 3];
													break;
												case 15:
													_ = [3, 2];
													break;
												case 16:
													_ = [2, 1];
													break;
												case 255:
													_ = [o() << 8 | o(), o() << 8 | o()]
											}
											return {
												width: Math.ceil(16 * (y + 1) - 2 * n - 2 * i),
												height: (2 - E) * (b + 1) * 16 - (E ? 2 : 4) * (s + a),
												pixelRatio: _
											}
										}, t.readSliceType = function() {
											return this.readUByte(), this.readUEG(), this.readUEG()
										}, e
									}();
								t.default = i
							},
							"./src/demux/id3.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "isHeader", (function() {
									return i
								})), r.d(t, "isFooter", (function() {
									return s
								})), r.d(t, "getID3Data", (function() {
									return a
								})), r.d(t, "canParse", (function() {
									return l
								})), r.d(t, "getTimeStamp", (function() {
									return u
								})), r.d(t, "isTimeStampFrame", (function() {
									return c
								})), r.d(t, "getID3Frames", (function() {
									return f
								})), r.d(t, "decodeFrame", (function() {
									return h
								})), r.d(t, "utf8ArrayToStr", (function() {
									return y
								})), r.d(t, "testables", (function() {
									return b
								}));
								var n, i = function(e, t) {
										return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
									},
									s = function(e, t) {
										return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
									},
									a = function(e, t) {
										for (var r = t, n = 0; i(e, t);) n += 10, n += o(e, t + 6), s(e, t + 10) && (n += 10), t += n;
										if (n > 0) return e.subarray(r, r + n)
									},
									o = function(e, t) {
										var r = 0;
										return r = (127 & e[t]) << 21, r |= (127 & e[t + 1]) << 14, r |= (127 & e[t + 2]) << 7, r |= 127 & e[t + 3]
									},
									l = function(e, t) {
										return i(e, t) && o(e, t + 6) + 10 <= e.length - t
									},
									u = function(e) {
										for (var t = f(e), r = 0; r < t.length; r++) {
											var n = t[r];
											if (c(n)) return m(n)
										}
									},
									c = function(e) {
										return e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info
									},
									d = function(e) {
										var t = String.fromCharCode(e[0], e[1], e[2], e[3]),
											r = o(e, 4);
										return {
											type: t,
											size: r,
											data: e.subarray(10, 10 + r)
										}
									},
									f = function(e) {
										for (var t = 0, r = []; i(e, t);) {
											for (var n = o(e, t + 6), a = (t += 10) + n; t + 8 < a;) {
												var l = d(e.subarray(t)),
													u = h(l);
												u && r.push(u), t += l.size + 10
											}
											s(e, t) && (t += 10)
										}
										return r
									},
									h = function(e) {
										return "PRIV" === e.type ? g(e) : "W" === e.type[0] ? p(e) : v(e)
									},
									g = function(e) {
										if (!(e.size < 2)) {
											var t = y(e.data, !0),
												r = new Uint8Array(e.data.subarray(t.length + 1));
											return {
												key: e.type,
												info: t,
												data: r.buffer
											}
										}
									},
									v = function(e) {
										if (!(e.size < 2)) {
											if ("TXXX" === e.type) {
												var t = 1,
													r = y(e.data.subarray(t), !0);
												t += r.length + 1;
												var n = y(e.data.subarray(t));
												return {
													key: e.type,
													info: r,
													data: n
												}
											}
											var i = y(e.data.subarray(1));
											return {
												key: e.type,
												data: i
											}
										}
									},
									p = function(e) {
										if ("WXXX" === e.type) {
											if (e.size < 2) return;
											var t = 1,
												r = y(e.data.subarray(t), !0);
											t += r.length + 1;
											var n = y(e.data.subarray(t));
											return {
												key: e.type,
												info: r,
												data: n
											}
										}
										var i = y(e.data);
										return {
											key: e.type,
											data: i
										}
									},
									m = function(e) {
										if (8 === e.data.byteLength) {
											var t = new Uint8Array(e.data),
												r = 1 & t[3],
												n = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
											return n /= 45, r && (n += 47721858.84), Math.round(n)
										}
									},
									y = function(e, t) {
										void 0 === t && (t = !1);
										var r = E();
										if (r) {
											var n = r.decode(e);
											if (t) {
												var i = n.indexOf("\0");
												return -1 !== i ? n.substring(0, i) : n
											}
											return n.replace(/\0/g, "")
										}
										for (var s, a, o, l = e.length, u = "", c = 0; c < l;) {
											if (0 === (s = e[c++]) && t) return u;
											if (0 !== s && 3 !== s) switch (s >> 4) {
												case 0:
												case 1:
												case 2:
												case 3:
												case 4:
												case 5:
												case 6:
												case 7:
													u += String.fromCharCode(s);
													break;
												case 12:
												case 13:
													a = e[c++], u += String.fromCharCode((31 & s) << 6 | 63 & a);
													break;
												case 14:
													a = e[c++], o = e[c++], u += String.fromCharCode((15 & s) << 12 | (63 & a) << 6 | (63 & o) << 0)
											}
										}
										return u
									},
									b = {
										decodeTextFrame: v
									};

								function E() {
									return n || void 0 === self.TextDecoder || (n = new self.TextDecoder("utf-8")), n
								}
							},
							"./src/demux/mp3demuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/demux/base-audio-demuxer.ts"),
									i = r("./src/demux/id3.ts"),
									s = r("./src/utils/logger.ts"),
									a = r("./src/demux/mpegaudio.ts");

								function o(e, t) {
									return o = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, o(e, t)
								}
								var l = function(e) {
									var t, r;

									function n() {
										return e.apply(this, arguments) || this
									}
									r = e, (t = n)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, o(t, r);
									var l = n.prototype;
									return l.resetInitSegment = function(t, r, n) {
										e.prototype.resetInitSegment.call(this, t, r, n), this._audioTrack = {
											container: "audio/mpeg",
											type: "audio",
											id: 2,
											pid: -1,
											sequenceNumber: 0,
											isAAC: !1,
											samples: [],
											manifestCodec: t,
											duration: n,
											inputTimeScale: 9e4,
											dropped: 0
										}
									}, n.probe = function(e) {
										if (!e) return !1;
										for (var t = (i.getID3Data(e, 0) || [])
											.length, r = e.length; t < r; t++)
											if (a.probe(e, t)) return s.logger.log("MPEG Audio sync word found !"), !0;
										return !1
									}, l.canParse = function(e, t) {
										return a.canParse(e, t)
									}, l.appendFrame = function(e, t, r) {
										if (null !== this.initPTS) return a.appendFrame(e, t, r, this.initPTS, this.frameIndex)
									}, n
								}(n.default);
								l.minProbeByteLength = 4, t.default = l
							},
							"./src/demux/mp4demuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/utils/mp4-tools.ts"),
									i = r("./src/demux/dummy-demuxed-track.ts"),
									s = function() {
										function e(e, t) {
											this.remainderData = null, this.config = void 0, this.config = t
										}
										var t = e.prototype;
										return t.resetTimeStamp = function() {}, t.resetInitSegment = function() {}, t.resetContiguity = function() {}, e.probe = function(e) {
											return Object(n.findBox)({
													data: e,
													start: 0,
													end: Math.min(e.length, 16384)
												}, ["moof"])
												.length > 0
										}, t.demux = function(e) {
											var t = e,
												r = Object(i.dummyTrack)();
											if (this.config.progressive) {
												this.remainderData && (t = Object(n.appendUint8Array)(this.remainderData, e));
												var s = Object(n.segmentValidRange)(t);
												this.remainderData = s.remainder, r.samples = s.valid || new Uint8Array
											} else r.samples = t;
											return {
												audioTrack: Object(i.dummyTrack)(),
												avcTrack: r,
												id3Track: Object(i.dummyTrack)(),
												textTrack: Object(i.dummyTrack)()
											}
										}, t.flush = function() {
											var e = Object(i.dummyTrack)();
											return e.samples = this.remainderData || new Uint8Array, this.remainderData = null, {
												audioTrack: Object(i.dummyTrack)(),
												avcTrack: e,
												id3Track: Object(i.dummyTrack)(),
												textTrack: Object(i.dummyTrack)()
											}
										}, t.demuxSampleAes = function(e, t, r) {
											return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
										}, t.destroy = function() {}, e
									}();
								s.minProbeByteLength = 1024, t.default = s
							},
							"./src/demux/mpegaudio.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "appendFrame", (function() {
									return l
								})), r.d(t, "parseHeader", (function() {
									return u
								})), r.d(t, "isHeaderPattern", (function() {
									return c
								})), r.d(t, "isHeader", (function() {
									return d
								})), r.d(t, "canParse", (function() {
									return f
								})), r.d(t, "probe", (function() {
									return h
								}));
								var n = null,
									i = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
									s = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
									a = [
										[0, 72, 144, 12],
										[0, 0, 0, 0],
										[0, 72, 144, 12],
										[0, 144, 144, 12]
									],
									o = [0, 1, 1, 4];

								function l(e, t, r, n, i) {
									if (!(r + 24 > t.length)) {
										var s = u(t, r);
										if (s && r + s.frameLength <= t.length) {
											var a = n + i * (9e4 * s.samplesPerFrame / s.sampleRate),
												o = {
													unit: t.subarray(r, r + s.frameLength),
													pts: a,
													dts: a
												};
											return e.config = [], e.channelCount = s.channelCount, e.samplerate = s.sampleRate, e.samples.push(o), {
												sample: o,
												length: s.frameLength,
												missing: 0
											}
										}
									}
								}

								function u(e, t) {
									var r = e[t + 1] >> 3 & 3,
										l = e[t + 1] >> 1 & 3,
										u = e[t + 2] >> 4 & 15,
										c = e[t + 2] >> 2 & 3;
									if (1 !== r && 0 !== u && 15 !== u && 3 !== c) {
										var d = e[t + 2] >> 1 & 1,
											f = e[t + 3] >> 6,
											h = 1e3 * i[14 * (3 === r ? 3 - l : 3 === l ? 3 : 4) + u - 1],
											g = s[3 * (3 === r ? 0 : 2 === r ? 1 : 2) + c],
											v = 3 === f ? 1 : 2,
											p = a[r][l],
											m = o[l],
											y = 8 * p * m,
											b = Math.floor(p * h / g + d) * m;
										if (null === n) {
											var E = (navigator.userAgent || "")
												.match(/Chrome\/(\d+)/i);
											n = E ? parseInt(E[1]) : 0
										}
										return !!n && n <= 87 && 2 === l && h >= 224e3 && 0 === f && (e[t + 3] = 128 | e[t + 3]), {
											sampleRate: g,
											channelCount: v,
											frameLength: b,
											samplesPerFrame: y
										}
									}
								}

								function c(e, t) {
									return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
								}

								function d(e, t) {
									return t + 1 < e.length && c(e, t)
								}

								function f(e, t) {
									return c(e, t) && 4 <= e.length - t
								}

								function h(e, t) {
									if (t + 1 < e.length && c(e, t)) {
										var r = u(e, t),
											n = 4;
										null != r && r.frameLength && (n = r.frameLength);
										var i = t + n;
										return i === e.length || d(e, i)
									}
									return !1
								}
							},
							"./src/demux/sample-aes.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/crypt/decrypter.ts"),
									i = r("./src/demux/tsdemuxer.ts"),
									s = function() {
										function e(e, t, r) {
											this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new n.default(e, t, {
												removePKCS7Padding: !1
											})
										}
										var t = e.prototype;
										return t.decryptBuffer = function(e, t) {
											this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, t)
										}, t.decryptAacSample = function(e, t, r, n) {
											var i = e[t].unit,
												s = i.subarray(16, i.length - i.length % 16),
												a = s.buffer.slice(s.byteOffset, s.byteOffset + s.length),
												o = this;
											this.decryptBuffer(a, (function(s) {
												var a = new Uint8Array(s);
												i.set(a, 16), n || o.decryptAacSamples(e, t + 1, r)
											}))
										}, t.decryptAacSamples = function(e, t, r) {
											for (;; t++) {
												if (t >= e.length) return void r();
												if (!(e[t].unit.length < 32)) {
													var n = this.decrypter.isSync();
													if (this.decryptAacSample(e, t, r, n), !n) return
												}
											}
										}, t.getAvcEncryptedData = function(e) {
											for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, r = new Int8Array(t), n = 0, i = 32; i < e.length - 16; i += 160, n += 16) r.set(e.subarray(i, i + 16), n);
											return r
										}, t.getAvcDecryptedUnit = function(e, t) {
											for (var r = new Uint8Array(t), n = 0, i = 32; i < e.length - 16; i += 160, n += 16) e.set(r.subarray(n, n + 16), i);
											return e
										}, t.decryptAvcSample = function(e, t, r, n, s, a) {
											var o = Object(i.discardEPB)(s.data),
												l = this.getAvcEncryptedData(o),
												u = this;
											this.decryptBuffer(l.buffer, (function(i) {
												s.data = u.getAvcDecryptedUnit(o, i), a || u.decryptAvcSamples(e, t, r + 1, n)
											}))
										}, t.decryptAvcSamples = function(e, t, r, n) {
											if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
											for (;; t++, r = 0) {
												if (t >= e.length) return void n();
												for (var i = e[t].units; !(r >= i.length); r++) {
													var s = i[r];
													if (!(s.data.length <= 48 || 1 !== s.type && 5 !== s.type)) {
														var a = this.decrypter.isSync();
														if (this.decryptAvcSample(e, t, r, n, s, a), !a) return
													}
												}
											}
										}, e
									}();
								t.default = s
							},
							"./src/demux/transmuxer-interface.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return d
								}));
								var n = r("./node_modules/webworkify-webpack/index.js"),
									i = r("./src/events.ts"),
									s = r("./src/demux/transmuxer.ts"),
									a = r("./src/utils/logger.ts"),
									o = r("./src/errors.ts"),
									l = r("./src/utils/mediasource-helper.ts"),
									u = r("./node_modules/eventemitter3/index.js"),
									c = Object(l.getMediaSource)() || {
										isTypeSupported: function() {
											return !1
										}
									},
									d = function() {
										function e(e, t, r, l) {
											var d = this;
											this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.hls = e, this.id = t, this.onTransmuxComplete = r, this.onFlush = l;
											var f = e.config,
												h = function(t, r) {
													(r = r || {})
													.frag = d.frag, r.id = d.id, e.trigger(t, r)
												};
											this.observer = new u.EventEmitter, this.observer.on(i.Events.FRAG_DECRYPTED, h), this.observer.on(i.Events.ERROR, h);
											var g = {
													mp4: c.isTypeSupported("video/mp4"),
													mpeg: c.isTypeSupported("audio/mpeg"),
													mp3: c.isTypeSupported('audio/mp4; codecs="mp3"')
												},
												v = navigator.vendor;
											if (f.enableWorker && "undefined" != typeof Worker) {
												var p;
												a.logger.log("demuxing in webworker");
												try {
													p = this.worker = n("./src/demux/transmuxer-worker.ts"), this.onwmsg = this.onWorkerMessage.bind(this), p.addEventListener("message", this.onwmsg), p.onerror = function(t) {
														e.trigger(i.Events.ERROR, {
															type: o.ErrorTypes.OTHER_ERROR,
															details: o.ErrorDetails.INTERNAL_EXCEPTION,
															fatal: !0,
															event: "demuxerWorker",
															error: new Error(t.message + "  (" + t.filename + ":" + t.lineno + ")")
														})
													}, p.postMessage({
														cmd: "init",
														typeSupported: g,
														vendor: v,
														id: t,
														config: JSON.stringify(f)
													})
												} catch (e) {
													a.logger.warn("Error in worker:", e), a.logger.error("Error while initializing DemuxerWorker, fallback to inline"), p && self.URL.revokeObjectURL(p.objectURL), this.transmuxer = new s.default(this.observer, g, f, v, t), this.worker = null
												}
											} else this.transmuxer = new s.default(this.observer, g, f, v, t)
										}
										var t = e.prototype;
										return t.destroy = function() {
											var e = this.worker;
											if (e) e.removeEventListener("message", this.onwmsg), e.terminate(), this.worker = null;
											else {
												var t = this.transmuxer;
												t && (t.destroy(), this.transmuxer = null)
											}
											var r = this.observer;
											r && r.removeAllListeners(), this.observer = null
										}, t.push = function(e, t, r, n, i, o, l, u, c, d) {
											var f, h, g = this;
											c.transmuxing.start = self.performance.now();
											var v = this.transmuxer,
												p = this.worker,
												m = o ? o.start : i.start,
												y = i.decryptdata,
												b = this.frag,
												E = !(b && i.cc === b.cc),
												_ = !(b && c.level === b.level),
												T = b ? c.sn - b.sn : -1,
												S = this.part ? c.part - this.part.index : 1,
												A = !_ && (1 === T || 0 === T && 1 === S),
												L = self.performance.now();
											(_ || T || 0 === i.stats.parsing.start) && (i.stats.parsing.start = L), !o || !S && A || (o.stats.parsing.start = L);
											var w = !(b && (null === (f = i.initSegment) || void 0 === f ? void 0 : f.url) === (null === (h = b.initSegment) || void 0 === h ? void 0 : h.url)),
												k = new s.TransmuxState(E, A, u, _, m, w);
											if (!A || E || w) {
												a.logger.log("[transmuxer-interface, " + i.type + "]: Starting new transmux session for sn: " + c.sn + " p: " + c.part + " level: " + c.level + " id: " + c.id + "\n        discontinuity: " + E + "\n        trackSwitch: " + _ + "\n        contiguous: " + A + "\n        accurateTimeOffset: " + u + "\n        timeOffset: " + m + "\n        initSegmentChange: " + w);
												var C = new s.TransmuxConfig(r, n, t, l, d);
												this.configureTransmuxer(C)
											}
											if (this.frag = i, this.part = o, p) p.postMessage({
												cmd: "demux",
												data: e,
												decryptdata: y,
												chunkMeta: c,
												state: k
											}, e instanceof ArrayBuffer ? [e] : []);
											else if (v) {
												var P = v.push(e, y, c, k);
												Object(s.isPromise)(P) ? P.then((function(e) {
													g.handleTransmuxComplete(e)
												})) : this.handleTransmuxComplete(P)
											}
										}, t.flush = function(e) {
											var t = this;
											e.transmuxing.start = self.performance.now();
											var r = this.transmuxer,
												n = this.worker;
											if (n) n.postMessage({
												cmd: "flush",
												chunkMeta: e
											});
											else if (r) {
												var i = r.flush(e);
												Object(s.isPromise)(i) ? i.then((function(r) {
													t.handleFlushResult(r, e)
												})) : this.handleFlushResult(i, e)
											}
										}, t.handleFlushResult = function(e, t) {
											var r = this;
											e.forEach((function(e) {
												r.handleTransmuxComplete(e)
											})), this.onFlush(t)
										}, t.onWorkerMessage = function(e) {
											var t = e.data,
												r = this.hls;
											switch (t.event) {
												case "init":
													self.URL.revokeObjectURL(this.worker.objectURL);
													break;
												case "transmuxComplete":
													this.handleTransmuxComplete(t.data);
													break;
												case "flush":
													this.onFlush(t.data);
													break;
												default:
													t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data)
											}
										}, t.configureTransmuxer = function(e) {
											var t = this.worker,
												r = this.transmuxer;
											t ? t.postMessage({
												cmd: "configure",
												config: e
											}) : r && r.configure(e)
										}, t.handleTransmuxComplete = function(e) {
											e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e)
										}, e
									}()
							},
							"./src/demux/transmuxer-worker.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return o
								}));
								var n = r("./src/demux/transmuxer.ts"),
									i = r("./src/events.ts"),
									s = r("./src/utils/logger.ts"),
									a = r("./node_modules/eventemitter3/index.js");

								function o(e) {
									var t = new a.EventEmitter,
										r = function(t, r) {
											e.postMessage({
												event: t,
												data: r
											})
										};
									t.on(i.Events.FRAG_DECRYPTED, r), t.on(i.Events.ERROR, r), e.addEventListener("message", (function(i) {
										var a = i.data;
										switch (a.cmd) {
											case "init":
												var o = JSON.parse(a.config);
												e.transmuxer = new n.default(t, a.typeSupported, o, a.vendor, a.id), Object(s.enableLogs)(o.debug), r("init", null);
												break;
											case "configure":
												e.transmuxer.configure(a.config);
												break;
											case "demux":
												var u = e.transmuxer.push(a.data, a.decryptdata, a.chunkMeta, a.state);
												Object(n.isPromise)(u) ? u.then((function(t) {
													l(e, t)
												})) : l(e, u);
												break;
											case "flush":
												var d = a.chunkMeta,
													f = e.transmuxer.flush(d);
												Object(n.isPromise)(f) ? f.then((function(t) {
													c(e, t, d)
												})) : c(e, f, d)
										}
									}))
								}

								function l(e, t) {
									if ((r = t.remuxResult)
										.audio || r.video || r.text || r.id3 || r.initSegment) {
										var r, n = [],
											i = t.remuxResult,
											s = i.audio,
											a = i.video;
										s && u(n, s), a && u(n, a), e.postMessage({
											event: "transmuxComplete",
											data: t
										}, n)
									}
								}

								function u(e, t) {
									t.data1 && e.push(t.data1.buffer), t.data2 && e.push(t.data2.buffer)
								}

								function c(e, t, r) {
									t.forEach((function(t) {
										l(e, t)
									})), e.postMessage({
										event: "flush",
										data: r
									})
								}
							},
							"./src/demux/transmuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return y
								})), r.d(t, "isPromise", (function() {
									return E
								})), r.d(t, "TransmuxConfig", (function() {
									return _
								})), r.d(t, "TransmuxState", (function() {
									return T
								}));
								var n, i = r("./src/events.ts"),
									s = r("./src/errors.ts"),
									a = r("./src/crypt/decrypter.ts"),
									o = r("./src/demux/aacdemuxer.ts"),
									l = r("./src/demux/mp4demuxer.ts"),
									u = r("./src/demux/tsdemuxer.ts"),
									c = r("./src/demux/mp3demuxer.ts"),
									d = r("./src/remux/mp4-remuxer.ts"),
									f = r("./src/remux/passthrough-remuxer.ts"),
									h = r("./src/demux/chunk-cache.ts"),
									g = r("./src/utils/mp4-tools.ts"),
									v = r("./src/utils/logger.ts");
								try {
									n = self.performance.now.bind(self.performance)
								} catch (e) {
									v.logger.debug("Unable to use Performance API on this environment"), n = self.Date.now
								}
								var p = [{
										demux: u.default,
										remux: d.default
									}, {
										demux: l.default,
										remux: f.default
									}, {
										demux: o.default,
										remux: d.default
									}, {
										demux: c.default,
										remux: d.default
									}],
									m = 1024;
								p.forEach((function(e) {
									var t = e.demux;
									m = Math.max(m, t.minProbeByteLength)
								}));
								var y = function() {
										function e(e, t, r, n, i) {
											this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.cache = new h.default, this.observer = e, this.typeSupported = t, this.config = r, this.vendor = n, this.id = i
										}
										var t = e.prototype;
										return t.configure = function(e) {
											this.transmuxConfig = e, this.decrypter && this.decrypter.reset()
										}, t.push = function(e, t, r, i) {
											var s = this,
												a = r.transmuxing;
											a.executeStart = n();
											var o = new Uint8Array(e),
												l = this.cache,
												u = this.config,
												c = this.currentTransmuxState,
												d = this.transmuxConfig;
											i && (this.currentTransmuxState = i);
											var f = function(e, t) {
												var r = null;
												return e.byteLength > 0 && null != t && null != t.key && null !== t.iv && null != t.method && (r = t), r
											}(o, t);
											if (f && "AES-128" === f.method) {
												var h = this.getDecrypter();
												if (!u.enableSoftwareAES) return this.decryptionPromise = h.webCryptoDecrypt(o, f.key.buffer, f.iv.buffer)
													.then((function(e) {
														var t = s.push(e, null, r);
														return s.decryptionPromise = null, t
													})), this.decryptionPromise;
												var v = h.softwareDecrypt(o, f.key.buffer, f.iv.buffer);
												if (!v) return a.executeEnd = n(), b(r);
												o = new Uint8Array(v)
											}
											var p = i || c,
												m = p.contiguous,
												y = p.discontinuity,
												E = p.trackSwitch,
												_ = p.accurateTimeOffset,
												T = p.timeOffset,
												S = p.initSegmentChange,
												A = d.audioCodec,
												L = d.videoCodec,
												w = d.defaultInitPts,
												k = d.duration,
												C = d.initSegmentData;
											if ((y || E || S) && this.resetInitSegment(C, A, L, k), (y || S) && this.resetInitialTimestamp(w), m || this.resetContiguity(), this.needsProbing(o, y, E)) {
												if (l.dataLength) {
													var P = l.flush();
													o = Object(g.appendUint8Array)(P, o)
												}
												this.configureTransmuxer(o, d)
											}
											var D = this.transmux(o, f, T, _, r),
												R = this.currentTransmuxState;
											return R.contiguous = !0, R.discontinuity = !1, R.trackSwitch = !1, a.executeEnd = n(), D
										}, t.flush = function(e) {
											var t = this,
												r = e.transmuxing;
											r.executeStart = n();
											var a = this.decrypter,
												o = this.cache,
												l = this.currentTransmuxState,
												u = this.decryptionPromise;
											if (u) return u.then((function() {
												return t.flush(e)
											}));
											var c = [],
												d = l.timeOffset;
											if (a) {
												var f = a.flush();
												f && c.push(this.push(f, null, e))
											}
											var h = o.dataLength;
											o.reset();
											var g = this.demuxer,
												v = this.remuxer;
											if (!g || !v) return h >= m && this.observer.emit(i.Events.ERROR, i.Events.ERROR, {
												type: s.ErrorTypes.MEDIA_ERROR,
												details: s.ErrorDetails.FRAG_PARSING_ERROR,
												fatal: !0,
												reason: "no demux matching with content found"
											}), r.executeEnd = n(), [b(e)];
											var p = g.flush(d);
											return E(p) ? p.then((function(r) {
												return t.flushRemux(c, r, e), c
											})) : (this.flushRemux(c, p, e), c)
										}, t.flushRemux = function(e, t, r) {
											var i = t.audioTrack,
												s = t.avcTrack,
												a = t.id3Track,
												o = t.textTrack,
												l = this.currentTransmuxState,
												u = l.accurateTimeOffset,
												c = l.timeOffset;
											v.logger.log("[transmuxer.ts]: Flushed fragment " + r.sn + (r.part > -1 ? " p: " + r.part : "") + " of level " + r.level);
											var d = this.remuxer.remux(i, s, a, o, c, u, !0, this.id);
											e.push({
												remuxResult: d,
												chunkMeta: r
											}), r.transmuxing.executeEnd = n()
										}, t.resetInitialTimestamp = function(e) {
											var t = this.demuxer,
												r = this.remuxer;
											t && r && (t.resetTimeStamp(e), r.resetTimeStamp(e))
										}, t.resetContiguity = function() {
											var e = this.demuxer,
												t = this.remuxer;
											e && t && (e.resetContiguity(), t.resetNextTimestamp())
										}, t.resetInitSegment = function(e, t, r, n) {
											var i = this.demuxer,
												s = this.remuxer;
											i && s && (i.resetInitSegment(t, r, n), s.resetInitSegment(e, t, r))
										}, t.destroy = function() {
											this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
										}, t.transmux = function(e, t, r, n, i) {
											return t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, r, n, i) : this.transmuxUnencrypted(e, r, n, i)
										}, t.transmuxUnencrypted = function(e, t, r, n) {
											var i = this.demuxer.demux(e, t, !1, !this.config.progressive),
												s = i.audioTrack,
												a = i.avcTrack,
												o = i.id3Track,
												l = i.textTrack;
											return {
												remuxResult: this.remuxer.remux(s, a, o, l, t, r, !1, this.id),
												chunkMeta: n
											}
										}, t.transmuxSampleAes = function(e, t, r, n, i) {
											var s = this;
											return this.demuxer.demuxSampleAes(e, t, r)
												.then((function(e) {
													return {
														remuxResult: s.remuxer.remux(e.audioTrack, e.avcTrack, e.id3Track, e.textTrack, r, n, !1, s.id),
														chunkMeta: i
													}
												}))
										}, t.configureTransmuxer = function(e, t) {
											for (var r, n = this.config, i = this.observer, s = this.typeSupported, a = this.vendor, o = t.audioCodec, u = t.defaultInitPts, c = t.duration, d = t.initSegmentData, h = t.videoCodec, g = 0, m = p.length; g < m; g++)
												if (p[g].demux.probe(e)) {
													r = p[g];
													break
												} r || (v.logger.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough"), r = {
												demux: l.default,
												remux: f.default
											});
											var y = this.demuxer,
												b = this.remuxer,
												E = r.remux,
												_ = r.demux;
											b && b instanceof E || (this.remuxer = new E(i, n, s, a)), y && y instanceof _ || (this.demuxer = new _(i, n, s), this.probe = _.probe), this.resetInitSegment(d, o, h, c), this.resetInitialTimestamp(u)
										}, t.needsProbing = function(e, t, r) {
											return !this.demuxer || !this.remuxer || t || r
										}, t.getDecrypter = function() {
											var e = this.decrypter;
											return e || (e = this.decrypter = new a.default(this.observer, this.config)), e
										}, e
									}(),
									b = function(e) {
										return {
											remuxResult: {},
											chunkMeta: e
										}
									};

								function E(e) {
									return "then" in e && e.then instanceof Function
								}
								var _ = function(e, t, r, n, i) {
										this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = n, this.defaultInitPts = i
									},
									T = function(e, t, r, n, i, s) {
										this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = n, this.timeOffset = i, this.initSegmentChange = s
									}
							},
							"./src/demux/tsdemuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "discardEPB", (function() {
									return E
								}));
								var n = r("./src/demux/adts.ts"),
									i = r("./src/demux/mpegaudio.ts"),
									s = r("./src/demux/exp-golomb.ts"),
									a = r("./src/demux/id3.ts"),
									o = r("./src/demux/sample-aes.ts"),
									l = r("./src/events.ts"),
									u = r("./src/utils/mp4-tools.ts"),
									c = r("./src/utils/logger.ts"),
									d = r("./src/errors.ts"),
									f = {
										video: 1,
										audio: 2,
										id3: 3,
										text: 4
									},
									h = function() {
										function e(e, t, r) {
											this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this.aacLastPTS = null, this._initPTS = null, this._initDTS = null, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e, this.config = t, this.typeSupported = r
										}
										e.probe = function(t) {
											var r = e.syncOffset(t);
											return !(r < 0 || (r && c.logger.warn("MPEG2-TS detected but first sync word found @ offset " + r + ", junk ahead ?"), 0))
										}, e.syncOffset = function(e) {
											for (var t = Math.min(1e3, e.length - 564), r = 0; r < t;) {
												if (71 === e[r] && 71 === e[r + 188] && 71 === e[r + 376]) return r;
												r++
											}
											return -1
										}, e.createTrack = function(e, t) {
											return {
												container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
												type: e,
												id: f[e],
												pid: -1,
												inputTimeScale: 9e4,
												sequenceNumber: 0,
												samples: [],
												dropped: 0,
												duration: "audio" === e ? t : void 0
											}
										};
										var t = e.prototype;
										return t.resetInitSegment = function(t, r, n) {
											this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = e.createTrack("video", n), this._audioTrack = e.createTrack("audio", n), this._id3Track = e.createTrack("id3", n), this._txtTrack = e.createTrack("text", n), this._audioTrack.isAAC = !0, this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = t, this.videoCodec = r, this._duration = n
										}, t.resetTimeStamp = function() {}, t.resetContiguity = function() {
											var e = this._audioTrack,
												t = this._avcTrack,
												r = this._id3Track;
											e && (e.pesData = null), t && (t.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.aacLastPTS = null
										}, t.demux = function(t, r, n, i) {
											var s;
											void 0 === n && (n = !1), void 0 === i && (i = !1), n || (this.sampleAes = null);
											var a = this._avcTrack,
												o = this._audioTrack,
												f = this._id3Track,
												h = a.pid,
												g = a.pesData,
												y = o.pid,
												b = f.pid,
												E = o.pesData,
												_ = f.pesData,
												T = !1,
												S = this.pmtParsed,
												A = this._pmtId,
												L = t.length;
											if (this.remainderData && (L = (t = Object(u.appendUint8Array)(this.remainderData, t))
												.length, this.remainderData = null), L < 188 && !i) return this.remainderData = t, {
												audioTrack: o,
												avcTrack: a,
												id3Track: f,
												textTrack: this._txtTrack
											};
											var w = Math.max(0, e.syncOffset(t));
											(L -= (L + w) % 188) < t.byteLength && !i && (this.remainderData = new Uint8Array(t.buffer, L, t.buffer.byteLength - L));
											for (var k = 0, C = w; C < L; C += 188)
												if (71 === t[C]) {
													var P = !!(64 & t[C + 1]),
														D = ((31 & t[C + 1]) << 8) + t[C + 2],
														R = void 0;
													if ((48 & t[C + 3]) >> 4 > 1) {
														if ((R = C + 5 + t[C + 4]) === C + 188) continue
													} else R = C + 4;
													switch (D) {
														case h:
															P && (g && (s = m(g)) && this.parseAVCPES(s, !1), g = {
																data: [],
																size: 0
															}), g && (g.data.push(t.subarray(R, C + 188)), g.size += C + 188 - R);
															break;
														case y:
															P && (E && (s = m(E)) && (o.isAAC ? this.parseAACPES(s) : this.parseMPEGPES(s)), E = {
																data: [],
																size: 0
															}), E && (E.data.push(t.subarray(R, C + 188)), E.size += C + 188 - R);
															break;
														case b:
															P && (_ && (s = m(_)) && this.parseID3PES(s), _ = {
																data: [],
																size: 0
															}), _ && (_.data.push(t.subarray(R, C + 188)), _.size += C + 188 - R);
															break;
														case 0:
															P && (R += t[R] + 1), A = this._pmtId = v(t, R);
															break;
														case A:
															P && (R += t[R] + 1);
															var I = p(t, R, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, n);
															(h = I.avc) > 0 && (a.pid = h), (y = I.audio) > 0 && (o.pid = y, o.isAAC = I.isAAC), (b = I.id3) > 0 && (f.pid = b), T && !S && (c.logger.log("reparse from beginning"), T = !1, C = w - 188), S = this.pmtParsed = !0;
															break;
														case 17:
														case 8191:
															break;
														default:
															T = !0
													}
												} else k++;
											k > 0 && this.observer.emit(l.Events.ERROR, l.Events.ERROR, {
												type: d.ErrorTypes.MEDIA_ERROR,
												details: d.ErrorDetails.FRAG_PARSING_ERROR,
												fatal: !1,
												reason: "Found " + k + " TS packet/s that do not start with 0x47"
											}), a.pesData = g, o.pesData = E, f.pesData = _;
											var O = {
												audioTrack: o,
												avcTrack: a,
												id3Track: f,
												textTrack: this._txtTrack
											};
											return i && this.extractRemainingSamples(O), O
										}, t.flush = function() {
											var e, t = this.remainderData;
											return this.remainderData = null, e = t ? this.demux(t, -1, !1, !0) : {
												audioTrack: this._audioTrack,
												avcTrack: this._avcTrack,
												textTrack: this._txtTrack,
												id3Track: this._id3Track
											}, this.extractRemainingSamples(e), this.sampleAes ? this.decrypt(e, this.sampleAes) : e
										}, t.extractRemainingSamples = function(e) {
											var t, r = e.audioTrack,
												n = e.avcTrack,
												i = e.id3Track,
												s = n.pesData,
												a = r.pesData,
												o = i.pesData;
											s && (t = m(s)) ? (this.parseAVCPES(t, !0), n.pesData = null) : n.pesData = s, a && (t = m(a)) ? (r.isAAC ? this.parseAACPES(t) : this.parseMPEGPES(t), r.pesData = null) : (null != a && a.size && c.logger.log("last AAC PES packet truncated,might overlap between fragments"), r.pesData = a), o && (t = m(o)) ? (this.parseID3PES(t), i.pesData = null) : i.pesData = o
										}, t.demuxSampleAes = function(e, t, r) {
											var n = this.demux(e, r, !0, !this.config.progressive),
												i = this.sampleAes = new o.default(this.observer, this.config, t);
											return this.decrypt(n, i)
										}, t.decrypt = function(e, t) {
											return new Promise((function(r) {
												var n = e.audioTrack,
													i = e.avcTrack;
												n.samples && n.isAAC ? t.decryptAacSamples(n.samples, 0, (function() {
													i.samples ? t.decryptAvcSamples(i.samples, 0, 0, (function() {
														r(e)
													})) : r(e)
												})) : i.samples && t.decryptAvcSamples(i.samples, 0, 0, (function() {
													r(e)
												}))
											}))
										}, t.destroy = function() {
											this._initPTS = this._initDTS = null, this._duration = 0
										}, t.parseAVCPES = function(e, t) {
											var r, n = this,
												i = this._avcTrack,
												o = this.parseAVCNALu(e.data),
												l = this.avcSample,
												u = !1;
											e.data = null, l && o.length && !i.audFound && (y(l, i), l = this.avcSample = g(!1, e.pts, e.dts, "")), o.forEach((function(t) {
												switch (t.type) {
													case 1:
														r = !0, l || (l = n.avcSample = g(!0, e.pts, e.dts, "")), l.frame = !0;
														var o = t.data;
														if (u && o.length > 4) {
															var c = new s.default(o)
																.readSliceType();
															2 !== c && 4 !== c && 7 !== c && 9 !== c || (l.key = !0)
														}
														break;
													case 5:
														r = !0, l || (l = n.avcSample = g(!0, e.pts, e.dts, "")), l.key = !0, l.frame = !0;
														break;
													case 6:
														r = !0;
														var d = new s.default(E(t.data));
														d.readUByte();
														for (var f = 0, h = 0, v = !1, p = 0; !v && d.bytesAvailable > 1;) {
															f = 0;
															do {
																f += p = d.readUByte()
															} while (255 === p);
															h = 0;
															do {
																h += p = d.readUByte()
															} while (255 === p);
															if (4 === f && 0 !== d.bytesAvailable) {
																if (v = !0, 181 === d.readUByte() && 49 === d.readUShort() && 1195456820 === d.readUInt() && 3 === d.readUByte()) {
																	for (var m = d.readUByte(), _ = 31 & m, T = [m, d.readUByte()], S = 0; S < _; S++) T.push(d.readUByte()), T.push(d.readUByte()), T.push(d.readUByte());
																	b(n._txtTrack.samples, {
																		type: 3,
																		pts: e.pts,
																		bytes: T
																	})
																}
															} else if (5 === f && 0 !== d.bytesAvailable) {
																if (v = !0, h > 16) {
																	for (var A = [], L = 0; L < 16; L++) A.push(d.readUByte()
																		.toString(16)), 3 !== L && 5 !== L && 7 !== L && 9 !== L || A.push("-");
																	for (var w = h - 16, k = new Uint8Array(w), C = 0; C < w; C++) k[C] = d.readUByte();
																	b(n._txtTrack.samples, {
																		pts: e.pts,
																		payloadType: f,
																		uuid: A.join(""),
																		userData: Object(a.utf8ArrayToStr)(k),
																		userDataBytes: k
																	})
																}
															} else if (h < d.bytesAvailable)
																for (var P = 0; P < h; P++) d.readUByte()
														}
														break;
													case 7:
														if (r = !0, u = !0, !i.sps) {
															var D = new s.default(t.data)
																.readSPS();
															i.width = D.width, i.height = D.height, i.pixelRatio = D.pixelRatio, i.sps = [t.data], i.duration = n._duration;
															for (var R = t.data.subarray(1, 4), I = "avc1.", O = 0; O < 3; O++) {
																var x = R[O].toString(16);
																x.length < 2 && (x = "0" + x), I += x
															}
															i.codec = I
														}
														break;
													case 8:
														r = !0, i.pps || (i.pps = [t.data]);
														break;
													case 9:
														r = !1, i.audFound = !0, l && y(l, i), l = n.avcSample = g(!1, e.pts, e.dts, "");
														break;
													case 12:
														r = !1;
														break;
													default:
														r = !1, l && (l.debug += "unknown NAL " + t.type + " ")
												}
												l && r && l.units.push(t)
											})), t && l && (y(l, i), this.avcSample = null)
										}, t.getLastNalUnit = function() {
											var e, t, r = this.avcSample;
											if (!r || 0 === r.units.length) {
												var n = this._avcTrack.samples;
												r = n[n.length - 1]
											}
											if (null !== (e = r) && void 0 !== e && e.units) {
												var i = r.units;
												t = i[i.length - 1]
											}
											return t
										}, t.parseAVCNALu = function(e) {
											var t, r, n = e.byteLength,
												i = this._avcTrack,
												s = i.naluState || 0,
												a = s,
												o = [],
												l = 0,
												u = -1,
												c = 0;
											for (-1 === s && (u = 0, c = 31 & e[0], s = 0, l = 1); l < n;)
												if (t = e[l++], s)
													if (1 !== s)
														if (t)
															if (1 === t) {
																if (u >= 0) {
																	var d = {
																		data: e.subarray(u, l - s - 1),
																		type: c
																	};
																	o.push(d)
																} else {
																	var f = this.getLastNalUnit();
																	if (f && (a && l <= 4 - a && f.state && (f.data = f.data.subarray(0, f.data.byteLength - a)), (r = l - s - 1) > 0)) {
																		var h = new Uint8Array(f.data.byteLength + r);
																		h.set(f.data, 0), h.set(e.subarray(0, r), f.data.byteLength), f.data = h, f.state = 0
																	}
																}
																l < n ? (u = l, c = 31 & e[l], s = 0) : s = -1
															} else s = 0;
											else s = 3;
											else s = t ? 0 : 2;
											else s = t ? 0 : 1;
											if (u >= 0 && s >= 0) {
												var g = {
													data: e.subarray(u, n),
													type: c,
													state: s
												};
												o.push(g)
											}
											if (0 === o.length) {
												var v = this.getLastNalUnit();
												if (v) {
													var p = new Uint8Array(v.data.byteLength + e.byteLength);
													p.set(v.data, 0), p.set(e, v.data.byteLength), v.data = p
												}
											}
											return i.naluState = s, o
										}, t.parseAACPES = function(e) {
											var t, r, i, s, a, o = 0,
												u = this._audioTrack,
												f = this.aacOverFlow,
												h = e.data;
											if (f) {
												this.aacOverFlow = null;
												var g = f.sample.unit.byteLength,
													v = Math.min(f.missing, g),
													p = g - v;
												f.sample.unit.set(h.subarray(0, v), p), u.samples.push(f.sample), o = f.missing
											}
											for (t = o, r = h.length; t < r - 1 && !n.isHeader(h, t); t++);
											if (t === o || (t < r - 1 ? (i = "AAC PES did not start with ADTS header,offset:" + t, s = !1) : (i = "no ADTS header found in AAC PES", s = !0), c.logger.warn("parsing error:" + i), this.observer.emit(l.Events.ERROR, l.Events.ERROR, {
												type: d.ErrorTypes.MEDIA_ERROR,
												details: d.ErrorDetails.FRAG_PARSING_ERROR,
												fatal: s,
												reason: i
											}), !s)) {
												if (n.initTrackConfig(u, this.observer, h, t, this.audioCodec), void 0 !== e.pts) a = e.pts;
												else {
													if (!f) return void c.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
													var m = n.getFrameDuration(u.samplerate);
													a = f.sample.pts + m
												}
												for (var y = 0; t < r;) {
													if (n.isHeader(h, t)) {
														if (t + 5 < r) {
															var b = n.appendFrame(u, h, t, a, y);
															if (b) {
																if (!b.missing) {
																	t += b.length, y++;
																	continue
																}
																this.aacOverFlow = b
															}
														}
														break
													}
													t++
												}
											}
										}, t.parseMPEGPES = function(e) {
											var t = e.data,
												r = t.length,
												n = 0,
												s = 0,
												a = e.pts;
											if (void 0 !== a)
												for (; s < r;)
													if (i.isHeader(t, s)) {
														var o = i.appendFrame(this._audioTrack, t, s, a, n);
														if (!o) break;
														s += o.length, n++
													} else s++;
											else c.logger.warn("[tsdemuxer]: MPEG PES unknown PTS")
										}, t.parseID3PES = function(e) {
											void 0 !== e.pts ? this._id3Track.samples.push(e) : c.logger.warn("[tsdemuxer]: ID3 PES unknown PTS")
										}, e
									}();

								function g(e, t, r, n) {
									return {
										key: e,
										frame: !1,
										pts: t,
										dts: r,
										units: [],
										debug: n,
										length: 0
									}
								}

								function v(e, t) {
									return (31 & e[t + 10]) << 8 | e[t + 11]
								}

								function p(e, t, r, n) {
									var i = {
											audio: -1,
											avc: -1,
											id3: -1,
											isAAC: !0
										},
										s = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
									for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < s;) {
										var a = (31 & e[t + 1]) << 8 | e[t + 2];
										switch (e[t]) {
											case 207:
												if (!n) {
													c.logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
													break
												}
											case 15:
												-1 === i.audio && (i.audio = a);
												break;
											case 21:
												-1 === i.id3 && (i.id3 = a);
												break;
											case 219:
												if (!n) {
													c.logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
													break
												}
											case 27:
												-1 === i.avc && (i.avc = a);
												break;
											case 3:
											case 4:
												r ? -1 === i.audio && (i.audio = a, i.isAAC = !1) : c.logger.log("MPEG audio found, not supported in this browser");
												break;
											case 36:
												c.logger.warn("Unsupported HEVC stream type found")
										}
										t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
									}
									return i
								}

								function m(e) {
									var t, r, n, i, s, a = 0,
										o = e.data;
									if (!e || 0 === e.size) return null;
									for (; o[0].length < 19 && o.length > 1;) {
										var l = new Uint8Array(o[0].length + o[1].length);
										l.set(o[0]), l.set(o[1], o[0].length), o[0] = l, o.splice(1, 1)
									}
									if (1 === ((t = o[0])[0] << 16) + (t[1] << 8) + t[2]) {
										if ((r = (t[4] << 8) + t[5]) && r > e.size - 6) return null;
										var u = t[7];
										192 & u && (i = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, 64 & u ? i - (s = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2) > 54e5 && (c.logger.warn(Math.round((i - s) / 9e4) + "s delta between PTS and DTS, align them"), i = s) : s = i);
										var d = (n = t[8]) + 9;
										if (e.size <= d) return null;
										e.size -= d;
										for (var f = new Uint8Array(e.size), h = 0, g = o.length; h < g; h++) {
											var v = (t = o[h])
												.byteLength;
											if (d) {
												if (d > v) {
													d -= v;
													continue
												}
												t = t.subarray(d), v -= d, d = 0
											}
											f.set(t, a), a += v
										}
										return r && (r -= n + 3), {
											data: f,
											pts: i,
											dts: s,
											len: r
										}
									}
									return null
								}

								function y(e, t) {
									if (e.units.length && e.frame) {
										if (void 0 === e.pts) {
											var r = t.samples,
												n = r.length;
											if (!n) return void t.dropped++;
											var i = r[n - 1];
											e.pts = i.pts, e.dts = i.dts
										}
										t.samples.push(e)
									}
									e.debug.length && c.logger.log(e.pts + "/" + e.dts + ":" + e.debug)
								}

								function b(e, t) {
									var r = e.length;
									if (r > 0) {
										if (t.pts >= e[r - 1].pts) e.push(t);
										else
											for (var n = r - 1; n >= 0; n--)
												if (t.pts < e[n].pts) {
													e.splice(n, 0, t);
													break
												}
									} else e.push(t)
								}

								function E(e) {
									for (var t = e.byteLength, r = [], n = 1; n < t - 2;) 0 === e[n] && 0 === e[n + 1] && 3 === e[n + 2] ? (r.push(n + 2), n += 2) : n++;
									if (0 === r.length) return e;
									var i = t - r.length,
										s = new Uint8Array(i),
										a = 0;
									for (n = 0; n < i; a++, n++) a === r[0] && (a++, r.shift()), s[n] = e[a];
									return s
								}
								h.minProbeByteLength = 188, t.default = h
							},
							"./src/errors.ts": function(e, t, r) {
								"use strict";
								var n, i;
								r.r(t), r.d(t, "ErrorTypes", (function() {
										return n
									})), r.d(t, "ErrorDetails", (function() {
										return i
									})),
									function(e) {
										e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError"
									}(n || (n = {})),
									function(e) {
										e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException", e.INTERNAL_ABORTED = "aborted", e.UNKNOWN = "unknown"
									}(i || (i = {}))
							},
							"./src/events.ts": function(e, t, r) {
								"use strict";
								var n;
								r.r(t), r.d(t, "Events", (function() {
										return n
									})),
									function(e) {
										e.MEDIA_ATTACHING = "hlsMediaAttaching", e.MEDIA_ATTACHED = "hlsMediaAttached", e.MEDIA_DETACHING = "hlsMediaDetaching", e.MEDIA_DETACHED = "hlsMediaDetached", e.BUFFER_RESET = "hlsBufferReset", e.BUFFER_CODECS = "hlsBufferCodecs", e.BUFFER_CREATED = "hlsBufferCreated", e.BUFFER_APPENDING = "hlsBufferAppending", e.BUFFER_APPENDED = "hlsBufferAppended", e.BUFFER_EOS = "hlsBufferEos", e.BUFFER_FLUSHING = "hlsBufferFlushing", e.BUFFER_FLUSHED = "hlsBufferFlushed", e.MANIFEST_LOADING = "hlsManifestLoading", e.MANIFEST_LOADED = "hlsManifestLoaded", e.MANIFEST_PARSED = "hlsManifestParsed", e.LEVEL_SWITCHING = "hlsLevelSwitching", e.LEVEL_SWITCHED = "hlsLevelSwitched", e.LEVEL_LOADING = "hlsLevelLoading", e.LEVEL_LOADED = "hlsLevelLoaded", e.LEVEL_UPDATED = "hlsLevelUpdated", e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e.LEVELS_UPDATED = "hlsLevelsUpdated", e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e.CUES_PARSED = "hlsCuesParsed", e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e.INIT_PTS_FOUND = "hlsInitPtsFound", e.FRAG_LOADING = "hlsFragLoading", e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e.FRAG_LOADED = "hlsFragLoaded", e.FRAG_DECRYPTED = "hlsFragDecrypted", e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e.FRAG_PARSED = "hlsFragParsed", e.FRAG_BUFFERED = "hlsFragBuffered", e.FRAG_CHANGED = "hlsFragChanged", e.FPS_DROP = "hlsFpsDrop", e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e.ERROR = "hlsError", e.DESTROYING = "hlsDestroying", e.KEY_LOADING = "hlsKeyLoading", e.KEY_LOADED = "hlsKeyLoaded", e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e.BACK_BUFFER_REACHED = "hlsBackBufferReached"
									}(n || (n = {}))
							},
							"./src/hls.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return y
								}));
								var n = r("./node_modules/url-toolkit/src/url-toolkit.js"),
									i = r("./src/loader/playlist-loader.ts"),
									s = r("./src/loader/key-loader.ts"),
									a = r("./src/controller/id3-track-controller.ts"),
									o = r("./src/controller/latency-controller.ts"),
									l = r("./src/controller/level-controller.ts"),
									u = r("./src/controller/fragment-tracker.ts"),
									c = r("./src/controller/stream-controller.ts"),
									d = r("./src/is-supported.ts"),
									f = r("./src/utils/logger.ts"),
									h = r("./src/config.ts"),
									g = r("./node_modules/eventemitter3/index.js"),
									v = r("./src/events.ts"),
									p = r("./src/errors.ts");

								function m(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var y = function() {
									function e(t) {
										void 0 === t && (t = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new g.EventEmitter, this._autoLevelCapping = void 0, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null;
										var r = this.config = Object(h.mergeConfig)(e.DefaultConfig, t);
										this.userConfig = t, Object(f.enableLogs)(r.debug), this._autoLevelCapping = -1, r.progressive && Object(h.enableStreamingMode)(r);
										var n = r.abrController,
											d = r.bufferController,
											v = r.capLevelController,
											p = r.fpsController,
											m = this.abrController = new n(this),
											y = this.bufferController = new d(this),
											b = this.capLevelController = new v(this),
											E = new p(this),
											_ = new i.default(this),
											T = new s.default(this),
											S = new a.default(this),
											A = this.levelController = new l.default(this),
											L = new u.FragmentTracker(this),
											w = this.streamController = new c.default(this, L);
										b.setStreamController(w), E.setStreamController(w);
										var k = [A, w];
										this.networkControllers = k;
										var C = [_, T, m, y, b, E, S, L];
										this.audioTrackController = this.createController(r.audioTrackController, null, k), this.createController(r.audioStreamController, L, k), this.subtitleTrackController = this.createController(r.subtitleTrackController, null, k), this.createController(r.subtitleStreamController, L, k), this.createController(r.timelineController, null, C), this.emeController = this.createController(r.emeController, null, C), this.cmcdController = this.createController(r.cmcdController, null, C), this.latencyController = this.createController(o.default, null, C), this.coreComponents = C
									}
									e.isSupported = function() {
										return Object(d.isSupported)()
									};
									var t, r, y, b = e.prototype;
									return b.createController = function(e, t, r) {
										if (e) {
											var n = t ? new e(this, t) : new e(this);
											return r && r.push(n), n
										}
										return null
									}, b.on = function(e, t, r) {
										void 0 === r && (r = this), this._emitter.on(e, t, r)
									}, b.once = function(e, t, r) {
										void 0 === r && (r = this), this._emitter.once(e, t, r)
									}, b.removeAllListeners = function(e) {
										this._emitter.removeAllListeners(e)
									}, b.off = function(e, t, r, n) {
										void 0 === r && (r = this), this._emitter.off(e, t, r, n)
									}, b.listeners = function(e) {
										return this._emitter.listeners(e)
									}, b.emit = function(e, t, r) {
										return this._emitter.emit(e, t, r)
									}, b.trigger = function(e, t) {
										if (this.config.debug) return this.emit(e, e, t);
										try {
											return this.emit(e, e, t)
										} catch (t) {
											f.logger.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), this.trigger(v.Events.ERROR, {
												type: p.ErrorTypes.OTHER_ERROR,
												details: p.ErrorDetails.INTERNAL_EXCEPTION,
												fatal: !1,
												event: e,
												error: t
											})
										}
										return !1
									}, b.listenerCount = function(e) {
										return this._emitter.listenerCount(e)
									}, b.destroy = function() {
										f.logger.log("destroy"), this.trigger(v.Events.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach((function(e) {
											return e.destroy()
										})), this.networkControllers.length = 0, this.coreComponents.forEach((function(e) {
											return e.destroy()
										})), this.coreComponents.length = 0
									}, b.attachMedia = function(e) {
										f.logger.log("attachMedia"), this._media = e, this.trigger(v.Events.MEDIA_ATTACHING, {
											media: e
										})
									}, b.detachMedia = function() {
										f.logger.log("detachMedia"), this.trigger(v.Events.MEDIA_DETACHING, void 0), this._media = null
									}, b.loadSource = function(e) {
										this.stopLoad();
										var t = this.media,
											r = this.url,
											i = this.url = n.buildAbsoluteURL(self.location.href, e, {
												alwaysNormalize: !0
											});
										f.logger.log("loadSource:" + i), t && r && r !== i && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(t)), this.trigger(v.Events.MANIFEST_LOADING, {
											url: e
										})
									}, b.startLoad = function(e) {
										void 0 === e && (e = -1), f.logger.log("startLoad(" + e + ")"), this.networkControllers.forEach((function(t) {
											t.startLoad(e)
										}))
									}, b.stopLoad = function() {
										f.logger.log("stopLoad"), this.networkControllers.forEach((function(e) {
											e.stopLoad()
										}))
									}, b.swapAudioCodec = function() {
										f.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec()
									}, b.recoverMediaError = function() {
										f.logger.log("recoverMediaError");
										var e = this._media;
										this.detachMedia(), e && this.attachMedia(e)
									}, b.removeLevel = function(e, t) {
										void 0 === t && (t = 0), this.levelController.removeLevel(e, t)
									}, t = e, y = [{
										key: "version",
										get: function() {
											return "1.1.5"
										}
									}, {
										key: "Events",
										get: function() {
											return v.Events
										}
									}, {
										key: "ErrorTypes",
										get: function() {
											return p.ErrorTypes
										}
									}, {
										key: "ErrorDetails",
										get: function() {
											return p.ErrorDetails
										}
									}, {
										key: "DefaultConfig",
										get: function() {
											return e.defaultConfig ? e.defaultConfig : h.hlsDefaultConfig
										},
										set: function(t) {
											e.defaultConfig = t
										}
									}], (r = [{
										key: "levels",
										get: function() {
											var e = this.levelController.levels;
											return e || []
										}
									}, {
										key: "currentLevel",
										get: function() {
											return this.streamController.currentLevel
										},
										set: function(e) {
											f.logger.log("set currentLevel:" + e), this.loadLevel = e, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch()
										}
									}, {
										key: "nextLevel",
										get: function() {
											return this.streamController.nextLevel
										},
										set: function(e) {
											f.logger.log("set nextLevel:" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
										}
									}, {
										key: "loadLevel",
										get: function() {
											return this.levelController.level
										},
										set: function(e) {
											f.logger.log("set loadLevel:" + e), this.levelController.manualLevel = e
										}
									}, {
										key: "nextLoadLevel",
										get: function() {
											return this.levelController.nextLoadLevel
										},
										set: function(e) {
											this.levelController.nextLoadLevel = e
										}
									}, {
										key: "firstLevel",
										get: function() {
											return Math.max(this.levelController.firstLevel, this.minAutoLevel)
										},
										set: function(e) {
											f.logger.log("set firstLevel:" + e), this.levelController.firstLevel = e
										}
									}, {
										key: "startLevel",
										get: function() {
											return this.levelController.startLevel
										},
										set: function(e) {
											f.logger.log("set startLevel:" + e), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e
										}
									}, {
										key: "capLevelToPlayerSize",
										get: function() {
											return this.config.capLevelToPlayerSize
										},
										set: function(e) {
											var t = !!e;
											t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t)
										}
									}, {
										key: "autoLevelCapping",
										get: function() {
											return this._autoLevelCapping
										},
										set: function(e) {
											this._autoLevelCapping !== e && (f.logger.log("set autoLevelCapping:" + e), this._autoLevelCapping = e)
										}
									}, {
										key: "bandwidthEstimate",
										get: function() {
											var e = this.abrController.bwEstimator;
											return e ? e.getEstimate() : NaN
										}
									}, {
										key: "autoLevelEnabled",
										get: function() {
											return -1 === this.levelController.manualLevel
										}
									}, {
										key: "manualLevel",
										get: function() {
											return this.levelController.manualLevel
										}
									}, {
										key: "minAutoLevel",
										get: function() {
											var e = this.levels,
												t = this.config.minAutoBitrate;
											if (!e) return 0;
											for (var r = e.length, n = 0; n < r; n++)
												if (e[n].maxBitrate > t) return n;
											return 0
										}
									}, {
										key: "maxAutoLevel",
										get: function() {
											var e = this.levels,
												t = this.autoLevelCapping;
											return -1 === t && e && e.length ? e.length - 1 : t
										}
									}, {
										key: "nextAutoLevel",
										get: function() {
											return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
										},
										set: function(e) {
											this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
										}
									}, {
										key: "audioTracks",
										get: function() {
											var e = this.audioTrackController;
											return e ? e.audioTracks : []
										}
									}, {
										key: "audioTrack",
										get: function() {
											var e = this.audioTrackController;
											return e ? e.audioTrack : -1
										},
										set: function(e) {
											var t = this.audioTrackController;
											t && (t.audioTrack = e)
										}
									}, {
										key: "subtitleTracks",
										get: function() {
											var e = this.subtitleTrackController;
											return e ? e.subtitleTracks : []
										}
									}, {
										key: "subtitleTrack",
										get: function() {
											var e = this.subtitleTrackController;
											return e ? e.subtitleTrack : -1
										},
										set: function(e) {
											var t = this.subtitleTrackController;
											t && (t.subtitleTrack = e)
										}
									}, {
										key: "media",
										get: function() {
											return this._media
										}
									}, {
										key: "subtitleDisplay",
										get: function() {
											var e = this.subtitleTrackController;
											return !!e && e.subtitleDisplay
										},
										set: function(e) {
											var t = this.subtitleTrackController;
											t && (t.subtitleDisplay = e)
										}
									}, {
										key: "lowLatencyMode",
										get: function() {
											return this.config.lowLatencyMode
										},
										set: function(e) {
											this.config.lowLatencyMode = e
										}
									}, {
										key: "liveSyncPosition",
										get: function() {
											return this.latencyController.liveSyncPosition
										}
									}, {
										key: "latency",
										get: function() {
											return this.latencyController.latency
										}
									}, {
										key: "maxLatency",
										get: function() {
											return this.latencyController.maxLatency
										}
									}, {
										key: "targetLatency",
										get: function() {
											return this.latencyController.targetLatency
										}
									}, {
										key: "drift",
										get: function() {
											return this.latencyController.drift
										}
									}, {
										key: "forceStartLoad",
										get: function() {
											return this.streamController.forceStartLoad
										}
									}]) && m(t.prototype, r), y && m(t, y), e
								}();
								y.defaultConfig = void 0
							},
							"./src/is-supported.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "isSupported", (function() {
									return s
								})), r.d(t, "changeTypeSupported", (function() {
									return a
								}));
								var n = r("./src/utils/mediasource-helper.ts");

								function i() {
									return self.SourceBuffer || self.WebKitSourceBuffer
								}

								function s() {
									var e = Object(n.getMediaSource)();
									if (!e) return !1;
									var t = i(),
										r = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
										s = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
									return !!r && !!s
								}

								function a() {
									var e, t = i();
									return "function" == typeof(null == t || null === (e = t.prototype) || void 0 === e ? void 0 : e.changeType)
								}
							},
							"./src/loader/fragment-loader.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return d
								})), r.d(t, "LoadError", (function() {
									return h
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/errors.ts");

								function s(e) {
									var t = "function" == typeof Map ? new Map : void 0;
									return s = function(e) {
										if (null === e || (r = e, -1 === Function.toString.call(r)
											.indexOf("[native code]"))) return e;
										var r;
										if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
										if (void 0 !== t) {
											if (t.has(e)) return t.get(e);
											t.set(e, n)
										}

										function n() {
											return a(e, arguments, u(this)
												.constructor)
										}
										return n.prototype = Object.create(e.prototype, {
											constructor: {
												value: n,
												enumerable: !1,
												writable: !0,
												configurable: !0
											}
										}), l(n, e)
									}, s(e)
								}

								function a(e, t, r) {
									return a = o() ? Reflect.construct : function(e, t, r) {
										var n = [null];
										n.push.apply(n, t);
										var i = new(Function.bind.apply(e, n));
										return r && l(i, r.prototype), i
									}, a.apply(null, arguments)
								}

								function o() {
									if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
									if (Reflect.construct.sham) return !1;
									if ("function" == typeof Proxy) return !0;
									try {
										return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
									} catch (e) {
										return !1
									}
								}

								function l(e, t) {
									return l = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, l(e, t)
								}

								function u(e) {
									return u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									}, u(e)
								}
								var c = Math.pow(2, 17),
									d = function() {
										function e(e) {
											this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e
										}
										var t = e.prototype;
										return t.destroy = function() {
											this.loader && (this.loader.destroy(), this.loader = null)
										}, t.abort = function() {
											this.loader && this.loader.abort()
										}, t.load = function(e, t) {
											var r = this,
												n = e.url;
											if (!n) return Promise.reject(new h({
												type: i.ErrorTypes.NETWORK_ERROR,
												details: i.ErrorDetails.FRAG_LOAD_ERROR,
												fatal: !1,
												frag: e,
												networkDetails: null
											}, "Fragment does not have a " + (n ? "part list" : "url")));
											this.abort();
											var s = this.config,
												a = s.fLoader,
												o = s.loader;
											return new Promise((function(n, l) {
												r.loader && r.loader.destroy();
												var u = r.loader = e.loader = a ? new a(s) : new o(s),
													d = f(e),
													g = {
														timeout: s.fragLoadingTimeOut,
														maxRetry: 0,
														retryDelay: 0,
														maxRetryDelay: s.fragLoadingMaxRetryTimeout,
														highWaterMark: c
													};
												e.stats = u.stats, u.load(d, g, {
													onSuccess: function(t, i, s, a) {
														r.resetLoader(e, u), n({
															frag: e,
															part: null,
															payload: t.data,
															networkDetails: a
														})
													},
													onError: function(t, n, s) {
														r.resetLoader(e, u), l(new h({
															type: i.ErrorTypes.NETWORK_ERROR,
															details: i.ErrorDetails.FRAG_LOAD_ERROR,
															fatal: !1,
															frag: e,
															response: t,
															networkDetails: s
														}))
													},
													onAbort: function(t, n, s) {
														r.resetLoader(e, u), l(new h({
															type: i.ErrorTypes.NETWORK_ERROR,
															details: i.ErrorDetails.INTERNAL_ABORTED,
															fatal: !1,
															frag: e,
															networkDetails: s
														}))
													},
													onTimeout: function(t, n, s) {
														r.resetLoader(e, u), l(new h({
															type: i.ErrorTypes.NETWORK_ERROR,
															details: i.ErrorDetails.FRAG_LOAD_TIMEOUT,
															fatal: !1,
															frag: e,
															networkDetails: s
														}))
													},
													onProgress: function(r, n, i, s) {
														t && t({
															frag: e,
															part: null,
															payload: i,
															networkDetails: s
														})
													}
												})
											}))
										}, t.loadPart = function(e, t, r) {
											var n = this;
											this.abort();
											var s = this.config,
												a = s.fLoader,
												o = s.loader;
											return new Promise((function(l, u) {
												n.loader && n.loader.destroy();
												var d = n.loader = e.loader = a ? new a(s) : new o(s),
													g = f(e, t),
													v = {
														timeout: s.fragLoadingTimeOut,
														maxRetry: 0,
														retryDelay: 0,
														maxRetryDelay: s.fragLoadingMaxRetryTimeout,
														highWaterMark: c
													};
												t.stats = d.stats, d.load(g, v, {
													onSuccess: function(i, s, a, o) {
														n.resetLoader(e, d), n.updateStatsFromPart(e, t);
														var u = {
															frag: e,
															part: t,
															payload: i.data,
															networkDetails: o
														};
														r(u), l(u)
													},
													onError: function(r, s, a) {
														n.resetLoader(e, d), u(new h({
															type: i.ErrorTypes.NETWORK_ERROR,
															details: i.ErrorDetails.FRAG_LOAD_ERROR,
															fatal: !1,
															frag: e,
															part: t,
															response: r,
															networkDetails: a
														}))
													},
													onAbort: function(r, s, a) {
														e.stats.aborted = t.stats.aborted, n.resetLoader(e, d), u(new h({
															type: i.ErrorTypes.NETWORK_ERROR,
															details: i.ErrorDetails.INTERNAL_ABORTED,
															fatal: !1,
															frag: e,
															part: t,
															networkDetails: a
														}))
													},
													onTimeout: function(r, s, a) {
														n.resetLoader(e, d), u(new h({
															type: i.ErrorTypes.NETWORK_ERROR,
															details: i.ErrorDetails.FRAG_LOAD_TIMEOUT,
															fatal: !1,
															frag: e,
															part: t,
															networkDetails: a
														}))
													}
												})
											}))
										}, t.updateStatsFromPart = function(e, t) {
											var r = e.stats,
												n = t.stats,
												i = n.total;
											if (r.loaded += n.loaded, i) {
												var s = Math.round(e.duration / t.duration),
													a = Math.min(Math.round(r.loaded / i), s),
													o = (s - a) * Math.round(r.loaded / a);
												r.total = r.loaded + o
											} else r.total = Math.max(r.loaded, r.total);
											var l = r.loading,
												u = n.loading;
											l.start ? l.first += u.first - u.start : (l.start = u.start, l.first = u.first), l.end = u.end
										}, t.resetLoader = function(e, t) {
											e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy()
										}, e
									}();

								function f(e, t) {
									void 0 === t && (t = null);
									var r = t || e,
										i = {
											frag: e,
											part: t,
											responseType: "arraybuffer",
											url: r.url,
											headers: {},
											rangeStart: 0,
											rangeEnd: 0
										},
										s = r.byteRangeStartOffset,
										a = r.byteRangeEndOffset;
									return Object(n.isFiniteNumber)(s) && Object(n.isFiniteNumber)(a) && (i.rangeStart = s, i.rangeEnd = a), i
								}
								var h = function(e) {
									var t, r;

									function n(t) {
										for (var r, n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++) i[s - 1] = arguments[s];
										return (r = e.call.apply(e, [this].concat(i)) || this)
											.data = void 0, r.data = t, r
									}
									return r = e, (t = n)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, l(t, r), n
								}(s(Error))
							},
							"./src/loader/fragment.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "ElementaryStreamTypes", (function() {
									return n
								})), r.d(t, "BaseSegment", (function() {
									return h
								})), r.d(t, "Fragment", (function() {
									return g
								})), r.d(t, "Part", (function() {
									return v
								}));
								var n, i = r("./src/polyfills/number.ts"),
									s = r("./node_modules/url-toolkit/src/url-toolkit.js"),
									a = r("./src/utils/logger.ts"),
									o = r("./src/loader/level-key.ts"),
									l = r("./src/loader/load-stats.ts");

								function u(e, t) {
									e.prototype = Object.create(t.prototype), e.prototype.constructor = e, c(e, t)
								}

								function c(e, t) {
									return c = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, c(e, t)
								}

								function d(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}

								function f(e, t, r) {
									return t && d(e.prototype, t), r && d(e, r), e
								}! function(e) {
									e.AUDIO = "audio", e.VIDEO = "video", e.AUDIOVIDEO = "audiovideo"
								}(n || (n = {}));
								var h = function() {
										function e(e) {
											var t;
											this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = ((t = {})[n.AUDIO] = null, t[n.VIDEO] = null, t[n.AUDIOVIDEO] = null, t), this.baseurl = e
										}
										return e.prototype.setByteRange = function(e, t) {
											var r = e.split("@", 2),
												n = [];
											1 === r.length ? n[0] = t ? t.byteRangeEndOffset : 0 : n[0] = parseInt(r[1]), n[1] = parseInt(r[0]) + n[0], this._byteRange = n
										}, f(e, [{
											key: "byteRange",
											get: function() {
												return this._byteRange ? this._byteRange : []
											}
										}, {
											key: "byteRangeStartOffset",
											get: function() {
												return this.byteRange[0]
											}
										}, {
											key: "byteRangeEndOffset",
											get: function() {
												return this.byteRange[1]
											}
										}, {
											key: "url",
											get: function() {
												return !this._url && this.baseurl && this.relurl && (this._url = Object(s.buildAbsoluteURL)(this.baseurl, this.relurl, {
													alwaysNormalize: !0
												})), this._url || ""
											},
											set: function(e) {
												this._url = e
											}
										}]), e
									}(),
									g = function(e) {
										function t(t, r) {
											var n;
											return (n = e.call(this, r) || this)
												._decryptdata = null, n.rawProgramDateTime = null, n.programDateTime = null, n.tagList = [], n.duration = 0, n.sn = 0, n.levelkey = void 0, n.type = void 0, n.loader = null, n.level = -1, n.cc = 0, n.startPTS = void 0, n.endPTS = void 0, n.appendedPTS = void 0, n.startDTS = void 0, n.endDTS = void 0, n.start = 0, n.deltaPTS = void 0, n.maxStartPTS = void 0, n.minEndPTS = void 0, n.stats = new l.LoadStats, n.urlId = 0, n.data = void 0, n.bitrateTest = !1, n.title = null, n.initSegment = null, n.type = t, n
										}
										u(t, e);
										var r = t.prototype;
										return r.createInitializationVector = function(e) {
											for (var t = new Uint8Array(16), r = 12; r < 16; r++) t[r] = e >> 8 * (15 - r) & 255;
											return t
										}, r.setDecryptDataFromLevelKey = function(e, t) {
											var r = e;
											return "AES-128" === (null == e ? void 0 : e.method) && e.uri && !e.iv && ((r = o.LevelKey.fromURI(e.uri))
												.method = e.method, r.iv = this.createInitializationVector(t), r.keyFormat = "identity"), r
										}, r.setElementaryStreamInfo = function(e, t, r, n, i, s) {
											void 0 === s && (s = !1);
											var a = this.elementaryStreams,
												o = a[e];
											o ? (o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, r), o.startDTS = Math.min(o.startDTS, n), o.endDTS = Math.max(o.endDTS, i)) : a[e] = {
												startPTS: t,
												endPTS: r,
												startDTS: n,
												endDTS: i,
												partial: s
											}
										}, r.clearElementaryStreamInfo = function() {
											var e = this.elementaryStreams;
											e[n.AUDIO] = null, e[n.VIDEO] = null, e[n.AUDIOVIDEO] = null
										}, f(t, [{
											key: "decryptdata",
											get: function() {
												if (!this.levelkey && !this._decryptdata) return null;
												if (!this._decryptdata && this.levelkey) {
													var e = this.sn;
													"number" != typeof e && (this.levelkey && "AES-128" === this.levelkey.method && !this.levelkey.iv && a.logger.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'), e = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, e)
												}
												return this._decryptdata
											}
										}, {
											key: "end",
											get: function() {
												return this.start + this.duration
											}
										}, {
											key: "endProgramDateTime",
											get: function() {
												if (null === this.programDateTime) return null;
												if (!Object(i.isFiniteNumber)(this.programDateTime)) return null;
												var e = Object(i.isFiniteNumber)(this.duration) ? this.duration : 0;
												return this.programDateTime + 1e3 * e
											}
										}, {
											key: "encrypted",
											get: function() {
												var e;
												return !(null === (e = this.decryptdata) || void 0 === e || !e.keyFormat || !this.decryptdata.uri)
											}
										}]), t
									}(h),
									v = function(e) {
										function t(t, r, n, i, s) {
											var a;
											(a = e.call(this, n) || this)
											.fragOffset = 0, a.duration = 0, a.gap = !1, a.independent = !1, a.relurl = void 0, a.fragment = void 0, a.index = void 0, a.stats = new l.LoadStats, a.duration = t.decimalFloatingPoint("DURATION"), a.gap = t.bool("GAP"), a.independent = t.bool("INDEPENDENT"), a.relurl = t.enumeratedString("URI"), a.fragment = r, a.index = i;
											var o = t.enumeratedString("BYTERANGE");
											return o && a.setByteRange(o, s), s && (a.fragOffset = s.fragOffset + s.duration), a
										}
										return u(t, e), f(t, [{
											key: "start",
											get: function() {
												return this.fragment.start + this.fragOffset
											}
										}, {
											key: "end",
											get: function() {
												return this.start + this.duration
											}
										}, {
											key: "loaded",
											get: function() {
												var e = this.elementaryStreams;
												return !!(e.audio || e.video || e.audiovideo)
											}
										}]), t
									}(h)
							},
							"./src/loader/key-loader.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return a
								}));
								var n = r("./src/events.ts"),
									i = r("./src/errors.ts"),
									s = r("./src/utils/logger.ts"),
									a = function() {
										function e(e) {
											this.hls = void 0, this.loaders = {}, this.decryptkey = null, this.decrypturl = null, this.hls = e, this._registerListeners()
										}
										var t = e.prototype;
										return t._registerListeners = function() {
											this.hls.on(n.Events.KEY_LOADING, this.onKeyLoading, this)
										}, t._unregisterListeners = function() {
											this.hls.off(n.Events.KEY_LOADING, this.onKeyLoading)
										}, t.destroy = function() {
											for (var e in this._unregisterListeners(), this.loaders) {
												var t = this.loaders[e];
												t && t.destroy()
											}
											this.loaders = {}
										}, t.onKeyLoading = function(e, t) {
											var r = t.frag,
												i = r.type,
												a = this.loaders[i];
											if (r.decryptdata) {
												var o = r.decryptdata.uri;
												if (o !== this.decrypturl || null === this.decryptkey) {
													var l = this.hls.config;
													if (a && (s.logger.warn("abort previous key loader for type:" + i), a.abort()), !o) return void s.logger.warn("key uri is falsy");
													var u = l.loader,
														c = r.loader = this.loaders[i] = new u(l);
													this.decrypturl = o, this.decryptkey = null;
													var d = {
															url: o,
															frag: r,
															responseType: "arraybuffer"
														},
														f = {
															timeout: l.fragLoadingTimeOut,
															maxRetry: 0,
															retryDelay: l.fragLoadingRetryDelay,
															maxRetryDelay: l.fragLoadingMaxRetryTimeout,
															highWaterMark: 0
														},
														h = {
															onSuccess: this.loadsuccess.bind(this),
															onError: this.loaderror.bind(this),
															onTimeout: this.loadtimeout.bind(this)
														};
													c.load(d, f, h)
												} else this.decryptkey && (r.decryptdata.key = this.decryptkey, this.hls.trigger(n.Events.KEY_LOADED, {
													frag: r
												}))
											} else s.logger.warn("Missing decryption data on fragment in onKeyLoading")
										}, t.loadsuccess = function(e, t, r) {
											var i = r.frag;
											i.decryptdata ? (this.decryptkey = i.decryptdata.key = new Uint8Array(e.data), i.loader = null, delete this.loaders[i.type], this.hls.trigger(n.Events.KEY_LOADED, {
												frag: i
											})) : s.logger.error("after key load, decryptdata unset")
										}, t.loaderror = function(e, t) {
											var r = t.frag,
												s = r.loader;
											s && s.abort(), delete this.loaders[r.type], this.hls.trigger(n.Events.ERROR, {
												type: i.ErrorTypes.NETWORK_ERROR,
												details: i.ErrorDetails.KEY_LOAD_ERROR,
												fatal: !1,
												frag: r,
												response: e
											})
										}, t.loadtimeout = function(e, t) {
											var r = t.frag,
												s = r.loader;
											s && s.abort(), delete this.loaders[r.type], this.hls.trigger(n.Events.ERROR, {
												type: i.ErrorTypes.NETWORK_ERROR,
												details: i.ErrorDetails.KEY_LOAD_TIMEOUT,
												fatal: !1,
												frag: r
											})
										}, e
									}()
							},
							"./src/loader/level-details.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "LevelDetails", (function() {
									return s
								}));
								var n = r("./src/polyfills/number.ts");

								function i(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var s = function() {
									function e(e) {
										this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.fragments = [], this.url = e
									}
									var t, r, s;
									return e.prototype.reloaded = function(e) {
										if (!e) return this.advanced = !0, void(this.updated = !0);
										var t = this.lastPartSn - e.lastPartSn,
											r = this.lastPartIndex - e.lastPartIndex;
										this.updated = this.endSN !== e.endSN || !!r || !!t, this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && r > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay
									}, t = e, (r = [{
										key: "hasProgramDateTime",
										get: function() {
											return !!this.fragments.length && Object(n.isFiniteNumber)(this.fragments[this.fragments.length - 1].programDateTime)
										}
									}, {
										key: "levelTargetDuration",
										get: function() {
											return this.averagetargetduration || this.targetduration || 10
										}
									}, {
										key: "drift",
										get: function() {
											var e = this.driftEndTime - this.driftStartTime;
											return e > 0 ? 1e3 * (this.driftEnd - this.driftStart) / e : 1
										}
									}, {
										key: "edge",
										get: function() {
											return this.partEnd || this.fragmentEnd
										}
									}, {
										key: "partEnd",
										get: function() {
											var e;
											return null !== (e = this.partList) && void 0 !== e && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
										}
									}, {
										key: "fragmentEnd",
										get: function() {
											var e;
											return null !== (e = this.fragments) && void 0 !== e && e.length ? this.fragments[this.fragments.length - 1].end : 0
										}
									}, {
										key: "age",
										get: function() {
											return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
										}
									}, {
										key: "lastPartIndex",
										get: function() {
											var e;
											return null !== (e = this.partList) && void 0 !== e && e.length ? this.partList[this.partList.length - 1].index : -1
										}
									}, {
										key: "lastPartSn",
										get: function() {
											var e;
											return null !== (e = this.partList) && void 0 !== e && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
										}
									}]) && i(t.prototype, r), s && i(t, s), e
								}()
							},
							"./src/loader/level-key.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "LevelKey", (function() {
									return s
								}));
								var n = r("./node_modules/url-toolkit/src/url-toolkit.js");

								function i(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var s = function() {
									function e(e, t) {
										this._uri = null, this.method = null, this.keyFormat = null, this.keyFormatVersions = null, this.keyID = null, this.key = null, this.iv = null, this._uri = t ? Object(n.buildAbsoluteURL)(e, t, {
											alwaysNormalize: !0
										}) : e
									}
									var t, r, s;
									return e.fromURL = function(t, r) {
										return new e(t, r)
									}, e.fromURI = function(t) {
										return new e(t)
									}, t = e, (r = [{
										key: "uri",
										get: function() {
											return this._uri
										}
									}]) && i(t.prototype, r), s && i(t, s), e
								}()
							},
							"./src/loader/load-stats.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "LoadStats", (function() {
									return n
								}));
								var n = function() {
									this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
										start: 0,
										first: 0,
										end: 0
									}, this.parsing = {
										start: 0,
										end: 0
									}, this.buffering = {
										start: 0,
										first: 0,
										end: 0
									}
								}
							},
							"./src/loader/m3u8-parser.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return p
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./node_modules/url-toolkit/src/url-toolkit.js"),
									s = r("./src/loader/fragment.ts"),
									a = r("./src/loader/level-details.ts"),
									o = r("./src/loader/level-key.ts"),
									l = r("./src/utils/attr-list.ts"),
									u = r("./src/utils/logger.ts"),
									c = r("./src/utils/codecs.ts"),
									d = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+/g,
									f = /#EXT-X-MEDIA:(.*)/g,
									h = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
									g = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(PLAYLIST-TYPE):(.+)/.source, /#EXT-X-(MEDIA-SEQUENCE): *(\d+)/.source, /#EXT-X-(SKIP):(.+)/.source, /#EXT-X-(TARGETDURATION): *(\d+)/.source, /#EXT-X-(KEY):(.+)/.source, /#EXT-X-(START):(.+)/.source, /#EXT-X-(ENDLIST)/.source, /#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\d+)/.source, /#EXT-X-(DIS)CONTINUITY/.source, /#EXT-X-(VERSION):(\d+)/.source, /#EXT-X-(MAP):(.+)/.source, /#EXT-X-(SERVER-CONTROL):(.+)/.source, /#EXT-X-(PART-INF):(.+)/.source, /#EXT-X-(GAP)/.source, /#EXT-X-(BITRATE):\s*(\d+)/.source, /#EXT-X-(PART):(.+)/.source, /#EXT-X-(PRELOAD-HINT):(.+)/.source, /#EXT-X-(RENDITION-REPORT):(.+)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")),
									v = /\.(mp4|m4s|m4v|m4a)$/i,
									p = function() {
										function e() {}
										return e.findGroup = function(e, t) {
											for (var r = 0; r < e.length; r++) {
												var n = e[r];
												if (n.id === t) return n
											}
										}, e.convertAVC1ToAVCOTI = function(e) {
											var t = e.split(".");
											if (t.length > 2) {
												var r = t.shift() + ".";
												return r += parseInt(t.shift())
													.toString(16), r += ("000" + parseInt(t.shift())
														.toString(16))
													.substr(-4)
											}
											return e
										}, e.resolve = function(e, t) {
											return i.buildAbsoluteURL(t, e, {
												alwaysNormalize: !0
											})
										}, e.parseMasterPlaylist = function(t, r) {
											var n, i = [],
												s = {},
												a = !1;
											for (d.lastIndex = 0; null != (n = d.exec(t));)
												if (n[1]) {
													var o = new l.AttrList(n[1]),
														u = {
															attrs: o,
															bitrate: o.decimalInteger("AVERAGE-BANDWIDTH") || o.decimalInteger("BANDWIDTH"),
															name: o.NAME,
															url: e.resolve(n[2], r)
														},
														c = o.decimalResolution("RESOLUTION");
													c && (u.width = c.width, u.height = c.height), m((o.CODECS || "")
														.split(/[ ,]+/)
														.filter((function(e) {
															return e
														})), u), u.videoCodec && -1 !== u.videoCodec.indexOf("avc1") && (u.videoCodec = e.convertAVC1ToAVCOTI(u.videoCodec)), i.push(u)
												} else if (n[3]) {
												var f = new l.AttrList(n[3]);
												f["DATA-ID"] && (a = !0, s[f["DATA-ID"]] = f)
											}
											return {
												levels: i,
												sessionData: a ? s : null
											}
										}, e.parseMasterPlaylistMedia = function(t, r, n, i) {
											var s;
											void 0 === i && (i = []);
											var a = [],
												o = 0;
											for (f.lastIndex = 0; null !== (s = f.exec(t));) {
												var u = new l.AttrList(s[1]);
												if (u.TYPE === n) {
													var c = {
														attrs: u,
														bitrate: 0,
														id: o++,
														groupId: u["GROUP-ID"],
														instreamId: u["INSTREAM-ID"],
														name: u.NAME || u.LANGUAGE || "",
														type: n,
														default: u.bool("DEFAULT"),
														autoselect: u.bool("AUTOSELECT"),
														forced: u.bool("FORCED"),
														lang: u.LANGUAGE,
														url: u.URI ? e.resolve(u.URI, r) : ""
													};
													if (i.length) {
														var d = e.findGroup(i, c.groupId) || i[0];
														y(c, d, "audioCodec"), y(c, d, "textCodec")
													}
													a.push(c)
												}
											}
											return a
										}, e.parseLevelPlaylist = function(e, t, r, c, d) {
											var f, p, m, y = new a.LevelDetails(t),
												E = y.fragments,
												_ = null,
												T = 0,
												S = 0,
												A = 0,
												L = 0,
												w = null,
												k = new s.Fragment(c, t),
												C = -1,
												P = !1;
											for (h.lastIndex = 0, y.m3u8 = e; null !== (f = h.exec(e));) {
												P && (P = !1, (k = new s.Fragment(c, t))
													.start = A, k.sn = T, k.cc = L, k.level = r, _ && (k.initSegment = _, k.rawProgramDateTime = _.rawProgramDateTime));
												var D = f[1];
												if (D) {
													k.duration = parseFloat(D);
													var R = (" " + f[2])
														.slice(1);
													k.title = R || null, k.tagList.push(R ? ["INF", D, R] : ["INF", D])
												} else if (f[3]) Object(n.isFiniteNumber)(k.duration) && (k.start = A, m && (k.levelkey = m), k.sn = T, k.level = r, k.cc = L, k.urlId = d, E.push(k), k.relurl = (" " + f[3])
													.slice(1), b(k, w), w = k, A += k.duration, T++, S = 0, P = !0);
												else if (f[4]) {
													var I = (" " + f[4])
														.slice(1);
													w ? k.setByteRange(I, w) : k.setByteRange(I)
												} else if (f[5]) k.rawProgramDateTime = (" " + f[5])
													.slice(1), k.tagList.push(["PROGRAM-DATE-TIME", k.rawProgramDateTime]), -1 === C && (C = E.length);
												else {
													if (!(f = f[0].match(g))) {
														u.logger.warn("No matches on slow regex match for level playlist!");
														continue
													}
													for (p = 1; p < f.length && void 0 === f[p]; p++);
													var O = (" " + f[p])
														.slice(1),
														x = (" " + f[p + 1])
														.slice(1),
														M = f[p + 2] ? (" " + f[p + 2])
														.slice(1) : "";
													switch (O) {
														case "PLAYLIST-TYPE":
															y.type = x.toUpperCase();
															break;
														case "MEDIA-SEQUENCE":
															T = y.startSN = parseInt(x);
															break;
														case "SKIP":
															var F = new l.AttrList(x),
																N = F.decimalInteger("SKIPPED-SEGMENTS");
															if (Object(n.isFiniteNumber)(N)) {
																y.skippedSegments = N;
																for (var B = N; B--;) E.unshift(null);
																T += N
															}
															var U = F.enumeratedString("RECENTLY-REMOVED-DATERANGES");
															U && (y.recentlyRemovedDateranges = U.split("\t"));
															break;
														case "TARGETDURATION":
															y.targetduration = parseFloat(x);
															break;
														case "VERSION":
															y.version = parseInt(x);
															break;
														case "EXTM3U":
															break;
														case "ENDLIST":
															y.live = !1;
															break;
														case "#":
															(x || M) && k.tagList.push(M ? [x, M] : [x]);
															break;
														case "DIS":
															L++;
														case "GAP":
															k.tagList.push([O]);
															break;
														case "BITRATE":
															k.tagList.push([O, x]);
															break;
														case "DISCONTINUITY-SEQ":
															L = parseInt(x);
															break;
														case "KEY":
															var j, G = new l.AttrList(x),
																H = G.enumeratedString("METHOD"),
																K = G.URI,
																q = G.hexadecimalInteger("IV"),
																V = G.enumeratedString("KEYFORMATVERSIONS"),
																W = G.enumeratedString("KEYID"),
																z = null != (j = G.enumeratedString("KEYFORMAT")) ? j : "identity";
															if (["com.apple.streamingkeydelivery", "com.microsoft.playready", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", "com.widevine"].indexOf(z) > -1) {
																u.logger.warn("Keyformat " + z + " is not supported from the manifest");
																continue
															}
															if ("identity" !== z) continue;
															H && (m = o.LevelKey.fromURL(t, K), K && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(H) >= 0 && (m.method = H, m.keyFormat = z, W && (m.keyID = W), V && (m.keyFormatVersions = V), m.iv = q));
															break;
														case "START":
															var Y = new l.AttrList(x)
																.decimalFloatingPoint("TIME-OFFSET");
															Object(n.isFiniteNumber)(Y) && (y.startTimeOffset = Y);
															break;
														case "MAP":
															var X = new l.AttrList(x);
															k.relurl = X.URI, X.BYTERANGE && k.setByteRange(X.BYTERANGE), k.level = r, k.sn = "initSegment", m && (k.levelkey = m), k.initSegment = null, _ = k, P = !0;
															break;
														case "SERVER-CONTROL":
															var J = new l.AttrList(x);
															y.canBlockReload = J.bool("CAN-BLOCK-RELOAD"), y.canSkipUntil = J.optionalFloat("CAN-SKIP-UNTIL", 0), y.canSkipDateRanges = y.canSkipUntil > 0 && J.bool("CAN-SKIP-DATERANGES"), y.partHoldBack = J.optionalFloat("PART-HOLD-BACK", 0), y.holdBack = J.optionalFloat("HOLD-BACK", 0);
															break;
														case "PART-INF":
															var Q = new l.AttrList(x);
															y.partTarget = Q.decimalFloatingPoint("PART-TARGET");
															break;
														case "PART":
															var Z = y.partList;
															Z || (Z = y.partList = []);
															var $ = S > 0 ? Z[Z.length - 1] : void 0,
																ee = S++,
																te = new s.Part(new l.AttrList(x), k, t, ee, $);
															Z.push(te), k.duration += te.duration;
															break;
														case "PRELOAD-HINT":
															var re = new l.AttrList(x);
															y.preloadHint = re;
															break;
														case "RENDITION-REPORT":
															var ne = new l.AttrList(x);
															y.renditionReports = y.renditionReports || [], y.renditionReports.push(ne);
															break;
														default:
															u.logger.warn("line parsed but not handled: " + f)
													}
												}
											}
											w && !w.relurl ? (E.pop(), A -= w.duration, y.partList && (y.fragmentHint = w)) : y.partList && (b(k, w), k.cc = L, y.fragmentHint = k);
											var ie = E.length,
												se = E[0],
												ae = E[ie - 1];
											if ((A += y.skippedSegments * y.targetduration) > 0 && ie && ae) {
												y.averagetargetduration = A / ie;
												var oe = ae.sn;
												y.endSN = "initSegment" !== oe ? oe : 0, se && (y.startCC = se.cc, se.initSegment || y.fragments.every((function(e) {
													return e.relurl && (t = e.relurl, v.test(null != (r = null === (n = i.parseURL(t)) || void 0 === n ? void 0 : n.path) ? r : ""));
													var t, r, n
												})) && (u.logger.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"), (k = new s.Fragment(c, t))
													.relurl = ae.relurl, k.level = r, k.sn = "initSegment", se.initSegment = k, y.needSidxRanges = !0))
											} else y.endSN = 0, y.startCC = 0;
											return y.fragmentHint && (A += y.fragmentHint.duration), y.totalduration = A, y.endCC = L, C > 0 && function(e, t) {
												for (var r = e[t], n = t; n--;) {
													var i = e[n];
													if (!i) return;
													i.programDateTime = r.programDateTime - 1e3 * i.duration, r = i
												}
											}(E, C), y
										}, e
									}();

								function m(e, t) {
									["video", "audio", "text"].forEach((function(r) {
										var n = e.filter((function(e) {
											return Object(c.isCodecType)(e, r)
										}));
										if (n.length) {
											var i = n.filter((function(e) {
												return 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)
											}));
											t[r + "Codec"] = i.length > 0 ? i[0] : n[0], e = e.filter((function(e) {
												return -1 === n.indexOf(e)
											}))
										}
									})), t.unknownCodecs = e
								}

								function y(e, t, r) {
									var n = t[r];
									n && (e[r] = n)
								}

								function b(e, t) {
									e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), Object(n.isFiniteNumber)(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null)
								}
							},
							"./src/loader/playlist-loader.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/events.ts"),
									s = r("./src/errors.ts"),
									a = r("./src/utils/logger.ts"),
									o = r("./src/utils/mp4-tools.ts"),
									l = r("./src/loader/m3u8-parser.ts"),
									u = r("./src/types/loader.ts"),
									c = r("./src/utils/attr-list.ts");

								function d(e, t) {
									var r = e.url;
									return void 0 !== r && 0 !== r.indexOf("data:") || (r = t.url), r
								}
								var f = function() {
									function e(e) {
										this.hls = void 0, this.loaders = Object.create(null), this.hls = e, this.registerListeners()
									}
									var t = e.prototype;
									return t.registerListeners = function() {
										var e = this.hls;
										e.on(i.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(i.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(i.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(i.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
									}, t.unregisterListeners = function() {
										var e = this.hls;
										e.off(i.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(i.Events.LEVEL_LOADING, this.onLevelLoading, this), e.off(i.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(i.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
									}, t.createInternalLoader = function(e) {
										var t = this.hls.config,
											r = t.pLoader,
											n = t.loader,
											i = new(r || n)(t);
										return e.loader = i, this.loaders[e.type] = i, i
									}, t.getInternalLoader = function(e) {
										return this.loaders[e.type]
									}, t.resetInternalLoader = function(e) {
										this.loaders[e] && delete this.loaders[e]
									}, t.destroyInternalLoaders = function() {
										for (var e in this.loaders) {
											var t = this.loaders[e];
											t && t.destroy(), this.resetInternalLoader(e)
										}
									}, t.destroy = function() {
										this.unregisterListeners(), this.destroyInternalLoaders()
									}, t.onManifestLoading = function(e, t) {
										var r = t.url;
										this.load({
											id: null,
											groupId: null,
											level: 0,
											responseType: "text",
											type: u.PlaylistContextType.MANIFEST,
											url: r,
											deliveryDirectives: null
										})
									}, t.onLevelLoading = function(e, t) {
										var r = t.id,
											n = t.level,
											i = t.url,
											s = t.deliveryDirectives;
										this.load({
											id: r,
											groupId: null,
											level: n,
											responseType: "text",
											type: u.PlaylistContextType.LEVEL,
											url: i,
											deliveryDirectives: s
										})
									}, t.onAudioTrackLoading = function(e, t) {
										var r = t.id,
											n = t.groupId,
											i = t.url,
											s = t.deliveryDirectives;
										this.load({
											id: r,
											groupId: n,
											level: null,
											responseType: "text",
											type: u.PlaylistContextType.AUDIO_TRACK,
											url: i,
											deliveryDirectives: s
										})
									}, t.onSubtitleTrackLoading = function(e, t) {
										var r = t.id,
											n = t.groupId,
											i = t.url,
											s = t.deliveryDirectives;
										this.load({
											id: r,
											groupId: n,
											level: null,
											responseType: "text",
											type: u.PlaylistContextType.SUBTITLE_TRACK,
											url: i,
											deliveryDirectives: s
										})
									}, t.load = function(e) {
										var t, r, n, i, s, o, l = this.hls.config,
											c = this.getInternalLoader(e);
										if (c) {
											var d = c.context;
											if (d && d.url === e.url) return void a.logger.trace("[playlist-loader]: playlist request ongoing");
											a.logger.log("[playlist-loader]: aborting previous loader for type: " + e.type), c.abort()
										}
										switch (e.type) {
											case u.PlaylistContextType.MANIFEST:
												r = l.manifestLoadingMaxRetry, n = l.manifestLoadingTimeOut, i = l.manifestLoadingRetryDelay, s = l.manifestLoadingMaxRetryTimeout;
												break;
											case u.PlaylistContextType.LEVEL:
											case u.PlaylistContextType.AUDIO_TRACK:
											case u.PlaylistContextType.SUBTITLE_TRACK:
												r = 0, n = l.levelLoadingTimeOut;
												break;
											default:
												r = l.levelLoadingMaxRetry, n = l.levelLoadingTimeOut, i = l.levelLoadingRetryDelay, s = l.levelLoadingMaxRetryTimeout
										}
										if (c = this.createInternalLoader(e), null !== (t = e.deliveryDirectives) && void 0 !== t && t.part && (e.type === u.PlaylistContextType.LEVEL && null !== e.level ? o = this.hls.levels[e.level].details : e.type === u.PlaylistContextType.AUDIO_TRACK && null !== e.id ? o = this.hls.audioTracks[e.id].details : e.type === u.PlaylistContextType.SUBTITLE_TRACK && null !== e.id && (o = this.hls.subtitleTracks[e.id].details), o)) {
											var f = o.partTarget,
												h = o.targetduration;
											f && h && (n = Math.min(1e3 * Math.max(3 * f, .8 * h), n))
										}
										var g = {
												timeout: n,
												maxRetry: r,
												retryDelay: i,
												maxRetryDelay: s,
												highWaterMark: 0
											},
											v = {
												onSuccess: this.loadsuccess.bind(this),
												onError: this.loaderror.bind(this),
												onTimeout: this.loadtimeout.bind(this)
											};
										c.load(e, g, v)
									}, t.loadsuccess = function(e, t, r, n) {
										if (void 0 === n && (n = null), r.isSidxRequest) return this.handleSidxRequest(e, r), void this.handlePlaylistLoaded(e, t, r, n);
										this.resetInternalLoader(r.type);
										var i = e.data;
										0 === i.indexOf("#EXTM3U") ? (t.parsing.start = performance.now(), i.indexOf("#EXTINF:") > 0 || i.indexOf("#EXT-X-TARGETDURATION:") > 0 ? this.handleTrackOrLevelPlaylist(e, t, r, n) : this.handleMasterPlaylist(e, t, r, n)) : this.handleManifestParsingError(e, r, "no EXTM3U delimiter", n)
									}, t.loaderror = function(e, t, r) {
										void 0 === r && (r = null), this.handleNetworkError(t, r, !1, e)
									}, t.loadtimeout = function(e, t, r) {
										void 0 === r && (r = null), this.handleNetworkError(t, r, !0)
									}, t.handleMasterPlaylist = function(e, t, r, n) {
										var s = this.hls,
											o = e.data,
											u = d(e, r),
											f = l.default.parseMasterPlaylist(o, u),
											h = f.levels,
											g = f.sessionData;
										if (h.length) {
											var v = h.map((function(e) {
													return {
														id: e.attrs.AUDIO,
														audioCodec: e.audioCodec
													}
												})),
												p = h.map((function(e) {
													return {
														id: e.attrs.SUBTITLES,
														textCodec: e.textCodec
													}
												})),
												m = l.default.parseMasterPlaylistMedia(o, u, "AUDIO", v),
												y = l.default.parseMasterPlaylistMedia(o, u, "SUBTITLES", p),
												b = l.default.parseMasterPlaylistMedia(o, u, "CLOSED-CAPTIONS");
											m.length && (m.some((function(e) {
												return !e.url
											})) || !h[0].audioCodec || h[0].attrs.AUDIO || (a.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), m.unshift({
												type: "main",
												name: "main",
												default: !1,
												autoselect: !1,
												forced: !1,
												id: -1,
												attrs: new c.AttrList({}),
												bitrate: 0,
												url: ""
											}))), s.trigger(i.Events.MANIFEST_LOADED, {
												levels: h,
												audioTracks: m,
												subtitles: y,
												captions: b,
												url: u,
												stats: t,
												networkDetails: n,
												sessionData: g
											})
										} else this.handleManifestParsingError(e, r, "no level found in manifest", n)
									}, t.handleTrackOrLevelPlaylist = function(e, t, r, a) {
										var o = this.hls,
											f = r.id,
											h = r.level,
											g = r.type,
											v = d(e, r),
											p = Object(n.isFiniteNumber)(f) ? f : 0,
											m = Object(n.isFiniteNumber)(h) ? h : p,
											y = function(e) {
												switch (e.type) {
													case u.PlaylistContextType.AUDIO_TRACK:
														return u.PlaylistLevelType.AUDIO;
													case u.PlaylistContextType.SUBTITLE_TRACK:
														return u.PlaylistLevelType.SUBTITLE;
													default:
														return u.PlaylistLevelType.MAIN
												}
											}(r),
											b = l.default.parseLevelPlaylist(e.data, v, m, y, p);
										if (b.fragments.length) {
											if (g === u.PlaylistContextType.MANIFEST) {
												var E = {
													attrs: new c.AttrList({}),
													bitrate: 0,
													details: b,
													name: "",
													url: v
												};
												o.trigger(i.Events.MANIFEST_LOADED, {
													levels: [E],
													audioTracks: [],
													url: v,
													stats: t,
													networkDetails: a,
													sessionData: null
												})
											}
											if (t.parsing.end = performance.now(), b.needSidxRanges) {
												var _, T = null === (_ = b.fragments[0].initSegment) || void 0 === _ ? void 0 : _.url;
												this.load({
													url: T,
													isSidxRequest: !0,
													type: g,
													level: h,
													levelDetails: b,
													id: f,
													groupId: null,
													rangeStart: 0,
													rangeEnd: 2048,
													responseType: "arraybuffer",
													deliveryDirectives: null
												})
											} else r.levelDetails = b, this.handlePlaylistLoaded(e, t, r, a)
										} else o.trigger(i.Events.ERROR, {
											type: s.ErrorTypes.NETWORK_ERROR,
											details: s.ErrorDetails.LEVEL_EMPTY_ERROR,
											fatal: !1,
											url: v,
											reason: "no fragments found in level",
											level: "number" == typeof r.level ? r.level : void 0
										})
									}, t.handleSidxRequest = function(e, t) {
										var r = Object(o.parseSegmentIndex)(new Uint8Array(e.data));
										if (r) {
											var n = r.references,
												i = t.levelDetails;
											n.forEach((function(e, t) {
												var n = e.info,
													s = i.fragments[t];
												0 === s.byteRange.length && s.setByteRange(String(1 + n.end - n.start) + "@" + String(n.start)), s.initSegment && s.initSegment.setByteRange(String(r.moovEndOffset) + "@0")
											}))
										}
									}, t.handleManifestParsingError = function(e, t, r, n) {
										this.hls.trigger(i.Events.ERROR, {
											type: s.ErrorTypes.NETWORK_ERROR,
											details: s.ErrorDetails.MANIFEST_PARSING_ERROR,
											fatal: t.type === u.PlaylistContextType.MANIFEST,
											url: e.url,
											reason: r,
											response: e,
											context: t,
											networkDetails: n
										})
									}, t.handleNetworkError = function(e, t, r, n) {
										void 0 === r && (r = !1), a.logger.warn("[playlist-loader]: A network " + (r ? "timeout" : "error") + " occurred while loading " + e.type + " level: " + e.level + " id: " + e.id + ' group-id: "' + e.groupId + '"');
										var o = s.ErrorDetails.UNKNOWN,
											l = !1,
											c = this.getInternalLoader(e);
										switch (e.type) {
											case u.PlaylistContextType.MANIFEST:
												o = r ? s.ErrorDetails.MANIFEST_LOAD_TIMEOUT : s.ErrorDetails.MANIFEST_LOAD_ERROR, l = !0;
												break;
											case u.PlaylistContextType.LEVEL:
												o = r ? s.ErrorDetails.LEVEL_LOAD_TIMEOUT : s.ErrorDetails.LEVEL_LOAD_ERROR, l = !1;
												break;
											case u.PlaylistContextType.AUDIO_TRACK:
												o = r ? s.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : s.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, l = !1;
												break;
											case u.PlaylistContextType.SUBTITLE_TRACK:
												o = r ? s.ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : s.ErrorDetails.SUBTITLE_LOAD_ERROR, l = !1
										}
										c && this.resetInternalLoader(e.type);
										var d = {
											type: s.ErrorTypes.NETWORK_ERROR,
											details: o,
											fatal: l,
											url: e.url,
											loader: c,
											context: e,
											networkDetails: t
										};
										n && (d.response = n), this.hls.trigger(i.Events.ERROR, d)
									}, t.handlePlaylistLoaded = function(e, t, r, n) {
										var s = r.type,
											a = r.level,
											o = r.id,
											l = r.groupId,
											c = r.loader,
											d = r.levelDetails,
											f = r.deliveryDirectives;
										if (null != d && d.targetduration) {
											if (c) switch (d.live && (c.getCacheAge && (d.ageHeader = c.getCacheAge() || 0), c.getCacheAge && !isNaN(d.ageHeader) || (d.ageHeader = 0)), s) {
												case u.PlaylistContextType.MANIFEST:
												case u.PlaylistContextType.LEVEL:
													this.hls.trigger(i.Events.LEVEL_LOADED, {
														details: d,
														level: a || 0,
														id: o || 0,
														stats: t,
														networkDetails: n,
														deliveryDirectives: f
													});
													break;
												case u.PlaylistContextType.AUDIO_TRACK:
													this.hls.trigger(i.Events.AUDIO_TRACK_LOADED, {
														details: d,
														id: o || 0,
														groupId: l || "",
														stats: t,
														networkDetails: n,
														deliveryDirectives: f
													});
													break;
												case u.PlaylistContextType.SUBTITLE_TRACK:
													this.hls.trigger(i.Events.SUBTITLE_TRACK_LOADED, {
														details: d,
														id: o || 0,
														groupId: l || "",
														stats: t,
														networkDetails: n,
														deliveryDirectives: f
													})
											}
										} else this.handleManifestParsingError(e, r, "invalid target duration", n)
									}, e
								}();
								t.default = f
							},
							"./src/polyfills/number.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "isFiniteNumber", (function() {
									return n
								})), r.d(t, "MAX_SAFE_INTEGER", (function() {
									return i
								}));
								var n = Number.isFinite || function(e) {
										return "number" == typeof e && isFinite(e)
									},
									i = Number.MAX_SAFE_INTEGER || 9007199254740991
							},
							"./src/remux/aac-helper.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = function() {
									function e() {}
									return e.getSilentFrame = function(e, t) {
										if ("mp4a.40.2" === e) {
											if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
											if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
											if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
											if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
											if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
											if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
										} else {
											if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
											if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
											if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
										}
									}, e
								}();
								t.default = n
							},
							"./src/remux/mp4-generator.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = Math.pow(2, 32) - 1,
									i = function() {
										function e() {}
										return e.init = function() {
											var t;
											for (t in e.types = {
												avc1: [],
												avcC: [],
												btrt: [],
												dinf: [],
												dref: [],
												esds: [],
												ftyp: [],
												hdlr: [],
												mdat: [],
												mdhd: [],
												mdia: [],
												mfhd: [],
												minf: [],
												moof: [],
												moov: [],
												mp4a: [],
												".mp3": [],
												mvex: [],
												mvhd: [],
												pasp: [],
												sdtp: [],
												stbl: [],
												stco: [],
												stsc: [],
												stsd: [],
												stsz: [],
												stts: [],
												tfdt: [],
												tfhd: [],
												traf: [],
												trak: [],
												trun: [],
												trex: [],
												tkhd: [],
												vmhd: [],
												smhd: []
											}, e.types) e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
											var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
												n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
											e.HDLR_TYPES = {
												video: r,
												audio: n
											};
											var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
												s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
											e.STTS = e.STSC = e.STCO = s, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
											var a = new Uint8Array([105, 115, 111, 109]),
												o = new Uint8Array([97, 118, 99, 49]),
												l = new Uint8Array([0, 0, 0, 1]);
											e.FTYP = e.box(e.types.ftyp, a, l, a, o), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, i))
										}, e.box = function(e) {
											for (var t = 8, r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
											for (var s = n.length, a = s; s--;) t += n[s].byteLength;
											var o = new Uint8Array(t);
											for (o[0] = t >> 24 & 255, o[1] = t >> 16 & 255, o[2] = t >> 8 & 255, o[3] = 255 & t, o.set(e, 4), s = 0, t = 8; s < a; s++) o.set(n[s], t), t += n[s].byteLength;
											return o
										}, e.hdlr = function(t) {
											return e.box(e.types.hdlr, e.HDLR_TYPES[t])
										}, e.mdat = function(t) {
											return e.box(e.types.mdat, t)
										}, e.mdhd = function(t, r) {
											r *= t;
											var i = Math.floor(r / (n + 1)),
												s = Math.floor(r % (n + 1));
											return e.box(e.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, 85, 196, 0, 0]))
										}, e.mdia = function(t) {
											return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t))
										}, e.mfhd = function(t) {
											return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
										}, e.minf = function(t) {
											return "audio" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t))
										}, e.moof = function(t, r, n) {
											return e.box(e.types.moof, e.mfhd(t), e.traf(n, r))
										}, e.moov = function(t) {
											for (var r = t.length, n = []; r--;) n[r] = e.trak(t[r]);
											return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(n)
												.concat(e.mvex(t)))
										}, e.mvex = function(t) {
											for (var r = t.length, n = []; r--;) n[r] = e.trex(t[r]);
											return e.box.apply(null, [e.types.mvex].concat(n))
										}, e.mvhd = function(t, r) {
											r *= t;
											var i = Math.floor(r / (n + 1)),
												s = Math.floor(r % (n + 1)),
												a = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
											return e.box(e.types.mvhd, a)
										}, e.sdtp = function(t) {
											var r, n, i = t.samples || [],
												s = new Uint8Array(4 + i.length);
											for (r = 0; r < i.length; r++) n = i[r].flags, s[r + 4] = n.dependsOn << 4 | n.isDependedOn << 2 | n.hasRedundancy;
											return e.box(e.types.sdtp, s)
										}, e.stbl = function(t) {
											return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO))
										}, e.avc1 = function(t) {
											var r, n, i, s = [],
												a = [];
											for (r = 0; r < t.sps.length; r++) i = (n = t.sps[r])
												.byteLength, s.push(i >>> 8 & 255), s.push(255 & i), s = s.concat(Array.prototype.slice.call(n));
											for (r = 0; r < t.pps.length; r++) i = (n = t.pps[r])
												.byteLength, a.push(i >>> 8 & 255), a.push(255 & i), a = a.concat(Array.prototype.slice.call(n));
											var o = e.box(e.types.avcC, new Uint8Array([1, s[3], s[4], s[5], 255, 224 | t.sps.length].concat(s)
													.concat([t.pps.length])
													.concat(a))),
												l = t.width,
												u = t.height,
												c = t.pixelRatio[0],
												d = t.pixelRatio[1];
											return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e.box(e.types.pasp, new Uint8Array([c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c, d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d])))
										}, e.esds = function(e) {
											var t = e.config.length;
											return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t])
												.concat(e.config)
												.concat([6, 1, 2]))
										}, e.mp4a = function(t) {
											var r = t.samplerate;
											return e.box(e.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), e.box(e.types.esds, e.esds(t)))
										}, e.mp3 = function(t) {
											var r = t.samplerate;
											return e.box(e.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]))
										}, e.stsd = function(t) {
											return "audio" === t.type ? t.isAAC || "mp3" !== t.codec ? e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.mp3(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t))
										}, e.tkhd = function(t) {
											var r = t.id,
												i = t.duration * t.timescale,
												s = t.width,
												a = t.height,
												o = Math.floor(i / (n + 1)),
												l = Math.floor(i % (n + 1));
											return e.box(e.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, l >> 24, l >> 16 & 255, l >> 8 & 255, 255 & l, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, s >> 8 & 255, 255 & s, 0, 0, a >> 8 & 255, 255 & a, 0, 0]))
										}, e.traf = function(t, r) {
											var i = e.sdtp(t),
												s = t.id,
												a = Math.floor(r / (n + 1)),
												o = Math.floor(r % (n + 1));
											return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), e.box(e.types.tfdt, new Uint8Array([1, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o])), e.trun(t, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
										}, e.trak = function(t) {
											return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t))
										}, e.trex = function(t) {
											var r = t.id;
											return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
										}, e.trun = function(t, r) {
											var n, i, s, a, o, l, u = t.samples || [],
												c = u.length,
												d = 12 + 16 * c,
												f = new Uint8Array(d);
											for (r += 8 + d, f.set([0, 0, 15, 1, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, 255 & c, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), n = 0; n < c; n++) s = (i = u[n])
												.duration, a = i.size, o = i.flags, l = i.cts, f.set([s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * n);
											return e.box(e.types.trun, f)
										}, e.initSegment = function(t) {
											e.types || e.init();
											var r = e.moov(t),
												n = new Uint8Array(e.FTYP.byteLength + r.byteLength);
											return n.set(e.FTYP), n.set(r, e.FTYP.byteLength), n
										}, e
									}();
								i.types = void 0, i.HDLR_TYPES = void 0, i.STTS = void 0, i.STSC = void 0, i.STCO = void 0, i.STSZ = void 0, i.VMHD = void 0, i.SMHD = void 0, i.STSD = void 0, i.FTYP = void 0, i.DINF = void 0, t.default = i
							},
							"./src/remux/mp4-remuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return v
								})), r.d(t, "normalizePts", (function() {
									return p
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/remux/aac-helper.ts"),
									s = r("./src/remux/mp4-generator.ts"),
									a = r("./src/events.ts"),
									o = r("./src/errors.ts"),
									l = r("./src/utils/logger.ts"),
									u = r("./src/types/loader.ts"),
									c = r("./src/utils/timescale-conversion.ts");

								function d() {
									return d = Object.assign || function(e) {
										for (var t = 1; t < arguments.length; t++) {
											var r = arguments[t];
											for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
										}
										return e
									}, d.apply(this, arguments)
								}
								var f = null,
									h = null,
									g = !1,
									v = function() {
										function e(e, t, r, n) {
											if (void 0 === n && (n = ""), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, null === f) {
												var i = (navigator.userAgent || "")
													.match(/Chrome\/(\d+)/i);
												f = i ? parseInt(i[1]) : 0
											}
											if (null === h) {
												var s = navigator.userAgent.match(/Safari\/(\d+)/i);
												h = s ? parseInt(s[1]) : 0
											}
											g = !!f && f < 75 || !!h && h < 600
										}
										var t = e.prototype;
										return t.destroy = function() {}, t.resetTimeStamp = function(e) {
											l.logger.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e
										}, t.resetNextTimestamp = function() {
											l.logger.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
										}, t.resetInitSegment = function() {
											l.logger.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
										}, t.getVideoStartPts = function(e) {
											var t = !1,
												r = e.reduce((function(e, r) {
													var n = r.pts - e;
													return n < -4294967296 ? (t = !0, p(e, r.pts)) : n > 0 ? e : r.pts
												}), e[0].pts);
											return t && l.logger.debug("PTS rollover detected"), r
										}, t.remux = function(e, t, r, n, i, s, a, o) {
											var c, d, f, h, g, v, m = i,
												y = i,
												b = e.pid > -1,
												E = t.pid > -1,
												_ = t.samples.length,
												T = e.samples.length > 0,
												S = _ > 1;
											if ((!b || T) && (!E || S) || this.ISGenerated || a) {
												this.ISGenerated || (f = this.generateIS(e, t, i));
												var A = this.isVideoContiguous,
													L = -1;
												if (S && (L = function(e) {
													for (var t = 0; t < e.length; t++)
														if (e[t].key) return t;
													return -1
												}(t.samples), !A && this.config.forceKeyFrameOnDiscontinuity))
													if (v = !0, L > 0) {
														l.logger.warn("[mp4-remuxer]: Dropped " + L + " out of " + _ + " video samples due to a missing keyframe");
														var w = this.getVideoStartPts(t.samples);
														t.samples = t.samples.slice(L), t.dropped += L, y += (t.samples[0].pts - w) / (t.timescale || 9e4)
													} else -1 === L && (l.logger.warn("[mp4-remuxer]: No keyframe found out of " + _ + " video samples"), v = !1);
												if (this.ISGenerated) {
													if (T && S) {
														var k = this.getVideoStartPts(t.samples),
															C = (p(e.samples[0].pts, k) - k) / t.inputTimeScale;
														m += Math.max(0, C), y += Math.max(0, -C)
													}
													if (T) {
														if (e.samplerate || (l.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), f = this.generateIS(e, t, i)), d = this.remuxAudio(e, m, this.isAudioContiguous, s, E || S || o === u.PlaylistLevelType.AUDIO ? y : void 0), S) {
															var P = d ? d.endPTS - d.startPTS : 0;
															t.inputTimeScale || (l.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), f = this.generateIS(e, t, i)), c = this.remuxVideo(t, y, A, P)
														}
													} else S && (c = this.remuxVideo(t, y, A, 0));
													c && (c.firstKeyFrame = L, c.independent = -1 !== L)
												}
											}
											return this.ISGenerated && (r.samples.length && (g = this.remuxID3(r, i)), n.samples.length && (h = this.remuxText(n, i))), {
												audio: d,
												video: c,
												initSegment: f,
												independent: v,
												text: h,
												id3: g
											}
										}, t.generateIS = function(e, t, r) {
											var i, a, o, l = e.samples,
												u = t.samples,
												c = this.typeSupported,
												d = {},
												f = !Object(n.isFiniteNumber)(this._initPTS),
												h = "audio/mp4";
											if (f && (i = a = 1 / 0), e.config && l.length && (e.timescale = e.samplerate, e.isAAC || (c.mpeg ? (h = "audio/mpeg", e.codec = "") : c.mp3 && (e.codec = "mp3")), d.audio = {
												id: "audio",
												container: h,
												codec: e.codec,
												initSegment: !e.isAAC && c.mpeg ? new Uint8Array(0) : s.default.initSegment([e]),
												metadata: {
													channelCount: e.channelCount
												}
											}, f && (o = e.inputTimeScale, i = a = l[0].pts - Math.round(o * r))), t.sps && t.pps && u.length && (t.timescale = t.inputTimeScale, d.video = {
												id: "main",
												container: "video/mp4",
												codec: t.codec,
												initSegment: s.default.initSegment([t]),
												metadata: {
													width: t.width,
													height: t.height
												}
											}, f)) {
												o = t.inputTimeScale;
												var g = this.getVideoStartPts(u),
													v = Math.round(o * r);
												a = Math.min(a, p(u[0].dts, g) - v), i = Math.min(i, g - v)
											}
											if (Object.keys(d)
												.length) return this.ISGenerated = !0, f && (this._initPTS = i, this._initDTS = a), {
												tracks: d,
												initPTS: i,
												timescale: o
											}
										}, t.remuxVideo = function(e, t, r, n) {
											var i, u, h, v = e.inputTimeScale,
												y = e.samples,
												b = [],
												E = y.length,
												_ = this._initPTS,
												T = this.nextAvcDts,
												S = 8,
												A = Number.POSITIVE_INFINITY,
												L = Number.NEGATIVE_INFINITY,
												w = 0,
												k = !1;
											r && null !== T || (T = t * v - (y[0].pts - p(y[0].dts, y[0].pts)));
											for (var C = 0; C < E; C++) {
												var P = y[C];
												P.pts = p(P.pts - _, T), P.dts = p(P.dts - _, T), P.dts > P.pts && (w = Math.max(Math.min(w, P.pts - P.dts), -18e3)), P.dts < y[C > 0 ? C - 1 : C].dts && (k = !0)
											}
											k && y.sort((function(e, t) {
												var r = e.dts - t.dts,
													n = e.pts - t.pts;
												return r || n
											})), u = y[0].dts, h = y[y.length - 1].dts;
											var D = Math.round((h - u) / (E - 1));
											if (w < 0) {
												if (w < -2 * D) {
													l.logger.warn("PTS < DTS detected in video samples, offsetting DTS from PTS by " + Object(c.toMsFromMpegTsClock)(-D, !0) + " ms");
													for (var R = w, I = 0; I < E; I++) y[I].dts = R = Math.max(R, y[I].pts - D), y[I].pts = Math.max(R, y[I].pts)
												} else {
													l.logger.warn("PTS < DTS detected in video samples, shifting DTS by " + Object(c.toMsFromMpegTsClock)(w, !0) + " ms to overcome this issue");
													for (var O = 0; O < E; O++) y[O].dts = y[O].dts + w
												}
												u = y[0].dts
											}
											if (r) {
												var x = u - T,
													M = x > D;
												if (M || x < -1) {
													M ? l.logger.warn("AVC: " + Object(c.toMsFromMpegTsClock)(x, !0) + " ms (" + x + "dts) hole between fragments detected, filling it") : l.logger.warn("AVC: " + Object(c.toMsFromMpegTsClock)(-x, !0) + " ms (" + x + "dts) overlapping between fragments detected"), u = T;
													var F = y[0].pts - x;
													y[0].dts = u, y[0].pts = F, l.logger.log("Video: First PTS/DTS adjusted: " + Object(c.toMsFromMpegTsClock)(F, !0) + "/" + Object(c.toMsFromMpegTsClock)(u, !0) + ", delta: " + Object(c.toMsFromMpegTsClock)(x, !0) + " ms")
												}
											}
											g && (u = Math.max(0, u));
											for (var N = 0, B = 0, U = 0; U < E; U++) {
												for (var j = y[U], G = j.units, H = G.length, K = 0, q = 0; q < H; q++) K += G[q].data.length;
												B += K, N += H, j.length = K, j.dts = Math.max(j.dts, u), j.pts = Math.max(j.pts, j.dts, 0), A = Math.min(j.pts, A), L = Math.max(j.pts, L)
											}
											h = y[E - 1].dts;
											var V, W = B + 4 * N + 8;
											try {
												V = new Uint8Array(W)
											} catch (e) {
												return void this.observer.emit(a.Events.ERROR, a.Events.ERROR, {
													type: o.ErrorTypes.MUX_ERROR,
													details: o.ErrorDetails.REMUX_ALLOC_ERROR,
													fatal: !1,
													bytes: W,
													reason: "fail allocating video mdat " + W
												})
											}
											var z = new DataView(V.buffer);
											z.setUint32(0, W), V.set(s.default.types.mdat, 4);
											for (var Y = 0; Y < E; Y++) {
												for (var X = y[Y], J = X.units, Q = 0, Z = 0, $ = J.length; Z < $; Z++) {
													var ee = J[Z],
														te = ee.data,
														re = ee.data.byteLength;
													z.setUint32(S, re), S += 4, V.set(te, S), S += re, Q += 4 + re
												}
												if (Y < E - 1) i = y[Y + 1].dts - X.dts;
												else {
													var ne = this.config,
														ie = X.dts - y[Y > 0 ? Y - 1 : Y].dts;
													if (ne.stretchShortVideoTrack && null !== this.nextAudioPts) {
														var se = Math.floor(ne.maxBufferHole * v),
															ae = (n ? A + n * v : this.nextAudioPts) - X.pts;
														ae > se ? ((i = ae - ie) < 0 && (i = ie), l.logger.log("[mp4-remuxer]: It is approximately " + ae / 90 + " ms to the next segment; using duration " + i / 90 + " ms for the last video frame.")) : i = ie
													} else i = ie
												}
												var oe = Math.round(X.pts - X.dts);
												b.push(new m(X.key, i, Q, oe))
											}
											if (b.length && f && f < 70) {
												var le = b[0].flags;
												le.dependsOn = 2, le.isNonSync = 0
											}
											console.assert(void 0 !== i, "mp4SampleDuration must be computed"), this.nextAvcDts = T = h + i, this.isVideoContiguous = !0;
											var ue = {
												data1: s.default.moof(e.sequenceNumber++, u, d({}, e, {
													samples: b
												})),
												data2: V,
												startPTS: A / v,
												endPTS: (L + i) / v,
												startDTS: u / v,
												endDTS: T / v,
												type: "video",
												hasAudio: !1,
												hasVideo: !0,
												nb: b.length,
												dropped: e.dropped
											};
											return e.samples = [], e.dropped = 0, console.assert(V.length, "MDAT length must not be zero"), ue
										}, t.remuxAudio = function(e, t, r, n, u) {
											var c = e.inputTimeScale,
												f = c / (e.samplerate ? e.samplerate : c),
												h = e.isAAC ? 1024 : 1152,
												g = h * f,
												v = this._initPTS,
												y = !e.isAAC && this.typeSupported.mpeg,
												b = [],
												E = e.samples,
												_ = y ? 0 : 8,
												T = this.nextAudioPts || -1,
												S = t * c;
											if (this.isAudioContiguous = r = r || E.length && T > 0 && (n && Math.abs(S - T) < 9e3 || Math.abs(p(E[0].pts - v, S) - T) < 20 * g), E.forEach((function(e) {
												e.pts = p(e.pts - v, S)
											})), !r || T < 0) {
												if (E = E.filter((function(e) {
													return e.pts >= 0
												})), !E.length) return;
												T = 0 === u ? 0 : n ? Math.max(0, S) : E[0].pts
											}
											if (e.isAAC)
												for (var A = void 0 !== u, L = this.config.maxAudioFramesDrift, w = 0, k = T; w < E.length; w++) {
													var C = E[w],
														P = C.pts,
														D = P - k,
														R = Math.abs(1e3 * D / c);
													if (D <= -L * g && A) 0 === w && (l.logger.warn("Audio frame @ " + (P / c)
														.toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * D / c) + " ms."), this.nextAudioPts = T = k = P);
													else if (D >= L * g && R < 1e4 && A) {
														var I = Math.round(D / g);
														(k = P - I * g) < 0 && (I--, k += g), 0 === w && (this.nextAudioPts = T = k), l.logger.warn("[mp4-remuxer]: Injecting " + I + " audio frame @ " + (k / c)
															.toFixed(3) + "s due to " + Math.round(1e3 * D / c) + " ms gap.");
														for (var O = 0; O < I; O++) {
															var x = Math.max(k, 0),
																M = i.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
															M || (l.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), M = C.unit.subarray()), E.splice(w, 0, {
																unit: M,
																pts: x
															}), k += g, w++
														}
													}
													C.pts = k, k += g
												}
											for (var F, N = null, B = null, U = 0, j = E.length; j--;) U += E[j].unit.byteLength;
											for (var G = 0, H = E.length; G < H; G++) {
												var K = E[G],
													q = K.unit,
													V = K.pts;
												if (null !== B) b[G - 1].duration = Math.round((V - B) / f);
												else {
													if (r && e.isAAC && (V = T), N = V, !(U > 0)) return;
													U += _;
													try {
														F = new Uint8Array(U)
													} catch (e) {
														return void this.observer.emit(a.Events.ERROR, a.Events.ERROR, {
															type: o.ErrorTypes.MUX_ERROR,
															details: o.ErrorDetails.REMUX_ALLOC_ERROR,
															fatal: !1,
															bytes: U,
															reason: "fail allocating audio mdat " + U
														})
													}
													y || (new DataView(F.buffer)
														.setUint32(0, U), F.set(s.default.types.mdat, 4))
												}
												F.set(q, _);
												var W = q.byteLength;
												_ += W, b.push(new m(!0, h, W, 0)), B = V
											}
											var z = b.length;
											if (z) {
												var Y = b[b.length - 1];
												this.nextAudioPts = T = B + f * Y.duration;
												var X = y ? new Uint8Array(0) : s.default.moof(e.sequenceNumber++, N / f, d({}, e, {
													samples: b
												}));
												e.samples = [];
												var J = N / c,
													Q = T / c,
													Z = {
														data1: X,
														data2: F,
														startPTS: J,
														endPTS: Q,
														startDTS: J,
														endDTS: Q,
														type: "audio",
														hasAudio: !0,
														hasVideo: !1,
														nb: z
													};
												return this.isAudioContiguous = !0, console.assert(F.length, "MDAT length must not be zero"), Z
											}
										}, t.remuxEmptyAudio = function(e, t, r, n) {
											var s = e.inputTimeScale,
												a = s / (e.samplerate ? e.samplerate : s),
												o = this.nextAudioPts,
												u = (null !== o ? o : n.startDTS * s) + this._initDTS,
												c = n.endDTS * s + this._initDTS,
												d = 1024 * a,
												f = Math.ceil((c - u) / d),
												h = i.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
											if (l.logger.warn("[mp4-remuxer]: remux empty Audio"), h) {
												for (var g = [], v = 0; v < f; v++) {
													var p = u + v * d;
													g.push({
														unit: h,
														pts: p,
														dts: p
													})
												}
												return e.samples = g, this.remuxAudio(e, t, r, !1)
											}
											l.logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec")
										}, t.remuxID3 = function(e, t) {
											var r = e.samples.length;
											if (r) {
												for (var n = e.inputTimeScale, i = this._initPTS, s = this._initDTS, a = 0; a < r; a++) {
													var o = e.samples[a];
													o.pts = p(o.pts - i, t * n) / n, o.dts = p(o.dts - s, t * n) / n
												}
												var l = e.samples;
												return e.samples = [], {
													samples: l
												}
											}
										}, t.remuxText = function(e, t) {
											var r = e.samples.length;
											if (r) {
												for (var n = e.inputTimeScale, i = this._initPTS, s = 0; s < r; s++) {
													var a = e.samples[s];
													a.pts = p(a.pts - i, t * n) / n
												}
												e.samples.sort((function(e, t) {
													return e.pts - t.pts
												}));
												var o = e.samples;
												return e.samples = [], {
													samples: o
												}
											}
										}, e
									}();

								function p(e, t) {
									var r;
									if (null === t) return e;
									for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += r;
									return e
								}
								var m = function(e, t, r, n) {
										this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = r, this.cts = n, this.flags = new y(e)
									},
									y = function(e) {
										this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e ? 2 : 1, this.isNonSync = e ? 0 : 1
									}
							},
							"./src/remux/passthrough-remuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/utils/mp4-tools.ts"),
									s = r("./src/loader/fragment.ts"),
									a = r("./src/utils/logger.ts"),
									o = function() {
										function e() {
											this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndDTS = null
										}
										var t = e.prototype;
										return t.destroy = function() {}, t.resetTimeStamp = function(e) {
											this.initPTS = e, this.lastEndDTS = null
										}, t.resetNextTimestamp = function() {
											this.lastEndDTS = null
										}, t.resetInitSegment = function(e, t, r) {
											this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(e), this.emitInitSegment = !0
										}, t.generateInitSegment = function(e) {
											var t = this.audioCodec,
												r = this.videoCodec;
											if (!e || !e.byteLength) return this.initTracks = void 0, void(this.initData = void 0);
											var n = this.initData = Object(i.parseInitSegment)(e);
											t || (t = u(n.audio, s.ElementaryStreamTypes.AUDIO)), r || (r = u(n.video, s.ElementaryStreamTypes.VIDEO));
											var o = {};
											n.audio && n.video ? o.audiovideo = {
												container: "video/mp4",
												codec: t + "," + r,
												initSegment: e,
												id: "main"
											} : n.audio ? o.audio = {
												container: "audio/mp4",
												codec: t,
												initSegment: e,
												id: "audio"
											} : n.video ? o.video = {
												container: "video/mp4",
												codec: r,
												initSegment: e,
												id: "main"
											} : a.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = o
										}, t.remux = function(e, t, r, s, o) {
											var u = this.initPTS,
												c = this.lastEndDTS,
												d = {
													audio: void 0,
													video: void 0,
													text: s,
													id3: r,
													initSegment: void 0
												};
											Object(n.isFiniteNumber)(c) || (c = this.lastEndDTS = o || 0);
											var f = t.samples;
											if (!f || !f.length) return d;
											var h = {
													initPTS: void 0,
													timescale: 1
												},
												g = this.initData;
											if (g && g.length || (this.generateInitSegment(f), g = this.initData), !g || !g.length) return a.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), d;
											this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1), Object(n.isFiniteNumber)(u) || (this.initPTS = h.initPTS = u = l(g, f, c));
											var v = Object(i.getDuration)(f, g),
												p = c,
												m = v + p;
											Object(i.offsetStartDTS)(g, f, u), v > 0 ? this.lastEndDTS = m : (a.logger.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
											var y = !!g.audio,
												b = !!g.video,
												E = "";
											y && (E += "audio"), b && (E += "video");
											var _ = {
												data1: f,
												startPTS: p,
												startDTS: p,
												endPTS: m,
												endDTS: m,
												type: E,
												hasAudio: y,
												hasVideo: b,
												nb: 1,
												dropped: 0
											};
											return d.audio = "audio" === _.type ? _ : void 0, d.video = "audio" !== _.type ? _ : void 0, d.text = s, d.id3 = r, d.initSegment = h, d
										}, e
									}(),
									l = function(e, t, r) {
										return Object(i.getStartDTS)(e, t) - r
									};

								function u(e, t) {
									var r = null == e ? void 0 : e.codec;
									return r && r.length > 4 ? r : "hvc1" === r ? "hvc1.1.c.L120.90" : "av01" === r ? "av01.0.04M.08" : "avc1" === r || t === s.ElementaryStreamTypes.VIDEO ? "avc1.42e01e" : "mp4a.40.5"
								}
								t.default = o
							},
							"./src/task-loop.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return n
								}));
								var n = function() {
									function e() {
										this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
									}
									var t = e.prototype;
									return t.destroy = function() {
										this.onHandlerDestroying(), this.onHandlerDestroyed()
									}, t.onHandlerDestroying = function() {
										this.clearNextTick(), this.clearInterval()
									}, t.onHandlerDestroyed = function() {}, t.hasInterval = function() {
										return !!this._tickInterval
									}, t.hasNextTick = function() {
										return !!this._tickTimer
									}, t.setInterval = function(e) {
										return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, e), !0)
									}, t.clearInterval = function() {
										return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
									}, t.clearNextTick = function() {
										return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
									}, t.tick = function() {
										this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
									}, t.tickImmediate = function() {
										this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
									}, t.doTick = function() {}, e
								}()
							},
							"./src/types/cmcd.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "CMCDVersion", (function() {
									return a
								})), r.d(t, "CMCDObjectType", (function() {
									return n
								})), r.d(t, "CMCDStreamingFormat", (function() {
									return i
								})), r.d(t, "CMCDStreamType", (function() {
									return s
								}));
								var n, i, s, a = 1;
								! function(e) {
									e.MANIFEST = "m", e.AUDIO = "a", e.VIDEO = "v", e.MUXED = "av", e.INIT = "i", e.CAPTION = "c", e.TIMED_TEXT = "tt", e.KEY = "k", e.OTHER = "o"
								}(n || (n = {})),
								function(e) {
									e.DASH = "d", e.HLS = "h", e.SMOOTH = "s", e.OTHER = "o"
								}(i || (i = {})),
								function(e) {
									e.VOD = "v", e.LIVE = "l"
								}(s || (s = {}))
							},
							"./src/types/level.ts": function(e, t, r) {
								"use strict";

								function n(e, t) {
									for (var r = 0; r < t.length; r++) {
										var n = t[r];
										n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
									}
								}
								var i;

								function s(e, t) {
									var r = e.canSkipUntil,
										n = e.canSkipDateRanges,
										s = e.endSN;
									return r && (void 0 !== t ? t - s : 0) < r ? n ? i.v2 : i.Yes : i.No
								}
								r.r(t), r.d(t, "HlsSkip", (function() {
										return i
									})), r.d(t, "getSkipValue", (function() {
										return s
									})), r.d(t, "HlsUrlParameters", (function() {
										return a
									})), r.d(t, "Level", (function() {
										return o
									})),
									function(e) {
										e.No = "", e.Yes = "YES", e.v2 = "v2"
									}(i || (i = {}));
								var a = function() {
										function e(e, t, r) {
											this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r
										}
										return e.prototype.addDirectives = function(e) {
											var t = new self.URL(e);
											return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.toString()
										}, e
									}(),
									o = function() {
										function e(e) {
											this.attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e.url], this.attrs = e.attrs, this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.unknownCodecs = e.unknownCodecs, this.codecSet = [e.videoCodec, e.audioCodec].filter((function(e) {
													return e
												}))
												.join(",")
												.replace(/\.[^.,]+/g, "")
										}
										var t, r, i;
										return t = e, (r = [{
											key: "maxBitrate",
											get: function() {
												return Math.max(this.realBitrate, this.bitrate)
											}
										}, {
											key: "uri",
											get: function() {
												return this.url[this._urlId] || ""
											}
										}, {
											key: "urlId",
											get: function() {
												return this._urlId
											},
											set: function(e) {
												var t = e % this.url.length;
												this._urlId !== t && (this.details = void 0, this._urlId = t)
											}
										}]) && n(t.prototype, r), i && n(t, i), e
									}()
							},
							"./src/types/loader.ts": function(e, t, r) {
								"use strict";
								var n, i;
								r.r(t), r.d(t, "PlaylistContextType", (function() {
										return n
									})), r.d(t, "PlaylistLevelType", (function() {
										return i
									})),
									function(e) {
										e.MANIFEST = "manifest", e.LEVEL = "level", e.AUDIO_TRACK = "audioTrack", e.SUBTITLE_TRACK = "subtitleTrack"
									}(n || (n = {})),
									function(e) {
										e.MAIN = "main", e.AUDIO = "audio", e.SUBTITLE = "subtitle"
									}(i || (i = {}))
							},
							"./src/types/transmuxer.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "ChunkMetadata", (function() {
									return n
								}));
								var n = function(e, t, r, n, i, s) {
									void 0 === n && (n = 0), void 0 === i && (i = -1), void 0 === s && (s = !1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
										start: 0,
										executeStart: 0,
										executeEnd: 0,
										end: 0
									}, this.buffering = {
										audio: {
											start: 0,
											executeStart: 0,
											executeEnd: 0,
											end: 0
										},
										video: {
											start: 0,
											executeStart: 0,
											executeEnd: 0,
											end: 0
										},
										audiovideo: {
											start: 0,
											executeStart: 0,
											executeEnd: 0,
											end: 0
										}
									}, this.level = e, this.sn = t, this.id = r, this.size = n, this.part = i, this.partial = s
								}
							},
							"./src/utils/attr-list.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "AttrList", (function() {
									return s
								}));
								var n = /^(\d+)x(\d+)$/,
									i = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,
									s = function() {
										function e(t) {
											for (var r in "string" == typeof t && (t = e.parseAttrList(t)), t) t.hasOwnProperty(r) && (this[r] = t[r])
										}
										var t = e.prototype;
										return t.decimalInteger = function(e) {
											var t = parseInt(this[e], 10);
											return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
										}, t.hexadecimalInteger = function(e) {
											if (this[e]) {
												var t = (this[e] || "0x")
													.slice(2);
												t = (1 & t.length ? "0" : "") + t;
												for (var r = new Uint8Array(t.length / 2), n = 0; n < t.length / 2; n++) r[n] = parseInt(t.slice(2 * n, 2 * n + 2), 16);
												return r
											}
											return null
										}, t.hexadecimalIntegerAsNumber = function(e) {
											var t = parseInt(this[e], 16);
											return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
										}, t.decimalFloatingPoint = function(e) {
											return parseFloat(this[e])
										}, t.optionalFloat = function(e, t) {
											var r = this[e];
											return r ? parseFloat(r) : t
										}, t.enumeratedString = function(e) {
											return this[e]
										}, t.bool = function(e) {
											return "YES" === this[e]
										}, t.decimalResolution = function(e) {
											var t = n.exec(this[e]);
											if (null !== t) return {
												width: parseInt(t[1], 10),
												height: parseInt(t[2], 10)
											}
										}, e.parseAttrList = function(e) {
											var t, r = {};
											for (i.lastIndex = 0; null !== (t = i.exec(e));) {
												var n = t[2];
												0 === n.indexOf('"') && n.lastIndexOf('"') === n.length - 1 && (n = n.slice(1, -1)), r[t[1]] = n
											}
											return r
										}, e
									}()
							},
							"./src/utils/binary-search.ts": function(e, t, r) {
								"use strict";
								r.r(t), t.default = {
									search: function(e, t) {
										for (var r = 0, n = e.length - 1, i = null, s = null; r <= n;) {
											var a = t(s = e[i = (r + n) / 2 | 0]);
											if (a > 0) r = i + 1;
											else {
												if (!(a < 0)) return s;
												n = i - 1
											}
										}
										return null
									}
								}
							},
							"./src/utils/buffer-helper.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "BufferHelper", (function() {
									return s
								}));
								var n = r("./src/utils/logger.ts"),
									i = {
										length: 0,
										start: function() {
											return 0
										},
										end: function() {
											return 0
										}
									},
									s = function() {
										function e() {}
										return e.isBuffered = function(t, r) {
											try {
												if (t)
													for (var n = e.getBuffered(t), i = 0; i < n.length; i++)
														if (r >= n.start(i) && r <= n.end(i)) return !0
											} catch (e) {}
											return !1
										}, e.bufferInfo = function(t, r, n) {
											try {
												if (t) {
													var i, s = e.getBuffered(t),
														a = [];
													for (i = 0; i < s.length; i++) a.push({
														start: s.start(i),
														end: s.end(i)
													});
													return this.bufferedInfo(a, r, n)
												}
											} catch (e) {}
											return {
												len: 0,
												start: r,
												end: r,
												nextStart: void 0
											}
										}, e.bufferedInfo = function(e, t, r) {
											t = Math.max(0, t), e.sort((function(e, t) {
												var r = e.start - t.start;
												return r || t.end - e.end
											}));
											var n = [];
											if (r)
												for (var i = 0; i < e.length; i++) {
													var s = n.length;
													if (s) {
														var a = n[s - 1].end;
														e[i].start - a < r ? e[i].end > a && (n[s - 1].end = e[i].end) : n.push(e[i])
													} else n.push(e[i])
												} else n = e;
											for (var o, l = 0, u = t, c = t, d = 0; d < n.length; d++) {
												var f = n[d].start,
													h = n[d].end;
												if (t + r >= f && t < h) u = f, l = (c = h) - t;
												else if (t + r < f) {
													o = f;
													break
												}
											}
											return {
												len: l,
												start: u || 0,
												end: c || 0,
												nextStart: o
											}
										}, e.getBuffered = function(e) {
											try {
												return e.buffered
											} catch (e) {
												return n.logger.log("failed to get media.buffered", e), i
											}
										}, e
									}()
							},
							"./src/utils/cea-608-parser.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "Row", (function() {
									return y
								})), r.d(t, "CaptionScreen", (function() {
									return b
								}));
								var n, i = r("./src/utils/logger.ts"),
									s = {
										42: 225,
										92: 233,
										94: 237,
										95: 243,
										96: 250,
										123: 231,
										124: 247,
										125: 209,
										126: 241,
										127: 9608,
										128: 174,
										129: 176,
										130: 189,
										131: 191,
										132: 8482,
										133: 162,
										134: 163,
										135: 9834,
										136: 224,
										137: 32,
										138: 232,
										139: 226,
										140: 234,
										141: 238,
										142: 244,
										143: 251,
										144: 193,
										145: 201,
										146: 211,
										147: 218,
										148: 220,
										149: 252,
										150: 8216,
										151: 161,
										152: 42,
										153: 8217,
										154: 9473,
										155: 169,
										156: 8480,
										157: 8226,
										158: 8220,
										159: 8221,
										160: 192,
										161: 194,
										162: 199,
										163: 200,
										164: 202,
										165: 203,
										166: 235,
										167: 206,
										168: 207,
										169: 239,
										170: 212,
										171: 217,
										172: 249,
										173: 219,
										174: 171,
										175: 187,
										176: 195,
										177: 227,
										178: 205,
										179: 204,
										180: 236,
										181: 210,
										182: 242,
										183: 213,
										184: 245,
										185: 123,
										186: 125,
										187: 92,
										188: 94,
										189: 95,
										190: 124,
										191: 8764,
										192: 196,
										193: 228,
										194: 214,
										195: 246,
										196: 223,
										197: 165,
										198: 164,
										199: 9475,
										200: 197,
										201: 229,
										202: 216,
										203: 248,
										204: 9487,
										205: 9491,
										206: 9495,
										207: 9499
									},
									a = function(e) {
										var t = e;
										return s.hasOwnProperty(e) && (t = s[e]), String.fromCharCode(t)
									},
									o = 15,
									l = 100,
									u = {
										17: 1,
										18: 3,
										21: 5,
										22: 7,
										23: 9,
										16: 11,
										19: 12,
										20: 14
									},
									c = {
										17: 2,
										18: 4,
										21: 6,
										22: 8,
										23: 10,
										19: 13,
										20: 15
									},
									d = {
										25: 1,
										26: 3,
										29: 5,
										30: 7,
										31: 9,
										24: 11,
										27: 12,
										28: 14
									},
									f = {
										25: 2,
										26: 4,
										29: 6,
										30: 8,
										31: 10,
										27: 13,
										28: 15
									},
									h = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
								! function(e) {
									e[e.ERROR = 0] = "ERROR", e[e.TEXT = 1] = "TEXT", e[e.WARNING = 2] = "WARNING", e[e.INFO = 2] = "INFO", e[e.DEBUG = 3] = "DEBUG", e[e.DATA = 3] = "DATA"
								}(n || (n = {}));
								var g = function() {
										function e() {
											this.time = null, this.verboseLevel = n.ERROR
										}
										return e.prototype.log = function(e, t) {
											this.verboseLevel >= e && i.logger.log(this.time + " [" + e + "] " + t)
										}, e
									}(),
									v = function(e) {
										for (var t = [], r = 0; r < e.length; r++) t.push(e[r].toString(16));
										return t
									},
									p = function() {
										function e(e, t, r, n, i) {
											this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = t || !1, this.italics = r || !1, this.background = n || "black", this.flash = i || !1
										}
										var t = e.prototype;
										return t.reset = function() {
											this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
										}, t.setStyles = function(e) {
											for (var t = ["foreground", "underline", "italics", "background", "flash"], r = 0; r < t.length; r++) {
												var n = t[r];
												e.hasOwnProperty(n) && (this[n] = e[n])
											}
										}, t.isDefault = function() {
											return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
										}, t.equals = function(e) {
											return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
										}, t.copy = function(e) {
											this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
										}, t.toString = function() {
											return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
										}, e
									}(),
									m = function() {
										function e(e, t, r, n, i, s) {
											this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new p(t, r, n, i, s)
										}
										var t = e.prototype;
										return t.reset = function() {
											this.uchar = " ", this.penState.reset()
										}, t.setChar = function(e, t) {
											this.uchar = e, this.penState.copy(t)
										}, t.setPenState = function(e) {
											this.penState.copy(e)
										}, t.equals = function(e) {
											return this.uchar === e.uchar && this.penState.equals(e.penState)
										}, t.copy = function(e) {
											this.uchar = e.uchar, this.penState.copy(e.penState)
										}, t.isEmpty = function() {
											return " " === this.uchar && this.penState.isDefault()
										}, e
									}(),
									y = function() {
										function e(e) {
											this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
											for (var t = 0; t < l; t++) this.chars.push(new m);
											this.logger = e, this.pos = 0, this.currPenState = new p
										}
										var t = e.prototype;
										return t.equals = function(e) {
											for (var t = !0, r = 0; r < l; r++)
												if (!this.chars[r].equals(e.chars[r])) {
													t = !1;
													break
												} return t
										}, t.copy = function(e) {
											for (var t = 0; t < l; t++) this.chars[t].copy(e.chars[t])
										}, t.isEmpty = function() {
											for (var e = !0, t = 0; t < l; t++)
												if (!this.chars[t].isEmpty()) {
													e = !1;
													break
												} return e
										}, t.setCursor = function(e) {
											this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(n.DEBUG, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > l && (this.logger.log(n.DEBUG, "Too large cursor position " + this.pos), this.pos = l)
										}, t.moveCursor = function(e) {
											var t = this.pos + e;
											if (e > 1)
												for (var r = this.pos + 1; r < t + 1; r++) this.chars[r].setPenState(this.currPenState);
											this.setCursor(t)
										}, t.backSpace = function() {
											this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
										}, t.insertChar = function(e) {
											e >= 144 && this.backSpace();
											var t = a(e);
											this.pos >= l ? this.logger.log(n.ERROR, "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1))
										}, t.clearFromPos = function(e) {
											var t;
											for (t = e; t < l; t++) this.chars[t].reset()
										}, t.clear = function() {
											this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
										}, t.clearToEndOfRow = function() {
											this.clearFromPos(this.pos)
										}, t.getTextString = function() {
											for (var e = [], t = !0, r = 0; r < l; r++) {
												var n = this.chars[r].uchar;
												" " !== n && (t = !1), e.push(n)
											}
											return t ? "" : e.join("")
										}, t.setPenStyles = function(e) {
											this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState)
										}, e
									}(),
									b = function() {
										function e(e) {
											this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
											for (var t = 0; t < o; t++) this.rows.push(new y(e));
											this.logger = e, this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset()
										}
										var t = e.prototype;
										return t.reset = function() {
											for (var e = 0; e < o; e++) this.rows[e].clear();
											this.currRow = 14
										}, t.equals = function(e) {
											for (var t = !0, r = 0; r < o; r++)
												if (!this.rows[r].equals(e.rows[r])) {
													t = !1;
													break
												} return t
										}, t.copy = function(e) {
											for (var t = 0; t < o; t++) this.rows[t].copy(e.rows[t])
										}, t.isEmpty = function() {
											for (var e = !0, t = 0; t < o; t++)
												if (!this.rows[t].isEmpty()) {
													e = !1;
													break
												} return e
										}, t.backSpace = function() {
											this.rows[this.currRow].backSpace()
										}, t.clearToEndOfRow = function() {
											this.rows[this.currRow].clearToEndOfRow()
										}, t.insertChar = function(e) {
											this.rows[this.currRow].insertChar(e)
										}, t.setPen = function(e) {
											this.rows[this.currRow].setPenStyles(e)
										}, t.moveCursor = function(e) {
											this.rows[this.currRow].moveCursor(e)
										}, t.setCursor = function(e) {
											this.logger.log(n.INFO, "setCursor: " + e), this.rows[this.currRow].setCursor(e)
										}, t.setPAC = function(e) {
											this.logger.log(n.INFO, "pacData = " + JSON.stringify(e));
											var t = e.row - 1;
											if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
												for (var r = 0; r < o; r++) this.rows[r].clear();
												var i = this.currRow + 1 - this.nrRollUpRows,
													s = this.lastOutputScreen;
												if (s) {
													var a = s.rows[i].cueStartTime,
														l = this.logger.time;
													if (a && null !== l && a < l)
														for (var u = 0; u < this.nrRollUpRows; u++) this.rows[t - this.nrRollUpRows + u + 1].copy(s.rows[i + u])
												}
											}
											this.currRow = t;
											var c = this.rows[this.currRow];
											if (null !== e.indent) {
												var d = e.indent,
													f = Math.max(d - 1, 0);
												c.setCursor(e.indent), e.color = c.chars[f].penState.foreground
											}
											var h = {
												foreground: e.color,
												underline: e.underline,
												italics: e.italics,
												background: "black",
												flash: !1
											};
											this.setPen(h)
										}, t.setBkgData = function(e) {
											this.logger.log(n.INFO, "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32)
										}, t.setRollUpRows = function(e) {
											this.nrRollUpRows = e
										}, t.rollUp = function() {
											if (null !== this.nrRollUpRows) {
												this.logger.log(n.TEXT, this.getDisplayText());
												var e = this.currRow + 1 - this.nrRollUpRows,
													t = this.rows.splice(e, 1)[0];
												t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(n.INFO, "Rolling up")
											} else this.logger.log(n.DEBUG, "roll_up but nrRollUpRows not set yet")
										}, t.getDisplayText = function(e) {
											e = e || !1;
											for (var t = [], r = "", n = -1, i = 0; i < o; i++) {
												var s = this.rows[i].getTextString();
												s && (n = i + 1, e ? t.push("Row " + n + ": '" + s + "'") : t.push(s.trim()))
											}
											return t.length > 0 && (r = e ? "[" + t.join(" | ") + "]" : t.join("\n")), r
										}, t.getTextAndFormat = function() {
											return this.rows
										}, e
									}(),
									E = function() {
										function e(e, t, r) {
											this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new b(r), this.nonDisplayedMemory = new b(r), this.lastOutputScreen = new b(r), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r
										}
										var t = e.prototype;
										return t.reset = function() {
											this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
										}, t.getHandler = function() {
											return this.outputFilter
										}, t.setHandler = function(e) {
											this.outputFilter = e
										}, t.setPAC = function(e) {
											this.writeScreen.setPAC(e)
										}, t.setBkgData = function(e) {
											this.writeScreen.setBkgData(e)
										}, t.setMode = function(e) {
											e !== this.mode && (this.mode = e, this.logger.log(n.INFO, "MODE=" + e), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
										}, t.insertChars = function(e) {
											for (var t = 0; t < e.length; t++) this.writeScreen.insertChar(e[t]);
											var r = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
											this.logger.log(n.INFO, r + ": " + this.writeScreen.getDisplayText(!0)), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(n.TEXT, "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate())
										}, t.ccRCL = function() {
											this.logger.log(n.INFO, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
										}, t.ccBS = function() {
											this.logger.log(n.INFO, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
										}, t.ccAOF = function() {}, t.ccAON = function() {}, t.ccDER = function() {
											this.logger.log(n.INFO, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
										}, t.ccRU = function(e) {
											this.logger.log(n.INFO, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
										}, t.ccFON = function() {
											this.logger.log(n.INFO, "FON - Flash On"), this.writeScreen.setPen({
												flash: !0
											})
										}, t.ccRDC = function() {
											this.logger.log(n.INFO, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
										}, t.ccTR = function() {
											this.logger.log(n.INFO, "TR"), this.setMode("MODE_TEXT")
										}, t.ccRTD = function() {
											this.logger.log(n.INFO, "RTD"), this.setMode("MODE_TEXT")
										}, t.ccEDM = function() {
											this.logger.log(n.INFO, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
										}, t.ccCR = function() {
											this.logger.log(n.INFO, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
										}, t.ccENM = function() {
											this.logger.log(n.INFO, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
										}, t.ccEOC = function() {
											if (this.logger.log(n.INFO, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
												var e = this.displayedMemory;
												this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(n.TEXT, "DISP: " + this.displayedMemory.getDisplayText())
											}
											this.outputDataUpdate(!0)
										}, t.ccTO = function(e) {
											this.logger.log(n.INFO, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
										}, t.ccMIDROW = function(e) {
											var t = {
												flash: !1
											};
											if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics) t.foreground = "white";
											else {
												var r = Math.floor(e / 2) - 16;
												t.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][r]
											}
											this.logger.log(n.INFO, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t)
										}, t.outputDataUpdate = function(e) {
											void 0 === e && (e = !1);
											var t = this.logger.time;
											null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory))
										}, t.cueSplitAtTime = function(e) {
											this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e))
										}, e
									}(),
									_ = function() {
										function e(e, t, r) {
											this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
											var n = new g;
											this.channels = [null, new E(e, t, n), new E(e + 1, r, n)], this.cmdHistory = {
												a: null,
												b: null
											}, this.logger = n
										}
										var t = e.prototype;
										return t.getHandler = function(e) {
											return this.channels[e].getHandler()
										}, t.setHandler = function(e, t) {
											this.channels[e].setHandler(t)
										}, t.addData = function(e, t) {
											var r, i, s, a = !1;
											this.logger.time = e;
											for (var o = 0; o < t.length; o += 2)
												if (i = 127 & t[o], s = 127 & t[o + 1], 0 !== i || 0 !== s) {
													if (this.logger.log(n.DATA, "[" + v([t[o], t[o + 1]]) + "] -> (" + v([i, s]) + ")"), (r = this.parseCmd(i, s)) || (r = this.parseMidrow(i, s)), r || (r = this.parsePAC(i, s)), r || (r = this.parseBackgroundAttributes(i, s)), !r && (a = this.parseChars(i, s))) {
														var l = this.currentChannel;
														l && l > 0 ? this.channels[l].insertChars(a) : this.logger.log(n.WARNING, "No channel found yet. TEXT-MODE?")
													}
													r || a || this.logger.log(n.WARNING, "Couldn't parse cleaned data " + v([i, s]) + " orig: " + v([t[o], t[o + 1]]))
												}
										}, t.parseCmd = function(e, t) {
											var r = this.cmdHistory;
											if (!((20 === e || 28 === e || 21 === e || 29 === e) && t >= 32 && t <= 47 || (23 === e || 31 === e) && t >= 33 && t <= 35)) return !1;
											if (S(e, t, r)) return T(null, null, r), this.logger.log(n.DEBUG, "Repeated command (" + v([e, t]) + ") is dropped"), !0;
											var i = 20 === e || 21 === e || 23 === e ? 1 : 2,
												s = this.channels[i];
											return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? s.ccRCL() : 33 === t ? s.ccBS() : 34 === t ? s.ccAOF() : 35 === t ? s.ccAON() : 36 === t ? s.ccDER() : 37 === t ? s.ccRU(2) : 38 === t ? s.ccRU(3) : 39 === t ? s.ccRU(4) : 40 === t ? s.ccFON() : 41 === t ? s.ccRDC() : 42 === t ? s.ccTR() : 43 === t ? s.ccRTD() : 44 === t ? s.ccEDM() : 45 === t ? s.ccCR() : 46 === t ? s.ccENM() : 47 === t && s.ccEOC() : s.ccTO(t - 32), T(e, t, r), this.currentChannel = i, !0
										}, t.parseMidrow = function(e, t) {
											var r = 0;
											if ((17 === e || 25 === e) && t >= 32 && t <= 47) {
												if ((r = 17 === e ? 1 : 2) !== this.currentChannel) return this.logger.log(n.ERROR, "Mismatch channel in midrow parsing"), !1;
												var i = this.channels[r];
												return !!i && (i.ccMIDROW(t), this.logger.log(n.DEBUG, "MIDROW (" + v([e, t]) + ")"), !0)
											}
											return !1
										}, t.parsePAC = function(e, t) {
											var r, n = this.cmdHistory;
											if (!((e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127 || (16 === e || 24 === e) && t >= 64 && t <= 95)) return !1;
											if (S(e, t, n)) return T(null, null, n), !0;
											var i = e <= 23 ? 1 : 2;
											r = t >= 64 && t <= 95 ? 1 === i ? u[e] : d[e] : 1 === i ? c[e] : f[e];
											var s = this.channels[i];
											return !!s && (s.setPAC(this.interpretPAC(r, t)), T(e, t, n), this.currentChannel = i, !0)
										}, t.interpretPAC = function(e, t) {
											var r, n = {
												color: null,
												italics: !1,
												indent: null,
												underline: !1,
												row: e
											};
											return r = t > 95 ? t - 96 : t - 64, n.underline = 1 == (1 & r), r <= 13 ? n.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (n.italics = !0, n.color = "white") : n.indent = 4 * Math.floor((r - 16) / 2), n
										}, t.parseChars = function(e, t) {
											var r, i, s = null,
												o = null;
											if (e >= 25 ? (r = 2, o = e - 8) : (r = 1, o = e), o >= 17 && o <= 19 ? (i = 17 === o ? t + 80 : 18 === o ? t + 112 : t + 144, this.logger.log(n.INFO, "Special char '" + a(i) + "' in channel " + r), s = [i]) : e >= 32 && e <= 127 && (s = 0 === t ? [e] : [e, t]), s) {
												var l = v(s);
												this.logger.log(n.DEBUG, "Char codes =  " + l.join(",")), T(e, t, this.cmdHistory)
											}
											return s
										}, t.parseBackgroundAttributes = function(e, t) {
											var r;
											if (!((16 === e || 24 === e) && t >= 32 && t <= 47 || (23 === e || 31 === e) && t >= 45 && t <= 47)) return !1;
											var n = {};
											16 === e || 24 === e ? (r = Math.floor((t - 32) / 2), n.background = h[r], t % 2 == 1 && (n.background = n.background + "_semi")) : 45 === t ? n.background = "transparent" : (n.foreground = "black", 47 === t && (n.underline = !0));
											var i = e <= 23 ? 1 : 2;
											return this.channels[i].setBkgData(n), T(e, t, this.cmdHistory), !0
										}, t.reset = function() {
											for (var e = 0; e < Object.keys(this.channels)
												.length; e++) {
												var t = this.channels[e];
												t && t.reset()
											}
											this.cmdHistory = {
												a: null,
												b: null
											}
										}, t.cueSplitAtTime = function(e) {
											for (var t = 0; t < this.channels.length; t++) {
												var r = this.channels[t];
												r && r.cueSplitAtTime(e)
											}
										}, e
									}();

								function T(e, t, r) {
									r.a = e, r.b = t
								}

								function S(e, t, r) {
									return r.a === e && r.b === t
								}
								t.default = _
							},
							"./src/utils/codecs.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "isCodecType", (function() {
									return i
								})), r.d(t, "isCodecSupportedInMp4", (function() {
									return s
								}));
								var n = {
									audio: {
										a3ds: !0,
										"ac-3": !0,
										"ac-4": !0,
										alac: !0,
										alaw: !0,
										dra1: !0,
										"dts+": !0,
										"dts-": !0,
										dtsc: !0,
										dtse: !0,
										dtsh: !0,
										"ec-3": !0,
										enca: !0,
										g719: !0,
										g726: !0,
										m4ae: !0,
										mha1: !0,
										mha2: !0,
										mhm1: !0,
										mhm2: !0,
										mlpa: !0,
										mp4a: !0,
										"raw ": !0,
										Opus: !0,
										samr: !0,
										sawb: !0,
										sawp: !0,
										sevc: !0,
										sqcp: !0,
										ssmv: !0,
										twos: !0,
										ulaw: !0
									},
									video: {
										avc1: !0,
										avc2: !0,
										avc3: !0,
										avc4: !0,
										avcp: !0,
										av01: !0,
										drac: !0,
										dvav: !0,
										dvhe: !0,
										encv: !0,
										hev1: !0,
										hvc1: !0,
										mjp2: !0,
										mp4v: !0,
										mvc1: !0,
										mvc2: !0,
										mvc3: !0,
										mvc4: !0,
										resv: !0,
										rv60: !0,
										s263: !0,
										svc1: !0,
										svc2: !0,
										"vc-1": !0,
										vp08: !0,
										vp09: !0
									},
									text: {
										stpp: !0,
										wvtt: !0
									}
								};

								function i(e, t) {
									var r = n[t];
									return !!r && !0 === r[e.slice(0, 4)]
								}

								function s(e, t) {
									return MediaSource.isTypeSupported((t || "video") + '/mp4;codecs="' + e + '"')
								}
							},
							"./src/utils/cues.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/utils/vttparser.ts"),
									i = r("./src/utils/webvtt-parser.ts"),
									s = r("./src/utils/texttrack-utils.ts"),
									a = /\s/,
									o = {
										newCue: function(e, t, r, o) {
											for (var l, u, c, d, f, h = [], g = self.VTTCue || self.TextTrackCue, v = 0; v < o.rows.length; v++)
												if (c = !0, d = 0, f = "", !(l = o.rows[v])
													.isEmpty()) {
													for (var p = 0; p < l.chars.length; p++) a.test(l.chars[p].uchar) && c ? d++ : (f += l.chars[p].uchar, c = !1);
													l.cueStartTime = t, t === r && (r += 1e-4), d >= 16 ? d-- : d++;
													var m = Object(n.fixLineBreaks)(f.trim()),
														y = Object(i.generateCueId)(t, r, m);
													e && e.cues && e.cues.getCueById(y) || ((u = new g(t, r, m))
														.id = y, u.line = v + 1, u.align = "left", u.position = 10 + Math.min(80, 10 * Math.floor(8 * d / 32)), h.push(u))
												} return e && h.length && (h.sort((function(e, t) {
												return "auto" === e.line || "auto" === t.line ? 0 : e.line > 8 && t.line > 8 ? t.line - e.line : e.line - t.line
											})), h.forEach((function(t) {
												return Object(s.addCueToTrack)(e, t)
											}))), h
										}
									};
								t.default = o
							},
							"./src/utils/discontinuities.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "findFirstFragWithCC", (function() {
									return a
								})), r.d(t, "shouldAlignOnDiscontinuities", (function() {
									return o
								})), r.d(t, "findDiscontinuousReferenceFrag", (function() {
									return l
								})), r.d(t, "adjustSlidingStart", (function() {
									return c
								})), r.d(t, "alignStream", (function() {
									return d
								})), r.d(t, "alignPDT", (function() {
									return f
								})), r.d(t, "alignFragmentByPDTDelta", (function() {
									return h
								})), r.d(t, "alignMediaPlaylistByPDT", (function() {
									return g
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/utils/logger.ts"),
									s = r("./src/controller/level-helper.ts");

								function a(e, t) {
									for (var r = null, n = 0, i = e.length; n < i; n++) {
										var s = e[n];
										if (s && s.cc === t) {
											r = s;
											break
										}
									}
									return r
								}

								function o(e, t, r) {
									return !(!t.details || !(r.endCC > r.startCC || e && e.cc < r.startCC))
								}

								function l(e, t) {
									var r = e.fragments,
										n = t.fragments;
									if (n.length && r.length) {
										var s = a(r, n[0].cc);
										if (s && (!s || s.startPTS)) return s;
										i.logger.log("No frag in previous level to align on")
									} else i.logger.log("No fragments to align")
								}

								function u(e, t) {
									if (e) {
										var r = e.start + t;
										e.start = e.startPTS = r, e.endPTS = r + e.duration
									}
								}

								function c(e, t) {
									for (var r = t.fragments, n = 0, i = r.length; n < i; n++) u(r[n], e);
									t.fragmentHint && u(t.fragmentHint, e), t.alignedSliding = !0
								}

								function d(e, t, r) {
									t && (function(e, t, r) {
										if (o(e, r, t)) {
											var s = l(r.details, t);
											s && Object(n.isFiniteNumber)(s.start) && (i.logger.log("Adjusting PTS using last level due to CC increase within current level " + t.url), c(s.start, t))
										}
									}(e, r, t), !r.alignedSliding && t.details && f(r, t.details), r.alignedSliding || !t.details || r.skippedSegments || Object(s.adjustSliding)(t.details, r))
								}

								function f(e, t) {
									if (t.fragments.length && e.hasProgramDateTime && t.hasProgramDateTime) {
										var r = t.fragments[0].programDateTime,
											s = e.fragments[0].programDateTime,
											a = (s - r) / 1e3 + t.fragments[0].start;
										a && Object(n.isFiniteNumber)(a) && (i.logger.log("Adjusting PTS using programDateTime delta " + (s - r) + "ms, sliding:" + a.toFixed(3) + " " + e.url + " "), c(a, e))
									}
								}

								function h(e, t) {
									var r = e.programDateTime;
									if (r) {
										var n = (r - t) / 1e3;
										e.start = e.startPTS = n, e.endPTS = n + e.duration
									}
								}

								function g(e, t) {
									if (t.fragments.length && e.hasProgramDateTime && t.hasProgramDateTime) {
										var r = t.fragments[0].programDateTime - 1e3 * t.fragments[0].start;
										e.fragments.forEach((function(e) {
											h(e, r)
										})), e.fragmentHint && h(e.fragmentHint, r), e.alignedSliding = !0
									}
								}
							},
							"./src/utils/ewma-bandwidth-estimator.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/utils/ewma.ts"),
									i = function() {
										function e(e, t, r) {
											this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new n.default(e), this.fast_ = new n.default(t)
										}
										var t = e.prototype;
										return t.update = function(e, t) {
											var r = this.slow_,
												i = this.fast_;
											this.slow_.halfLife !== e && (this.slow_ = new n.default(e, r.getEstimate(), r.getTotalWeight())), this.fast_.halfLife !== t && (this.fast_ = new n.default(t, i.getEstimate(), i.getTotalWeight()))
										}, t.sample = function(e, t) {
											var r = (e = Math.max(e, this.minDelayMs_)) / 1e3,
												n = 8 * t / r;
											this.fast_.sample(r, n), this.slow_.sample(r, n)
										}, t.canEstimate = function() {
											var e = this.fast_;
											return e && e.getTotalWeight() >= this.minWeight_
										}, t.getEstimate = function() {
											return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
										}, t.destroy = function() {}, e
									}();
								t.default = i
							},
							"./src/utils/ewma.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = function() {
									function e(e, t, r) {
										void 0 === t && (t = 0), void 0 === r && (r = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r
									}
									var t = e.prototype;
									return t.sample = function(e, t) {
										var r = Math.pow(this.alpha_, e);
										this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e
									}, t.getTotalWeight = function() {
										return this.totalWeight_
									}, t.getEstimate = function() {
										if (this.alpha_) {
											var e = 1 - Math.pow(this.alpha_, this.totalWeight_);
											if (e) return this.estimate_ / e
										}
										return this.estimate_
									}, e
								}();
								t.default = n
							},
							"./src/utils/fetch-loader.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "fetchSupported", (function() {
									return f
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/loader/load-stats.ts"),
									s = r("./src/demux/chunk-cache.ts");

								function a(e) {
									var t = "function" == typeof Map ? new Map : void 0;
									return a = function(e) {
										if (null === e || (r = e, -1 === Function.toString.call(r)
											.indexOf("[native code]"))) return e;
										var r;
										if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
										if (void 0 !== t) {
											if (t.has(e)) return t.get(e);
											t.set(e, n)
										}

										function n() {
											return o(e, arguments, c(this)
												.constructor)
										}
										return n.prototype = Object.create(e.prototype, {
											constructor: {
												value: n,
												enumerable: !1,
												writable: !0,
												configurable: !0
											}
										}), u(n, e)
									}, a(e)
								}

								function o(e, t, r) {
									return o = l() ? Reflect.construct : function(e, t, r) {
										var n = [null];
										n.push.apply(n, t);
										var i = new(Function.bind.apply(e, n));
										return r && u(i, r.prototype), i
									}, o.apply(null, arguments)
								}

								function l() {
									if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
									if (Reflect.construct.sham) return !1;
									if ("function" == typeof Proxy) return !0;
									try {
										return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
									} catch (e) {
										return !1
									}
								}

								function u(e, t) {
									return u = Object.setPrototypeOf || function(e, t) {
										return e.__proto__ = t, e
									}, u(e, t)
								}

								function c(e) {
									return c = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
										return e.__proto__ || Object.getPrototypeOf(e)
									}, c(e)
								}

								function d() {
									return d = Object.assign || function(e) {
										for (var t = 1; t < arguments.length; t++) {
											var r = arguments[t];
											for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
										}
										return e
									}, d.apply(this, arguments)
								}

								function f() {
									if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
										return new self.ReadableStream({}), !0
									} catch (e) {}
									return !1
								}
								var h = function() {
									function e(e) {
										this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || g, this.controller = new self.AbortController, this.stats = new i.LoadStats
									}
									var t = e.prototype;
									return t.destroy = function() {
										this.loader = this.callbacks = null, this.abortInternal()
									}, t.abortInternal = function() {
										var e = this.response;
										e && e.ok || (this.stats.aborted = !0, this.controller.abort())
									}, t.abort = function() {
										var e;
										this.abortInternal(), null !== (e = this.callbacks) && void 0 !== e && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
									}, t.load = function(e, t, r) {
										var i = this,
											s = this.stats;
										if (s.loading.start) throw new Error("Loader can only be used once.");
										s.loading.start = self.performance.now();
										var a = function(e, t) {
												var r = {
													method: "GET",
													mode: "cors",
													credentials: "same-origin",
													signal: t,
													headers: new self.Headers(d({}, e.headers))
												};
												return e.rangeEnd && r.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)), r
											}(e, this.controller.signal),
											o = r.onProgress,
											l = "arraybuffer" === e.responseType,
											u = l ? "byteLength" : "length";
										this.context = e, this.config = t, this.callbacks = r, this.request = this.fetchSetup(e, a), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout((function() {
												i.abortInternal(), r.onTimeout(s, e, i.response)
											}), t.timeout), self.fetch(this.request)
											.then((function(r) {
												if (i.response = i.loader = r, !r.ok) {
													var a = r.status,
														u = r.statusText;
													throw new v(u || "fetch, bad network response", a, r)
												}
												return s.loading.first = Math.max(self.performance.now(), s.loading.start), s.total = parseInt(r.headers.get("Content-Length") || "0"), o && Object(n.isFiniteNumber)(t.highWaterMark) ? i.loadProgressively(r, s, e, t.highWaterMark, o) : l ? r.arrayBuffer() : r.text()
											}))
											.then((function(a) {
												var l = i.response;
												self.clearTimeout(i.requestTimeout), s.loading.end = Math.max(self.performance.now(), s.loading.first), s.loaded = s.total = a[u];
												var c = {
													url: l.url,
													data: a
												};
												o && !Object(n.isFiniteNumber)(t.highWaterMark) && o(s, e, a, l), r.onSuccess(c, s, e, l)
											}))
											.catch((function(t) {
												if (self.clearTimeout(i.requestTimeout), !s.aborted) {
													var n = t.code || 0;
													r.onError({
														code: n,
														text: t.message
													}, e, t.details)
												}
											}))
									}, t.getCacheAge = function() {
										var e = null;
										if (this.response) {
											var t = this.response.headers.get("age");
											e = t ? parseFloat(t) : null
										}
										return e
									}, t.loadProgressively = function(e, t, r, n, i) {
										void 0 === n && (n = 0);
										var a = new s.default,
											o = e.body.getReader();
										return function s() {
											return o.read()
												.then((function(o) {
													if (o.done) return a.dataLength && i(t, r, a.flush(), e), Promise.resolve(new ArrayBuffer(0));
													var l = o.value,
														u = l.length;
													return t.loaded += u, u < n || a.dataLength ? (a.push(l), a.dataLength >= n && i(t, r, a.flush(), e)) : i(t, r, l, e), s()
												}))
												.catch((function() {
													return Promise.reject()
												}))
										}()
									}, e
								}();

								function g(e, t) {
									return new self.Request(e.url, t)
								}
								var v = function(e) {
									var t, r;

									function n(t, r, n) {
										var i;
										return (i = e.call(this, t) || this)
											.code = void 0, i.details = void 0, i.code = r, i.details = n, i
									}
									return r = e, (t = n)
										.prototype = Object.create(r.prototype), t.prototype.constructor = t, u(t, r), n
								}(a(Error));
								t.default = h
							},
							"./src/utils/imsc1-ttml-parser.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "IMSC1_CODEC", (function() {
									return c
								})), r.d(t, "parseIMSC1", (function() {
									return g
								}));
								var n = r("./src/utils/mp4-tools.ts"),
									i = r("./src/utils/vttparser.ts"),
									s = r("./src/utils/vttcue.ts"),
									a = r("./src/demux/id3.ts"),
									o = r("./src/utils/timescale-conversion.ts"),
									l = r("./src/utils/webvtt-parser.ts");

								function u() {
									return u = Object.assign || function(e) {
										for (var t = 1; t < arguments.length; t++) {
											var r = arguments[t];
											for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
										}
										return e
									}, u.apply(this, arguments)
								}
								var c = "stpp.ttml.im1t",
									d = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
									f = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
									h = {
										left: "start",
										center: "center",
										right: "end",
										start: "start",
										end: "end"
									};

								function g(e, t, r, i, c) {
									var d = Object(n.findBox)(new Uint8Array(e), ["mdat"]);
									if (0 !== d.length) {
										var f = d[0],
											g = Object(a.utf8ArrayToStr)(new Uint8Array(e, f.start, f.end - f.start)),
											_ = Object(o.toTimescaleFromScale)(t, 1, r);
										try {
											i(function(e, t) {
												var r = (new DOMParser)
													.parseFromString(e, "text/xml")
													.getElementsByTagName("tt")[0];
												if (!r) throw new Error("Invalid ttml");
												var n = {
														frameRate: 30,
														subFrameRate: 1,
														frameRateMultiplier: 0,
														tickRate: 0
													},
													i = Object.keys(n)
													.reduce((function(e, t) {
														return e[t] = r.getAttribute("ttp:" + t) || n[t], e
													}), {}),
													a = "preserve" !== r.getAttribute("xml:space"),
													o = p(v(r, "styling", "style")),
													c = p(v(r, "layout", "region")),
													d = v(r, "body", "[begin]");
												return [].map.call(d, (function(e) {
														var r = m(e, a);
														if (!r || !e.hasAttribute("begin")) return null;
														var n = E(e.getAttribute("begin"), i),
															d = E(e.getAttribute("dur"), i),
															f = E(e.getAttribute("end"), i);
														if (null === n) throw b(e);
														if (null === f) {
															if (null === d) throw b(e);
															f = n + d
														}
														var g = new s.default(n - t, f - t, r);
														g.id = Object(l.generateCueId)(g.startTime, g.endTime, g.text);
														var v = c[e.getAttribute("region")],
															p = o[e.getAttribute("style")];
														g.position = 10, g.size = 80;
														var _ = function(e, t) {
																var r = "http://www.w3.org/ns/ttml#styling";
																return ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce((function(n, i) {
																	var s = y(t, r, i) || y(e, r, i);
																	return s && (n[i] = s), n
																}), {})
															}(v, p),
															T = _.textAlign;
														if (T) {
															var S = h[T];
															S && (g.lineAlign = S), g.align = T
														}
														return u(g, _), g
													}))
													.filter((function(e) {
														return null !== e
													}))
											}(g, _))
										} catch (e) {
											c(e)
										}
									} else c(new Error("Could not parse IMSC1 mdat"))
								}

								function v(e, t, r) {
									var n = e.getElementsByTagName(t)[0];
									return n ? [].slice.call(n.querySelectorAll(r)) : []
								}

								function p(e) {
									return e.reduce((function(e, t) {
										var r = t.getAttribute("xml:id");
										return r && (e[r] = t), e
									}), {})
								}

								function m(e, t) {
									return [].slice.call(e.childNodes)
										.reduce((function(e, r, n) {
											var i;
											return "br" === r.nodeName && n ? e + "\n" : null !== (i = r.childNodes) && void 0 !== i && i.length ? m(r, t) : t ? e + r.textContent.trim()
												.replace(/\s+/g, " ") : e + r.textContent
										}), "")
								}

								function y(e, t, r) {
									return e.hasAttributeNS(t, r) ? e.getAttributeNS(t, r) : null
								}

								function b(e) {
									return new Error("Could not parse ttml timestamp " + e)
								}

								function E(e, t) {
									if (!e) return null;
									var r = Object(i.parseTimeStamp)(e);
									return null === r && (d.test(e) ? r = function(e, t) {
										var r = d.exec(e),
											n = (0 | r[4]) + (0 | r[5]) / t.subFrameRate;
										return 3600 * (0 | r[1]) + 60 * (0 | r[2]) + (0 | r[3]) + n / t.frameRate
									}(e, t) : f.test(e) && (r = function(e, t) {
										var r = f.exec(e),
											n = Number(r[1]);
										switch (r[2]) {
											case "h":
												return 3600 * n;
											case "m":
												return 60 * n;
											case "ms":
												return 1e3 * n;
											case "f":
												return n / t.frameRate;
											case "t":
												return n / t.tickRate
										}
										return n
									}(e, t))), r
								}
							},
							"./src/utils/logger.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "enableLogs", (function() {
									return o
								})), r.d(t, "logger", (function() {
									return l
								}));
								var n = function() {},
									i = {
										trace: n,
										debug: n,
										log: n,
										warn: n,
										info: n,
										error: n
									},
									s = i;

								function a(e) {
									var t = self.console[e];
									return t ? t.bind(self.console, "[" + e + "] >") : n
								}

								function o(e) {
									if (self.console && !0 === e || "object" == typeof e) {
										! function(e) {
											for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];
											r.forEach((function(t) {
												s[t] = e[t] ? e[t].bind(e) : a(t)
											}))
										}(e, "debug", "log", "info", "warn", "error");
										try {
											s.log()
										} catch (e) {
											s = i
										}
									} else s = i
								}
								var l = i
							},
							"./src/utils/mediakeys-helper.ts": function(e, t, r) {
								"use strict";
								var n;
								r.r(t), r.d(t, "KeySystems", (function() {
										return n
									})), r.d(t, "requestMediaKeySystemAccess", (function() {
										return i
									})),
									function(e) {
										e.WIDEVINE = "com.widevine.alpha", e.PLAYREADY = "com.microsoft.playready"
									}(n || (n = {}));
								var i = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null
							},
							"./src/utils/mediasource-helper.ts": function(e, t, r) {
								"use strict";

								function n() {
									return self.MediaSource || self.WebKitMediaSource
								}
								r.r(t), r.d(t, "getMediaSource", (function() {
									return n
								}))
							},
							"./src/utils/mp4-tools.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "bin2str", (function() {
									return o
								})), r.d(t, "readUint16", (function() {
									return l
								})), r.d(t, "readUint32", (function() {
									return u
								})), r.d(t, "writeUint32", (function() {
									return c
								})), r.d(t, "findBox", (function() {
									return d
								})), r.d(t, "parseSegmentIndex", (function() {
									return f
								})), r.d(t, "parseInitSegment", (function() {
									return h
								})), r.d(t, "getStartDTS", (function() {
									return g
								})), r.d(t, "getDuration", (function() {
									return v
								})), r.d(t, "computeRawDurationFromSamples", (function() {
									return p
								})), r.d(t, "offsetStartDTS", (function() {
									return m
								})), r.d(t, "segmentValidRange", (function() {
									return y
								})), r.d(t, "appendUint8Array", (function() {
									return b
								}));
								var n = r("./src/utils/typed-array.ts"),
									i = r("./src/loader/fragment.ts"),
									s = Math.pow(2, 32) - 1,
									a = [].push;

								function o(e) {
									return String.fromCharCode.apply(null, e)
								}

								function l(e, t) {
									"data" in e && (t += e.start, e = e.data);
									var r = e[t] << 8 | e[t + 1];
									return r < 0 ? 65536 + r : r
								}

								function u(e, t) {
									"data" in e && (t += e.start, e = e.data);
									var r = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
									return r < 0 ? 4294967296 + r : r
								}

								function c(e, t, r) {
									"data" in e && (t += e.start, e = e.data), e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r
								}

								function d(e, t) {
									var r, n, i, s = [];
									if (!t.length) return s;
									"data" in e ? (r = e.data, n = e.start, i = e.end) : (n = 0, i = (r = e)
										.byteLength);
									for (var l = n; l < i;) {
										var c = u(r, l),
											f = c > 1 ? l + c : i;
										if (o(r.subarray(l + 4, l + 8)) === t[0])
											if (1 === t.length) s.push({
												data: r,
												start: l + 8,
												end: f
											});
											else {
												var h = d({
													data: r,
													start: l + 8,
													end: f
												}, t.slice(1));
												h.length && a.apply(s, h)
											} l = f
									}
									return s
								}

								function f(e) {
									var t = d(e, ["moov"])[0],
										r = t ? t.end : null,
										n = d(e, ["sidx"]);
									if (!n || !n[0]) return null;
									var i = [],
										s = n[0],
										a = s.data[0],
										o = 0 === a ? 8 : 16,
										c = u(s, o);
									o += 4, o += 0 === a ? 8 : 16, o += 2;
									var f = s.end + 0,
										h = l(s, o);
									o += 2;
									for (var g = 0; g < h; g++) {
										var v = o,
											p = u(s, v);
										v += 4;
										var m = 2147483647 & p;
										if (1 == (2147483648 & p) >>> 31) return console.warn("SIDX has hierarchical references (not supported)"), null;
										var y = u(s, v);
										v += 4, i.push({
											referenceSize: m,
											subsegmentDuration: y,
											info: {
												duration: y / c,
												start: f,
												end: f + m - 1
											}
										}), f += m, o = v += 4
									}
									return {
										earliestPresentationTime: 0,
										timescale: c,
										version: a,
										referencesCount: h,
										references: i,
										moovEndOffset: r
									}
								}

								function h(e) {
									for (var t = [], r = d(e, ["moov", "trak"]), n = 0; n < r.length; n++) {
										var s = r[n],
											a = d(s, ["tkhd"])[0];
										if (a) {
											var l = a.data[a.start],
												c = 0 === l ? 12 : 20,
												f = u(a, c),
												h = d(s, ["mdia", "mdhd"])[0];
											if (h) {
												var g = u(h, c = 0 === (l = h.data[h.start]) ? 12 : 20),
													v = d(s, ["mdia", "hdlr"])[0];
												if (v) {
													var p = o(v.data.subarray(v.start + 8, v.start + 12)),
														m = {
															soun: i.ElementaryStreamTypes.AUDIO,
															vide: i.ElementaryStreamTypes.VIDEO
														} [p];
													if (m) {
														var y = d(s, ["mdia", "minf", "stbl", "stsd"])[0],
															b = void 0;
														y && (b = o(y.data.subarray(y.start + 12, y.start + 16))), t[f] = {
															timescale: g,
															type: m
														}, t[m] = {
															timescale: g,
															id: f,
															codec: b
														}
													}
												}
											}
										}
									}
									return d(e, ["moov", "mvex", "trex"])
										.forEach((function(e) {
											var r = u(e, 4),
												n = t[r];
											n && (n.default = {
												duration: u(e, 12),
												flags: u(e, 20)
											})
										})), t
								}

								function g(e, t) {
									return d(t, ["moof", "traf"])
										.reduce((function(t, r) {
											var n = d(r, ["tfdt"])[0],
												i = n.data[n.start],
												s = d(r, ["tfhd"])
												.reduce((function(t, r) {
													var s = u(r, 4),
														a = e[s];
													if (a) {
														var o = u(n, 4);
														1 === i && (o *= Math.pow(2, 32), o += u(n, 8));
														var l = o / (a.timescale || 9e4);
														if (isFinite(l) && (null === t || l < t)) return l
													}
													return t
												}), null);
											return null !== s && isFinite(s) && (null === t || s < t) ? s : t
										}), null) || 0
								}

								function v(e, t) {
									for (var r = 0, n = 0, s = 0, a = d(e, ["moof", "traf"]), o = 0; o < a.length; o++) {
										var l = a[o],
											c = d(l, ["tfhd"])[0],
											h = t[u(c, 4)];
										if (h) {
											var g = h.default,
												v = u(c, 0) | (null == g ? void 0 : g.flags),
												m = null == g ? void 0 : g.duration;
											8 & v && (m = u(c, 2 & v ? 12 : 8));
											for (var y = h.timescale || 9e4, b = d(l, ["trun"]), E = 0; E < b.length; E++) !(r = p(b[E])) && m && (r = m * u(b[E], 4)), h.type === i.ElementaryStreamTypes.VIDEO ? n += r / y : h.type === i.ElementaryStreamTypes.AUDIO && (s += r / y)
										}
									}
									if (0 === n && 0 === s) {
										var _ = f(e);
										if (null != _ && _.references) return _.references.reduce((function(e, t) {
											return e + t.info.duration || 0
										}), 0)
									}
									return n || s
								}

								function p(e) {
									var t = u(e, 0),
										r = 8;
									1 & t && (r += 4), 4 & t && (r += 4);
									for (var n = 0, i = u(e, 4), s = 0; s < i; s++) 256 & t && (n += u(e, r), r += 4), 512 & t && (r += 4), 1024 & t && (r += 4), 2048 & t && (r += 4);
									return n
								}

								function m(e, t, r) {
									d(t, ["moof", "traf"])
										.forEach((function(t) {
											d(t, ["tfhd"])
												.forEach((function(n) {
													var i = u(n, 4),
														a = e[i];
													if (a) {
														var o = a.timescale || 9e4;
														d(t, ["tfdt"])
															.forEach((function(e) {
																var t = e.data[e.start],
																	n = u(e, 4);
																if (0 === t) c(e, 4, n - r * o);
																else {
																	n *= Math.pow(2, 32), n += u(e, 8), n -= r * o, n = Math.max(n, 0);
																	var i = Math.floor(n / (s + 1)),
																		a = Math.floor(n % (s + 1));
																	c(e, 4, i), c(e, 8, a)
																}
															}))
													}
												}))
										}))
								}

								function y(e) {
									var t = {
											valid: null,
											remainder: null
										},
										r = d(e, ["moof"]);
									if (!r) return t;
									if (r.length < 2) return t.remainder = e, t;
									var i = r[r.length - 1];
									return t.valid = Object(n.sliceUint8)(e, 0, i.start - 8), t.remainder = Object(n.sliceUint8)(e, i.start - 8), t
								}

								function b(e, t) {
									var r = new Uint8Array(e.length + t.length);
									return r.set(e), r.set(t, e.length), r
								}
							},
							"./src/utils/output-filter.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "default", (function() {
									return n
								}));
								var n = function() {
									function e(e, t) {
										this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t
									}
									var t = e.prototype;
									return t.dispatchCue = function() {
										null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
									}, t.newCue = function(e, t, r) {
										(null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName)
									}, t.reset = function() {
										this.cueRanges = [], this.startTime = null
									}, e
								}()
							},
							"./src/utils/texttrack-utils.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "sendAddTrackEvent", (function() {
									return i
								})), r.d(t, "addCueToTrack", (function() {
									return s
								})), r.d(t, "clearCurrentCues", (function() {
									return a
								})), r.d(t, "removeCuesInRange", (function() {
									return o
								})), r.d(t, "getCuesInRange", (function() {
									return l
								}));
								var n = r("./src/utils/logger.ts");

								function i(e, t) {
									var r;
									try {
										r = new Event("addtrack")
									} catch (e) {
										(r = document.createEvent("Event"))
										.initEvent("addtrack", !1, !1)
									}
									r.track = e, t.dispatchEvent(r)
								}

								function s(e, t) {
									var r = e.mode;
									if ("disabled" === r && (e.mode = "hidden"), e.cues && !e.cues.getCueById(t.id)) try {
										if (e.addCue(t), !e.cues.getCueById(t.id)) throw new Error("addCue is failed for: " + t)
									} catch (r) {
										n.logger.debug("[texttrack-utils]: " + r);
										var i = new self.TextTrackCue(t.startTime, t.endTime, t.text);
										i.id = t.id, e.addCue(i)
									}
									"disabled" === r && (e.mode = r)
								}

								function a(e) {
									var t = e.mode;
									if ("disabled" === t && (e.mode = "hidden"), e.cues)
										for (var r = e.cues.length; r--;) e.removeCue(e.cues[r]);
									"disabled" === t && (e.mode = t)
								}

								function o(e, t, r) {
									var n = e.mode;
									if ("disabled" === n && (e.mode = "hidden"), e.cues && e.cues.length > 0)
										for (var i = l(e.cues, t, r), s = 0; s < i.length; s++) e.removeCue(i[s]);
									"disabled" === n && (e.mode = n)
								}

								function l(e, t, r) {
									var n = [],
										i = function(e, t) {
											if (t < e[0].startTime) return 0;
											var r = e.length - 1;
											if (t > e[r].endTime) return -1;
											for (var n = 0, i = r; n <= i;) {
												var s = Math.floor((i + n) / 2);
												if (t < e[s].startTime) i = s - 1;
												else {
													if (!(t > e[s].startTime && n < r)) return s;
													n = s + 1
												}
											}
											return e[n].startTime - t < t - e[i].startTime ? n : i
										}(e, t);
									if (i > -1)
										for (var s = i, a = e.length; s < a; s++) {
											var o = e[s];
											if (o.startTime >= t && o.endTime <= r) n.push(o);
											else if (o.startTime > r) return n
										}
									return n
								}
							},
							"./src/utils/time-ranges.ts": function(e, t, r) {
								"use strict";
								r.r(t), t.default = {
									toString: function(e) {
										for (var t = "", r = e.length, n = 0; n < r; n++) t += "[" + e.start(n)
											.toFixed(3) + "," + e.end(n)
											.toFixed(3) + "]";
										return t
									}
								}
							},
							"./src/utils/timescale-conversion.ts": function(e, t, r) {
								"use strict";

								function n(e, t, r, n) {
									void 0 === r && (r = 1), void 0 === n && (n = !1);
									var i = e * t * r;
									return n ? Math.round(i) : i
								}

								function i(e, t, r, i) {
									return void 0 === r && (r = 1), void 0 === i && (i = !1), n(e, t, 1 / r, i)
								}

								function s(e, t) {
									return void 0 === t && (t = !1), n(e, 1e3, 1 / 9e4, t)
								}

								function a(e, t) {
									return void 0 === t && (t = 1), n(e, 9e4, 1 / t)
								}
								r.r(t), r.d(t, "toTimescaleFromBase", (function() {
									return n
								})), r.d(t, "toTimescaleFromScale", (function() {
									return i
								})), r.d(t, "toMsFromMpegTsClock", (function() {
									return s
								})), r.d(t, "toMpegTsClockFromTimescale", (function() {
									return a
								}))
							},
							"./src/utils/typed-array.ts": function(e, t, r) {
								"use strict";

								function n(e, t, r) {
									return Uint8Array.prototype.slice ? e.slice(t, r) : new Uint8Array(Array.prototype.slice.call(e, t, r))
								}
								r.r(t), r.d(t, "sliceUint8", (function() {
									return n
								}))
							},
							"./src/utils/vttcue.ts": function(e, t, r) {
								"use strict";
								r.r(t), t.default = function() {
									if ("undefined" != typeof self && self.VTTCue) return self.VTTCue;
									var e = ["", "lr", "rl"],
										t = ["start", "middle", "end", "left", "right"];

									function r(e, t) {
										if ("string" != typeof t) return !1;
										if (!Array.isArray(e)) return !1;
										var r = t.toLowerCase();
										return !!~e.indexOf(r) && r
									}

									function n(e) {
										return r(t, e)
									}

									function i(e) {
										for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];
										for (var i = 1; i < arguments.length; i++) {
											var s = arguments[i];
											for (var a in s) e[a] = s[a]
										}
										return e
									}

									function s(t, s, a) {
										var o = this,
											l = {
												enumerable: !0
											};
										o.hasBeenReset = !1;
										var u = "",
											c = !1,
											d = t,
											f = s,
											h = a,
											g = null,
											v = "",
											p = !0,
											m = "auto",
											y = "start",
											b = 50,
											E = "middle",
											_ = 50,
											T = "middle";
										Object.defineProperty(o, "id", i({}, l, {
											get: function() {
												return u
											},
											set: function(e) {
												u = "" + e
											}
										})), Object.defineProperty(o, "pauseOnExit", i({}, l, {
											get: function() {
												return c
											},
											set: function(e) {
												c = !!e
											}
										})), Object.defineProperty(o, "startTime", i({}, l, {
											get: function() {
												return d
											},
											set: function(e) {
												if ("number" != typeof e) throw new TypeError("Start time must be set to a number.");
												d = e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "endTime", i({}, l, {
											get: function() {
												return f
											},
											set: function(e) {
												if ("number" != typeof e) throw new TypeError("End time must be set to a number.");
												f = e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "text", i({}, l, {
											get: function() {
												return h
											},
											set: function(e) {
												h = "" + e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "region", i({}, l, {
											get: function() {
												return g
											},
											set: function(e) {
												g = e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "vertical", i({}, l, {
											get: function() {
												return v
											},
											set: function(t) {
												var n = function(t) {
													return r(e, t)
												}(t);
												if (!1 === n) throw new SyntaxError("An invalid or illegal string was specified.");
												v = n, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "snapToLines", i({}, l, {
											get: function() {
												return p
											},
											set: function(e) {
												p = !!e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "line", i({}, l, {
											get: function() {
												return m
											},
											set: function(e) {
												if ("number" != typeof e && "auto" !== e) throw new SyntaxError("An invalid number or illegal string was specified.");
												m = e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "lineAlign", i({}, l, {
											get: function() {
												return y
											},
											set: function(e) {
												var t = n(e);
												if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
												y = t, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "position", i({}, l, {
											get: function() {
												return b
											},
											set: function(e) {
												if (e < 0 || e > 100) throw new Error("Position must be between 0 and 100.");
												b = e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "positionAlign", i({}, l, {
											get: function() {
												return E
											},
											set: function(e) {
												var t = n(e);
												if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
												E = t, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "size", i({}, l, {
											get: function() {
												return _
											},
											set: function(e) {
												if (e < 0 || e > 100) throw new Error("Size must be between 0 and 100.");
												_ = e, this.hasBeenReset = !0
											}
										})), Object.defineProperty(o, "align", i({}, l, {
											get: function() {
												return T
											},
											set: function(e) {
												var t = n(e);
												if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
												T = t, this.hasBeenReset = !0
											}
										})), o.displayState = void 0
									}
									return s.prototype.getCueAsHTML = function() {
										return self.WebVTT.convertCueToDOMTree(self, this.text)
									}, s
								}()
							},
							"./src/utils/vttparser.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "parseTimeStamp", (function() {
									return s
								})), r.d(t, "fixLineBreaks", (function() {
									return d
								})), r.d(t, "VTTParser", (function() {
									return f
								}));
								var n = r("./src/utils/vttcue.ts"),
									i = function() {
										function e() {}
										return e.prototype.decode = function(e, t) {
											if (!e) return "";
											if ("string" != typeof e) throw new Error("Error - expected string data.");
											return decodeURIComponent(encodeURIComponent(e))
										}, e
									}();

								function s(e) {
									function t(e, t, r, n) {
										return 3600 * (0 | e) + 60 * (0 | t) + (0 | r) + parseFloat(n || 0)
									}
									var r = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
									return r ? parseFloat(r[2]) > 59 ? t(r[2], r[3], 0, r[4]) : t(r[1], r[2], r[3], r[4]) : null
								}
								var a = function() {
									function e() {
										this.values = Object.create(null)
									}
									var t = e.prototype;
									return t.set = function(e, t) {
										this.get(e) || "" === t || (this.values[e] = t)
									}, t.get = function(e, t, r) {
										return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t
									}, t.has = function(e) {
										return e in this.values
									}, t.alt = function(e, t, r) {
										for (var n = 0; n < r.length; ++n)
											if (t === r[n]) {
												this.set(e, t);
												break
											}
									}, t.integer = function(e, t) {
										/^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
									}, t.percent = function(e, t) {
										if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
											var r = parseFloat(t);
											if (r >= 0 && r <= 100) return this.set(e, r), !0
										}
										return !1
									}, e
								}();

								function o(e, t, r, n) {
									var i = n ? e.split(n) : [e];
									for (var s in i)
										if ("string" == typeof i[s]) {
											var a = i[s].split(r);
											2 === a.length && t(a[0], a[1])
										}
								}
								var l = new n.default(0, 0, ""),
									u = "middle" === l.align ? "middle" : "center";

								function c(e, t, r) {
									var n = e;

									function i() {
										var t = s(e);
										if (null === t) throw new Error("Malformed timestamp: " + n);
										return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t
									}

									function c() {
										e = e.replace(/^\s+/, "")
									}
									if (c(), t.startTime = i(), c(), "--\x3e" !== e.substr(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + n);
									e = e.substr(3), c(), t.endTime = i(), c(),
										function(e, t) {
											var n = new a;
											o(e, (function(e, t) {
												var i;
												switch (e) {
													case "region":
														for (var s = r.length - 1; s >= 0; s--)
															if (r[s].id === t) {
																n.set(e, r[s].region);
																break
															} break;
													case "vertical":
														n.alt(e, t, ["rl", "lr"]);
														break;
													case "line":
														i = t.split(","), n.integer(e, i[0]), n.percent(e, i[0]) && n.set("snapToLines", !1), n.alt(e, i[0], ["auto"]), 2 === i.length && n.alt("lineAlign", i[1], ["start", u, "end"]);
														break;
													case "position":
														i = t.split(","), n.percent(e, i[0]), 2 === i.length && n.alt("positionAlign", i[1], ["start", u, "end", "line-left", "line-right", "auto"]);
														break;
													case "size":
														n.percent(e, t);
														break;
													case "align":
														n.alt(e, t, ["start", u, "end", "left", "right"])
												}
											}), /:/, /\s/), t.region = n.get("region", null), t.vertical = n.get("vertical", "");
											var i = n.get("line", "auto");
											"auto" === i && -1 === l.line && (i = -1), t.line = i, t.lineAlign = n.get("lineAlign", "start"), t.snapToLines = n.get("snapToLines", !0), t.size = n.get("size", 100), t.align = n.get("align", u);
											var s = n.get("position", "auto");
											"auto" === s && 50 === l.position && (s = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50), t.position = s
										}(e, t)
								}

								function d(e) {
									return e.replace(/<br(?: \/)?>/gi, "\n")
								}
								var f = function() {
									function e() {
										this.state = "INITIAL", this.buffer = "", this.decoder = new i, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
									}
									var t = e.prototype;
									return t.parse = function(e) {
										var t = this;

										function r() {
											var e = t.buffer,
												r = 0;
											for (e = d(e); r < e.length && "\r" !== e[r] && "\n" !== e[r];) ++r;
											var n = e.substr(0, r);
											return "\r" === e[r] && ++r, "\n" === e[r] && ++r, t.buffer = e.substr(r), n
										}
										e && (t.buffer += t.decoder.decode(e, {
											stream: !0
										}));
										try {
											var i = "";
											if ("INITIAL" === t.state) {
												if (!/\r\n|\n/.test(t.buffer)) return this;
												var s = (i = r())
													.match(/^()?WEBVTT([ \t].*)?$/);
												if (!s || !s[0]) throw new Error("Malformed WebVTT signature.");
												t.state = "HEADER"
											}
											for (var a = !1; t.buffer;) {
												if (!/\r\n|\n/.test(t.buffer)) return this;
												switch (a ? a = !1 : i = r(), t.state) {
													case "HEADER":
														/:/.test(i) ? o(i, (function(e, t) {}), /:/) : i || (t.state = "ID");
														continue;
													case "NOTE":
														i || (t.state = "ID");
														continue;
													case "ID":
														if (/^NOTE($|[ \t])/.test(i)) {
															t.state = "NOTE";
															break
														}
														if (!i) continue;
														if (t.cue = new n.default(0, 0, ""), t.state = "CUE", -1 === i.indexOf("--\x3e")) {
															t.cue.id = i;
															continue
														}
													case "CUE":
														if (!t.cue) {
															t.state = "BADCUE";
															continue
														}
														try {
															c(i, t.cue, t.regionList)
														} catch (e) {
															t.cue = null, t.state = "BADCUE";
															continue
														}
														t.state = "CUETEXT";
														continue;
													case "CUETEXT":
														var l = -1 !== i.indexOf("--\x3e");
														if (!i || l && (a = !0)) {
															t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
															continue
														}
														if (null === t.cue) continue;
														t.cue.text && (t.cue.text += "\n"), t.cue.text += i;
														continue;
													case "BADCUE":
														i || (t.state = "ID")
												}
											}
										} catch (e) {
											"CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE"
										}
										return this
									}, t.flush = function() {
										var e = this;
										try {
											if ((e.cue || "HEADER" === e.state) && (e.buffer += "\n\n", e.parse()), "INITIAL" === e.state || "BADWEBVTT" === e.state) throw new Error("Malformed WebVTT signature.")
										} catch (t) {
											e.onparsingerror && e.onparsingerror(t)
										}
										return e.onflush && e.onflush(), this
									}, e
								}()
							},
							"./src/utils/webvtt-parser.ts": function(e, t, r) {
								"use strict";
								r.r(t), r.d(t, "generateCueId", (function() {
									return d
								})), r.d(t, "parseWebVTT", (function() {
									return f
								}));
								var n = r("./src/polyfills/number.ts"),
									i = r("./src/utils/vttparser.ts"),
									s = r("./src/demux/id3.ts"),
									a = r("./src/utils/timescale-conversion.ts"),
									o = r("./src/remux/mp4-remuxer.ts"),
									l = /\r\n|\n\r|\n|\r/g,
									u = function(e, t, r) {
										return void 0 === r && (r = 0), e.substr(r, t.length) === t
									},
									c = function(e) {
										for (var t = 5381, r = e.length; r;) t = 33 * t ^ e.charCodeAt(--r);
										return (t >>> 0)
											.toString()
									};

								function d(e, t, r) {
									return c(e.toString()) + c(t.toString()) + c(r)
								}

								function f(e, t, r, c, f, h, g, v) {
									var p, m = new i.VTTParser,
										y = Object(s.utf8ArrayToStr)(new Uint8Array(e))
										.trim()
										.replace(l, "\n")
										.split("\n"),
										b = [],
										E = Object(a.toMpegTsClockFromTimescale)(t, r),
										_ = "00:00.000",
										T = 0,
										S = 0,
										A = !0,
										L = !1;
									m.oncue = function(e) {
										var t = c[f],
											r = c.ccOffset,
											n = (T - E) / 9e4;
										if (null != t && t.new && (void 0 !== S ? r = c.ccOffset = t.start : function(e, t, r) {
											var n = e[t],
												i = e[n.prevCC];
											if (!i || !i.new && n.new) return e.ccOffset = e.presentationOffset = n.start, void(n.new = !1);
											for (; null !== (s = i) && void 0 !== s && s.new;) {
												var s;
												e.ccOffset += n.start - i.start, n.new = !1, i = e[(n = i)
													.prevCC]
											}
											e.presentationOffset = r
										}(c, f, n)), n && (r = n - c.presentationOffset), L) {
											var i = e.endTime - e.startTime,
												s = Object(o.normalizePts)(9e4 * (e.startTime + r - S), 9e4 * h) / 9e4;
											e.startTime = s, e.endTime = s + i
										}
										var a = e.text.trim();
										e.text = decodeURIComponent(encodeURIComponent(a)), e.id || (e.id = d(e.startTime, e.endTime, a)), e.endTime > 0 && b.push(e)
									}, m.onparsingerror = function(e) {
										p = e
									}, m.onflush = function() {
										p ? v(p) : g(b)
									}, y.forEach((function(e) {
										if (A) {
											if (u(e, "X-TIMESTAMP-MAP=")) {
												A = !1, L = !0, e.substr(16)
													.split(",")
													.forEach((function(e) {
														u(e, "LOCAL:") ? _ = e.substr(6) : u(e, "MPEGTS:") && (T = parseInt(e.substr(7)))
													}));
												try {
													S = function(e) {
														var t = parseInt(e.substr(-3)),
															r = parseInt(e.substr(-6, 2)),
															i = parseInt(e.substr(-9, 2)),
															s = e.length > 9 ? parseInt(e.substr(0, e.indexOf(":"))) : 0;
														if (!(Object(n.isFiniteNumber)(t) && Object(n.isFiniteNumber)(r) && Object(n.isFiniteNumber)(i) && Object(n.isFiniteNumber)(s))) throw Error("Malformed X-TIMESTAMP-MAP: Local:" + e);
														return t += 1e3 * r, (t += 6e4 * i) + 36e5 * s
													}(_) / 1e3
												} catch (e) {
													L = !1, p = e
												}
												return
											}
											"" === e && (A = !1)
										}
										m.parse(e + "\n")
									})), m.flush()
								}
							},
							"./src/utils/xhr-loader.ts": function(e, t, r) {
								"use strict";
								r.r(t);
								var n = r("./src/utils/logger.ts"),
									i = r("./src/loader/load-stats.ts"),
									s = /^age:\s*[\d.]+\s*$/m,
									a = function() {
										function e(e) {
											this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e ? e.xhrSetup : null, this.stats = new i.LoadStats, this.retryDelay = 0
										}
										var t = e.prototype;
										return t.destroy = function() {
											this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null
										}, t.abortInternal = function() {
											var e = this.loader;
											self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort()))
										}, t.abort = function() {
											var e;
											this.abortInternal(), null !== (e = this.callbacks) && void 0 !== e && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
										}, t.load = function(e, t, r) {
											if (this.stats.loading.start) throw new Error("Loader can only be used once.");
											this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.retryDelay = t.retryDelay, this.loadInternal()
										}, t.loadInternal = function() {
											var e = this.config,
												t = this.context;
											if (e) {
												var r = this.loader = new self.XMLHttpRequest,
													n = this.stats;
												n.loading.first = 0, n.loaded = 0;
												var i = this.xhrSetup;
												try {
													if (i) try {
														i(r, t.url)
													} catch (e) {
														r.open("GET", t.url, !0), i(r, t.url)
													}
													r.readyState || r.open("GET", t.url, !0);
													var s = this.context.headers;
													if (s)
														for (var a in s) r.setRequestHeader(a, s[a])
												} catch (e) {
													return void this.callbacks.onError({
														code: r.status,
														text: e.message
													}, t, r)
												}
												t.rangeEnd && r.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), r.onreadystatechange = this.readystatechange.bind(this), r.onprogress = this.loadprogress.bind(this), r.responseType = t.responseType, self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), e.timeout), r.send()
											}
										}, t.readystatechange = function() {
											var e = this.context,
												t = this.loader,
												r = this.stats;
											if (e && t) {
												var i = t.readyState,
													s = this.config;
												if (!r.aborted && i >= 2)
													if (self.clearTimeout(this.requestTimeout), 0 === r.loading.first && (r.loading.first = Math.max(self.performance.now(), r.loading.start)), 4 === i) {
														t.onreadystatechange = null, t.onprogress = null;
														var a = t.status;
														if (a >= 200 && a < 300) {
															var o, l;
															if (r.loading.end = Math.max(self.performance.now(), r.loading.first), l = "arraybuffer" === e.responseType ? (o = t.response)
																.byteLength : (o = t.responseText)
																.length, r.loaded = r.total = l, !this.callbacks) return;
															var u = this.callbacks.onProgress;
															if (u && u(r, e, o, t), !this.callbacks) return;
															var c = {
																url: t.responseURL,
																data: o
															};
															this.callbacks.onSuccess(c, r, e, t)
														} else r.retry >= s.maxRetry || a >= 400 && a < 499 ? (n.logger.error(a + " while loading " + e.url), this.callbacks.onError({
															code: a,
															text: t.statusText
														}, e, t)) : (n.logger.warn(a + " while loading " + e.url + ", retrying in " + this.retryDelay + "..."), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, s.maxRetryDelay), r.retry++)
													} else self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.timeout)
											}
										}, t.loadtimeout = function() {
											n.logger.warn("timeout while loading " + this.context.url);
											var e = this.callbacks;
											e && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader))
										}, t.loadprogress = function(e) {
											var t = this.stats;
											t.loaded = e.loaded, e.lengthComputable && (t.total = e.total)
										}, t.getCacheAge = function() {
											var e = null;
											if (this.loader && s.test(this.loader.getAllResponseHeaders())) {
												var t = this.loader.getResponseHeader("age");
												e = t ? parseFloat(t) : null
											}
											return e
										}, e
									}();
								t.default = a
							}
						})
						.default
				}, e.exports = t())
			},
			760: (e, t, r) => {
				"use strict";
				r.r(t), r.d(t, {
					default: () => f
				});
				var n = function(e, t) {
					return n = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(e, t) {
						e.__proto__ = t
					} || function(e, t) {
						for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
					}, n(e, t)
				};

				function i(e, t) {
					function r() {
						this.constructor = e
					}
					n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
				}

				function s(e, t) {
					var r = "function" == typeof Symbol && e[Symbol.iterator];
					if (!r) return e;
					var n, i, s = r.call(e),
						a = [];
					try {
						for (;
							(void 0 === t || t-- > 0) && !(n = s.next())
							.done;) a.push(n.value)
					} catch (e) {
						i = {
							error: e
						}
					} finally {
						try {
							n && !n.done && (r = s.return) && r.call(s)
						} finally {
							if (i) throw i.error
						}
					}
					return a
				}

				function a() {
					for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(s(arguments[t]));
					return e
				}
				var o = function(e, t) {
						this.target = t, this.type = e
					},
					l = function(e) {
						function t(t, r) {
							var n = e.call(this, "error", r) || this;
							return n.message = t.message, n.error = t, n
						}
						return i(t, e), t
					}(o),
					u = function(e) {
						function t(t, r, n) {
							void 0 === t && (t = 1e3), void 0 === r && (r = "");
							var i = e.call(this, "close", n) || this;
							return i.wasClean = !0, i.code = t, i.reason = r, i
						}
						return i(t, e), t
					}(o),
					c = function() {
						if ("undefined" != typeof WebSocket) return WebSocket
					},
					d = {
						maxReconnectionDelay: 1e4,
						minReconnectionDelay: 1e3 + 4e3 * Math.random(),
						minUptime: 5e3,
						reconnectionDelayGrowFactor: 1.3,
						connectionTimeout: 4e3,
						maxRetries: 1 / 0,
						maxEnqueuedMessages: 1 / 0,
						startClosed: !1,
						debug: !1
					};
				const f = function() {
					function e(e, t, r) {
						var n = this;
						void 0 === r && (r = {}), this._listeners = {
							error: [],
							message: [],
							open: [],
							close: []
						}, this._retryCount = -1, this._shouldReconnect = !0, this._connectLock = !1, this._binaryType = "blob", this._closeCalled = !1, this._messageQueue = [], this.onclose = null, this.onerror = null, this.onmessage = null, this.onopen = null, this._handleOpen = function(e) {
							n._debug("open event");
							var t = n._options.minUptime,
								r = void 0 === t ? d.minUptime : t;
							clearTimeout(n._connectTimeout), n._uptimeTimeout = setTimeout((function() {
								return n._acceptOpen()
							}), r), n._ws.binaryType = n._binaryType, n._messageQueue.forEach((function(e) {
								return n._ws.send(e)
							})), n._messageQueue = [], n.onopen && n.onopen(e), n._listeners.open.forEach((function(t) {
								return n._callEventListener(e, t)
							}))
						}, this._handleMessage = function(e) {
							n._debug("message event"), n.onmessage && n.onmessage(e), n._listeners.message.forEach((function(t) {
								return n._callEventListener(e, t)
							}))
						}, this._handleError = function(e) {
							n._debug("error event", e.message), n._disconnect(void 0, "TIMEOUT" === e.message ? "timeout" : void 0), n.onerror && n.onerror(e), n._debug("exec error listeners"), n._listeners.error.forEach((function(t) {
								return n._callEventListener(e, t)
							})), n._connect()
						}, this._handleClose = function(e) {
							n._debug("close event"), n._clearTimeouts(), n._shouldReconnect && n._connect(), n.onclose && n.onclose(e), n._listeners.close.forEach((function(t) {
								return n._callEventListener(e, t)
							}))
						}, this._url = e, this._protocols = t, this._options = r, this._options.startClosed && (this._shouldReconnect = !1), this._connect()
					}
					return Object.defineProperty(e, "CONNECTING", {
						get: function() {
							return 0
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e, "OPEN", {
						get: function() {
							return 1
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e, "CLOSING", {
						get: function() {
							return 2
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e, "CLOSED", {
						get: function() {
							return 3
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "CONNECTING", {
						get: function() {
							return e.CONNECTING
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "OPEN", {
						get: function() {
							return e.OPEN
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "CLOSING", {
						get: function() {
							return e.CLOSING
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "CLOSED", {
						get: function() {
							return e.CLOSED
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "binaryType", {
						get: function() {
							return this._ws ? this._ws.binaryType : this._binaryType
						},
						set: function(e) {
							this._binaryType = e, this._ws && (this._ws.binaryType = e)
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "retryCount", {
						get: function() {
							return Math.max(this._retryCount, 0)
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "bufferedAmount", {
						get: function() {
							return this._messageQueue.reduce((function(e, t) {
								return "string" == typeof t ? e += t.length : t instanceof Blob ? e += t.size : e += t.byteLength, e
							}), 0) + (this._ws ? this._ws.bufferedAmount : 0)
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "extensions", {
						get: function() {
							return this._ws ? this._ws.extensions : ""
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "protocol", {
						get: function() {
							return this._ws ? this._ws.protocol : ""
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "readyState", {
						get: function() {
							return this._ws ? this._ws.readyState : this._options.startClosed ? e.CLOSED : e.CONNECTING
						},
						enumerable: !0,
						configurable: !0
					}), Object.defineProperty(e.prototype, "url", {
						get: function() {
							return this._ws ? this._ws.url : ""
						},
						enumerable: !0,
						configurable: !0
					}), e.prototype.close = function(e, t) {
						void 0 === e && (e = 1e3), this._closeCalled = !0, this._shouldReconnect = !1, this._clearTimeouts(), this._ws ? this._ws.readyState !== this.CLOSED ? this._ws.close(e, t) : this._debug("close: already closed") : this._debug("close enqueued: no ws instance")
					}, e.prototype.reconnect = function(e, t) {
						this._shouldReconnect = !0, this._closeCalled = !1, this._retryCount = -1, this._ws && this._ws.readyState !== this.CLOSED ? (this._disconnect(e, t), this._connect()) : this._connect()
					}, e.prototype.send = function(e) {
						if (this._ws && this._ws.readyState === this.OPEN) this._debug("send", e), this._ws.send(e);
						else {
							var t = this._options.maxEnqueuedMessages,
								r = void 0 === t ? d.maxEnqueuedMessages : t;
							this._messageQueue.length < r && (this._debug("enqueue", e), this._messageQueue.push(e))
						}
					}, e.prototype.addEventListener = function(e, t) {
						this._listeners[e] && this._listeners[e].push(t)
					}, e.prototype.dispatchEvent = function(e) {
						var t, r, n = this._listeners[e.type];
						if (n) try {
							for (var i = function(e) {
								var t = "function" == typeof Symbol && e[Symbol.iterator],
									r = 0;
								return t ? t.call(e) : {
									next: function() {
										return e && r >= e.length && (e = void 0), {
											value: e && e[r++],
											done: !e
										}
									}
								}
							}(n), s = i.next(); !s.done; s = i.next()) {
								var a = s.value;
								this._callEventListener(e, a)
							}
						} catch (e) {
							t = {
								error: e
							}
						} finally {
							try {
								s && !s.done && (r = i.return) && r.call(i)
							} finally {
								if (t) throw t.error
							}
						}
						return !0
					}, e.prototype.removeEventListener = function(e, t) {
						this._listeners[e] && (this._listeners[e] = this._listeners[e].filter((function(e) {
							return e !== t
						})))
					}, e.prototype._debug = function() {
						for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
						this._options.debug && console.log.apply(console, a(["RWS>"], e))
					}, e.prototype._getNextDelay = function() {
						var e = this._options,
							t = e.reconnectionDelayGrowFactor,
							r = void 0 === t ? d.reconnectionDelayGrowFactor : t,
							n = e.minReconnectionDelay,
							i = void 0 === n ? d.minReconnectionDelay : n,
							s = e.maxReconnectionDelay,
							a = void 0 === s ? d.maxReconnectionDelay : s,
							o = 0;
						return this._retryCount > 0 && (o = i * Math.pow(r, this._retryCount - 1)) > a && (o = a), this._debug("next delay", o), o
					}, e.prototype._wait = function() {
						var e = this;
						return new Promise((function(t) {
							setTimeout(t, e._getNextDelay())
						}))
					}, e.prototype._getNextUrl = function(e) {
						if ("string" == typeof e) return Promise.resolve(e);
						if ("function" == typeof e) {
							var t = e();
							if ("string" == typeof t) return Promise.resolve(t);
							if (t.then) return t
						}
						throw Error("Invalid URL")
					}, e.prototype._connect = function() {
						var e = this;
						if (!this._connectLock && this._shouldReconnect) {
							this._connectLock = !0;
							var t = this._options,
								r = t.maxRetries,
								n = void 0 === r ? d.maxRetries : r,
								i = t.connectionTimeout,
								s = void 0 === i ? d.connectionTimeout : i,
								a = t.WebSocket,
								o = void 0 === a ? c() : a;
							if (this._retryCount >= n) this._debug("max retries reached", this._retryCount, ">=", n);
							else {
								if (this._retryCount++, this._debug("connect", this._retryCount), this._removeListeners(), void 0 === (l = o) || !l || 2 !== l.CLOSING) throw Error("No valid WebSocket class provided");
								var l;
								this._wait()
									.then((function() {
										return e._getNextUrl(e._url)
									}))
									.then((function(t) {
										e._closeCalled || (e._debug("connect", {
											url: t,
											protocols: e._protocols
										}), e._ws = e._protocols ? new o(t, e._protocols) : new o(t), e._ws.binaryType = e._binaryType, e._connectLock = !1, e._addListeners(), e._connectTimeout = setTimeout((function() {
											return e._handleTimeout()
										}), s))
									}))
							}
						}
					}, e.prototype._handleTimeout = function() {
						this._debug("timeout event"), this._handleError(new l(Error("TIMEOUT"), this))
					}, e.prototype._disconnect = function(e, t) {
						if (void 0 === e && (e = 1e3), this._clearTimeouts(), this._ws) {
							this._removeListeners();
							try {
								this._ws.close(e, t), this._handleClose(new u(e, t, this))
							} catch (e) {}
						}
					}, e.prototype._acceptOpen = function() {
						this._debug("accept open"), this._retryCount = 0
					}, e.prototype._callEventListener = function(e, t) {
						"handleEvent" in t ? t.handleEvent(e) : t(e)
					}, e.prototype._removeListeners = function() {
						this._ws && (this._debug("removeListeners"), this._ws.removeEventListener("open", this._handleOpen), this._ws.removeEventListener("close", this._handleClose), this._ws.removeEventListener("message", this._handleMessage), this._ws.removeEventListener("error", this._handleError))
					}, e.prototype._addListeners = function() {
						this._ws && (this._debug("addListeners"), this._ws.addEventListener("open", this._handleOpen), this._ws.addEventListener("close", this._handleClose), this._ws.addEventListener("message", this._handleMessage), this._ws.addEventListener("error", this._handleError))
					}, e.prototype._clearTimeouts = function() {
						clearTimeout(this._connectTimeout), clearTimeout(this._uptimeTimeout)
					}, e
				}()
			},
			622: function(e) {
				var t, r, n, i, s;
				t = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, r = /^(?=([^\/?#]*))\1([^]*)$/, n = /(?:\/|^)\.(?=\/)/g, i = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, s = {
					buildAbsoluteURL: function(e, t, n) {
						if (n = n || {}, e = e.trim(), !(t = t.trim())) {
							if (!n.alwaysNormalize) return e;
							var i = s.parseURL(e);
							if (!i) throw new Error("Error trying to parse base URL.");
							return i.path = s.normalizePath(i.path), s.buildURLFromParts(i)
						}
						var a = s.parseURL(t);
						if (!a) throw new Error("Error trying to parse relative URL.");
						if (a.scheme) return n.alwaysNormalize ? (a.path = s.normalizePath(a.path), s.buildURLFromParts(a)) : t;
						var o = s.parseURL(e);
						if (!o) throw new Error("Error trying to parse base URL.");
						if (!o.netLoc && o.path && "/" !== o.path[0]) {
							var l = r.exec(o.path);
							o.netLoc = l[1], o.path = l[2]
						}
						o.netLoc && !o.path && (o.path = "/");
						var u = {
							scheme: o.scheme,
							netLoc: a.netLoc,
							path: null,
							params: a.params,
							query: a.query,
							fragment: a.fragment
						};
						if (!a.netLoc && (u.netLoc = o.netLoc, "/" !== a.path[0]))
							if (a.path) {
								var c = o.path,
									d = c.substring(0, c.lastIndexOf("/") + 1) + a.path;
								u.path = s.normalizePath(d)
							} else u.path = o.path, a.params || (u.params = o.params, a.query || (u.query = o.query));
						return null === u.path && (u.path = n.alwaysNormalize ? s.normalizePath(a.path) : a.path), s.buildURLFromParts(u)
					},
					parseURL: function(e) {
						var r = t.exec(e);
						return r ? {
							scheme: r[1] || "",
							netLoc: r[2] || "",
							path: r[3] || "",
							params: r[4] || "",
							query: r[5] || "",
							fragment: r[6] || ""
						} : null
					},
					normalizePath: function(e) {
						for (e = e.split("")
							.reverse()
							.join("")
							.replace(n, ""); e.length !== (e = e.replace(i, ""))
							.length;);
						return e.split("")
							.reverse()
							.join("")
					},
					buildURLFromParts: function(e) {
						return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
					}
				}, e.exports = s
			}
		},
		__webpack_module_cache__ = {};

	function __webpack_require__(e) {
		var t = __webpack_module_cache__[e];
		if (void 0 !== t) return t.exports;
		var r = __webpack_module_cache__[e] = {
			exports: {}
		};
		return __webpack_modules__[e].call(r.exports, r, r.exports, __webpack_require__), r.exports
	}
	__webpack_require__.d = (e, t) => {
		for (var r in t) __webpack_require__.o(t, r) && !__webpack_require__.o(e, r) && Object.defineProperty(e, r, {
			enumerable: !0,
			get: t[r]
		})
	}, __webpack_require__.g = function() {
		if ("object" == typeof globalThis) return globalThis;
		try {
			return this || new Function("return this")()
		} catch (e) {
			if ("object" == typeof window) return window
		}
	}(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = e => {
		"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
			value: "Module"
		}), Object.defineProperty(e, "__esModule", {
			value: !0
		})
	};
	var __webpack_exports__ = __webpack_require__(53);
	return __webpack_exports__
})()));